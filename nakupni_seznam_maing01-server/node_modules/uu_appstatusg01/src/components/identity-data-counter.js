"use strict";

const ResponseMap = require("./response-map");
const NestedResponseMap = require("./nested-response-map");

// Identity types in session
const KNOWN_IDENTITY_TYPES = ["uuPerson", "uuEe", "uuThing", "uuAI"];
// Identity types that are defined mapped to a group
const KNOWN_GROUP_IDENTITY_TYPES = ["uuAsidEe", "uuAwidEe"];
// Aggregate-only identity types
const KNOWN_AGGREGATE_ONLY_IDENTITY_TYPES = ["uuUnknown"];

// Identity types to be created as empty objects so as to include them in the response map even if none have been logged
const TRACKED_IDENTITY_TYPES = [...KNOWN_IDENTITY_TYPES, ...KNOWN_GROUP_IDENTITY_TYPES];
const TRACKED_AGGREGATE_IDENTITY_TYPES = [
  ...KNOWN_IDENTITY_TYPES,
  ...KNOWN_GROUP_IDENTITY_TYPES,
  ...KNOWN_AGGREGATE_ONLY_IDENTITY_TYPES,
];
const IDENTITY_CALLS_SUFFIX = "Map";
const AGGREGATE_CALLS_SUFFIX = "Calls";

/**
 * @typedef {import("./app-status-counter.js").ResData} ResData
 */

/**
 * @class
 * @classdesc Counter that tracks call statistics by caller identity and client identity.
 */
class IdentityDataCounter {
  constructor() {
    this.reset();
  }

  /**
   * Resets the counter
   */
  reset() {
    this._identityCallsMap = new NestedResponseMap();
    this._aggregateCallsMap = new ResponseMap();
    this._clientIdentityCallsMap = new ResponseMap();

    // initialize identity calls map with blank values
    TRACKED_IDENTITY_TYPES.forEach((type) => {
      this._identityCallsMap.create(type + IDENTITY_CALLS_SUFFIX);
    });

    // initialize aggregate calls map with blank values
    TRACKED_AGGREGATE_IDENTITY_TYPES.forEach((type) => {
      this._aggregateCallsMap.create(type + AGGREGATE_CALLS_SUFFIX);
    });
  }

  /**
   * Records uc statics for a call by caller identity and client identity
   * @param {ResData} resData
   */
  record(resData) {
    // record caller identity
    if (resData.identityType) {
      let loggedIdentityType = resData.identityType;
      switch (resData.identityType) {
        case "uuUnknown": // uuUnknown corresponds to a single identity - 0-0 and is only logged in aggregate
          this._recordAggregate(loggedIdentityType, resData);
          break;
        default:
          // uuPerson, uuEe, uuThing, uuAI, uuAsidEe, uuAwidEe etc. are logged as individual identities both in aggregate and by caller identity
          this._recordIdentity(loggedIdentityType, resData.uuId, resData);
          this._recordAggregate(loggedIdentityType, resData);
      }
    }

    // record client identity
    if (resData.clientAppKey) {
      this._recordClientIdentity(resData.clientAppKey, resData);
    }
  }

  _recordIdentity(type, identifier, resData) {
    this._identityCallsMap
      .get(type + IDENTITY_CALLS_SUFFIX)
      .get(identifier)
      .record(resData.statusCode, resData.reqTime);
  }

  _recordAggregate(type, resData) {
    this._aggregateCallsMap.get(type + AGGREGATE_CALLS_SUFFIX).record(resData.statusCode, resData.reqTime);
  }

  _recordClientIdentity(clientIdentifier, resData) {
    this._clientIdentityCallsMap.get(clientIdentifier).record(resData.statusCode, resData.reqTime);
  }

  getData() {
    const identityCallsData = this._identityCallsMap.getData();
    const uniqueIdentityCount = Object.values(identityCallsData).reduce((identifiers, responseMap) => {
      Object.keys(responseMap).forEach((identifier) => identifiers.add(identifier));
      return identifiers;
    }, new Set()).size;
    return {
      uniqueIdentityCount,
      ...this._aggregateCallsMap.getData(),
      ...identityCallsData,
      uuAppKeyMap: this._clientIdentityCallsMap.getData(),
    };
  }
}

module.exports = new IdentityDataCounter();
