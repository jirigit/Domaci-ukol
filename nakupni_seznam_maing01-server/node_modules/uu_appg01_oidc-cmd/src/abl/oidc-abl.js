"use strict";

const { Config } = require("uu_appg01_core-utils");
const { Uri, UriBuilder } = require("uu_appg01_core-uri");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { ValidationHelper, UseCaseError } = require("uu_appg01_core-appserver");
const { AppClient, SessionHandler } = require("uu_appg01_core-appclient");
const { AuthenticationService } = require("uu_appg01_core-authentication");
const ClientCredentialsHandler = require("./client-credentials-handler.js");
const { UuSubAppInstance, UuAppWorkspace } = require("uu_appg01_workspace");
const Errors = require("../api/errors/oidc-errors.js");

const ASID = Config.get("asid");
const DEFAULT_PROVIDER_NAME = "oidcg02";

class OidcAbl {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.oidc.appserver.OidcAbl");
    this.validator = Validator.load();
  }

  async initOidcClient(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcInitOidcClientDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.InitOidcClient.UC_CODE}unsupportedKeys`,
      Errors.InitOidcClient.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.clientId) {
      dtoIn.clientId = dtoIn.awid;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 3
    let awid = dtoIn.awid;
    if (awid === ASID) {
      try {
        await UuSubAppInstance.get(ASID);
      } catch (e) {
        //A3
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppNotInitialized({ uuAppErrorMap }, { asid: ASID }, e);
        }
        throw e;
      }
    } else {
      try {
        await UuAppWorkspace.get(awid);
      } catch (e) {
        // A4
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppWorkspaceNotInitialized({ uuAppErrorMap }, { awid }, e);
        }
        throw e;
      }
    }

    // HDS 4
    let providerName = dtoIn.providerName;
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(awid, providerName, session);
    } catch (e) {
      // A5
      throw new Errors.InitOidcClient.IntegrationNotEnabled({ uuAppErrorMap }, { providerName }, e);
    }

    // HDS 5
    let clientId = dtoIn.clientId;
    let oidcConfig;
    let setPublicKeyDtoOut;
    if (dtoIn.clientSecret) {
      // HDS 5.1
      let authenticationService = AuthenticationService.get(providerName);
      try {
        // AuthenticationService.authenticate() does not allow login via clientId and clientSecret,
        // so we utilize the private attribute _oauthClient to check validity of clientSecret
        await authenticationService._oauthClient.grantClientCredentialsToken({client_id: clientId, client_secret: dtoIn.clientSecret});
      } catch (e) {
        // A6
        throw new Errors.InitOidcClient.InvalidCredentials({ uuAppErrorMap }, { clientId, providerName }, e);
      }
      oidcConfig = { clientSecret: dtoIn.clientSecret };
    } else {
      // HDS 5.2
      let keyPair = await ClientCredentialsHandler.generateClientKeyPair();
      let setPublicKeyDtoIn = { clientId, publicKey: keyPair.publicKey };
      if (dtoIn.credentialsInitToken) {
        setPublicKeyDtoIn.credentialsInitToken = dtoIn.credentialsInitToken;
      }
      try {
        setPublicKeyDtoOut = await oidcServerClient.post("authOidcClient/setPublicKey", setPublicKeyDtoIn);
      } catch (e) {
        if (e.code && e.code.endsWith("/oidcClientNotExist")) {
          // A7
          throw new Errors.InitOidcClient.OidcClientDoesNotExist({uuAppErrorMap}, {clientId}, e);
        } else if (e.code && e.code.endsWith("/invalidInitToken")) {
          // A8
          throw new Errors.InitOidcClient.InvalidCredentialsInitToken({uuAppErrorMap}, {clientId}, e);
        } else {
          // A9
          throw new Errors.InitOidcClient.RegistrationOfPublicKeyFailed({ uuAppErrorMap }, { clientId, providerName }, e);
        }
      }
      oidcConfig = { keyPair };
    }

    // HDS 6
    try {
      await ClientCredentialsHandler.configureOidcClient(awid, providerName, clientId, oidcConfig);
    } catch (e) {
      // A10
      throw new Errors.InitOidcClient.StoringOfOidcClientConfigurationFailed({ uuAppErrorMap }, { clientId }, e);
    }

    // HDS 7
    oidcServerClient = await this._getOidcServerClient(awid, providerName, session);

    // HDS 8
    let oidcClient;
    try {
      oidcClient = (await oidcServerClient.get("oidcClient/get", { clientId })).oidcClient;
    } catch (e) {
      // A11
      throw new Errors.InitOidcClient.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }

    // HDS 9
    let defaultRedirectUriBuilder = UriBuilder.parse(uri);
    defaultRedirectUriBuilder.setAwid(awid);
    defaultRedirectUriBuilder.setUseCase("oidc/callback");
    defaultRedirectUriBuilder.clearParameters();
    let defaultRedirectUri = defaultRedirectUriBuilder.toUri().toString();
    let redirectUriList = oidcClient.redirectUriList || [];
    if (!redirectUriList.includes(defaultRedirectUri)) {
      redirectUriList.push(defaultRedirectUri);
    }
    if (redirectUriList.length > 16) {
      // A12
      let message = `Redirect uri list of OidcClient ${clientId} is greater than 16. Default redirect uri ${defaultRedirectUri} was not set. Use oidc/setAllowedRedirects to set required redirects.`;
      let params = { clientId, redirectUri: defaultRedirectUri };
      ValidationHelper.addWarning(uuAppErrorMap, `${Errors.InitOidcClient.UC_CODE}tooManyRedirectUris`, message, params);
      this.logger.error(message);
    } else {
      let updateClientDtoIn = { clientId, redirectUriList };
      try {
        oidcClient = (await oidcServerClient.post("oidcClient/update", updateClientDtoIn)).oidcClient;
      } catch (e) {
        // A13
        throw new Errors.InitOidcClient.UpdateOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
      }
    }

    // HDS 10
    return {
      clientId: oidcClient.clientId,
      credentialsId: setPublicKeyDtoOut && setPublicKeyDtoOut.credentials.id,
      publicKey: setPublicKeyDtoOut && setPublicKeyDtoOut.publicKey,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async setAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcSetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAllowedRedirects.UC_CODE}unsupportedKeys`,
      Errors.SetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.awid, dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = { providerName: dtoIn.providerName };
      throw new Errors.SetAllowedRedirects.IntegrationNotEnabled({ uuAppErrorMap }, params, e);
    }

    // HDS 3
    let clientId;
    try {
      clientId = await ClientCredentialsHandler.getClientId(dtoIn.providerName, dtoIn.awid);
    } catch (e) {
      // A4
      throw new Errors.SetAllowedRedirects.LoadingOfOidcClientConfigurationFailed({ uuAppErrorMap }, e);
    }
    if (!clientId) {
      // A5
      let params = { providerName: dtoIn.providerName };
      throw new Errors.SetAllowedRedirects.NoOidcClientConfigured({ uuAppErrorMap }, params);
    }

    // HDS 4
    let getClientDtoOut;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", { clientId });
    } catch (e) {
      // A6
      throw new Errors.SetAllowedRedirects.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.SetAllowedRedirects.OidcClientDoesNotExist({ uuAppErrorMap }, { clientId });
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS 5
    let redirectUriList = dtoIn.redirectUriList || oidcClient.redirectUriList || [];
    let postLogoutUriList = dtoIn.postLogoutUriList || oidcClient.postLogoutUriList || [];
    let updateClientDtoIn = { clientId };
    if (redirectUriList.length > 0) {
      updateClientDtoIn.redirectUriList = redirectUriList;
    }
    if (postLogoutUriList.length > 0) {
      updateClientDtoIn.postLogoutUriList = postLogoutUriList;
    }
    try {
      let updateClientDtoOut = await oidcServerClient.post("oidcClient/update", updateClientDtoIn);
      oidcClient = updateClientDtoOut.oidcClient;
    } catch (e) {
      // A8
      throw new Errors.SetAllowedRedirects.UpdateOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }

    // HDS6
    return {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async getAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcGetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.GetAllowedRedirects.UC_CODE}unsupportedKeys`,
      Errors.GetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.awid, dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = { providerName: dtoIn.providerName };
      throw new Errors.GetAllowedRedirects.IntegrationNotEnabled({ uuAppErrorMap }, params, e);
    }

    // HDS 3
    let clientId;
    try {
      clientId = await ClientCredentialsHandler.getClientId(dtoIn.providerName, dtoIn.awid);
    } catch (e) {
      // A4
      throw new Errors.GetAllowedRedirects.LoadingOfOidcClientConfigurationFailed({ uuAppErrorMap }, e);
    }
    if (!clientId) {
      // A5
      let params = { providerName: dtoIn.providerName };
      throw new Errors.GetAllowedRedirects.NoOidcClientConfigured({ uuAppErrorMap }, params);
    }

    // HDS 4
    let getClientDtoOut;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", { clientId });
    } catch (e) {
      // A6
      throw new Errors.GetAllowedRedirects.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.GetAllowedRedirects.OidcClientDoesNotExist({ uuAppErrorMap }, { clientId });
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS5
    return {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async _getOidcServerClient(awid, providerName, session) {
    let authenticationService = AuthenticationService.get(providerName);
    let baseUri = Uri.parse(await authenticationService.getServiceUri()).getBaseUri();
    let verifySsl = Config.getBoolean(`uu_app_oidc_providers_${providerName}_verify_ssl`, false);
    if (verifySsl == null) {
      verifySsl = true;
    }

    let useAuthFallback = true;
    // If awid system identity is initialized, try to authenticate as awid system identity
    if (await ClientCredentialsHandler.getClientId(providerName, awid)) {
      try {
        session = await authenticationService.authenticate({systemIdentity: awid}, baseUri);
        useAuthFallback = false;
      } catch (e) {
        if (awid === ASID) {
          this.logger.warn(`Authentication as asid system identity [${awid}] failed.`, e);
        } else {
          this.logger.warn(`Authentication as awid system identity [${awid}] failed.`, e);
        }
      }
    }
    // If we are not working with asid and asid systemIdetity is initialized, try to authenticate as asid systemIentity
    if (useAuthFallback && awid !== ASID && (await ClientCredentialsHandler.getClientId(providerName, ASID))) {
      try {
        session = await authenticationService.authenticate({systemIdentity: ASID}, baseUri);
        useAuthFallback = false;
      } catch (e) {
        this.logger.warn(`Authentication as asid system identity [${ASID}] failed.`, e);
      }
    }
    // Try to authenticate as OidcClient executive (which is by default represented by asidOwner)
    // TODO This is only fallback for backward compatibility which can be removed in future once uuEes are dropped
    if (useAuthFallback) {
      let clientExecutive = Config.get(`uu_app_oidc_providers_${providerName}_client_executive`, false) || "app_identity";
      let executiveCredentials = await AuthenticationService.get()._resolvePasswordFileCredentials(clientExecutive);
      if (typeof executiveCredentials !== "string") {
        // Disable configured client credentials as they might not be valid.
        let unregisteredClientCredentials = await ClientCredentialsHandler.getUnregisteredCredentials();
        executiveCredentials.clientCredentials = {
          client_id: unregisteredClientCredentials.clientId,
          client_secret: unregisteredClientCredentials.clientSecret
        };
        try {
          session = await authenticationService.authenticate(executiveCredentials, baseUri);
          useAuthFallback = false;
        } catch (e) {
          this.logger.warn(`Authentication as oidc client executive [${clientExecutive}] failed.`, e);
        }
      } else {
        this.logger.warn(`Unable to authenticate as oidc client executive because password file [${clientExecutive}] is not available.`);
      }
    }

    let interceptors = [...AppClient.getDefaultInterceptors(), SessionHandler];
    // Token exchange is disabled as without properly initialized system identity
    // exchange will fail and oidc server does not require matching token scope.
    // (Moreover this affects only using original user session as both system identity
    // and asid owner session are initialized with proper scope.)
    return new AppClient({baseUri, verifySsl, interceptors, session, useTokenExchange: false});
  }

}

module.exports = new OidcAbl();
