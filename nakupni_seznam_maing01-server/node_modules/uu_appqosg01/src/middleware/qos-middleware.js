"use strict";
const { Uri } = require("uu_appg01_core-uri");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { Config } = require("uu_appg01_core-utils");
const { AuditLog } = require("uu_appg01_auditlog");
const RateLimitError = require("../api/errors/sys-rate-limit-errors.js");
const RateLimitingComponent = require("../components/rate-limiting-component.js");
const SysQosConfigurationAbl = require("../abl/sys-qos-configuration-abl.js");
const RequestCountHandler = require("../components/request-count-handler.js");

const MIDDLEWARE_ORDER = -25;
const ERROR_PARAMS = [
  "totalLimitError",
  "uuIdentityTotalLimitError",
  "uuIdentityUnknownLimitError",
  "uuAppTotalLimitError",
  "uuAppUnknownLimitError",
  "uuIdentityLimitError",
  "uuAppLimitError",
];

class QosMiddleware {
  constructor() {
    this.name = "uuAppQos rate limiting Middleware";
    this.asid = Config.get("asid");
    this.order = MIDDLEWARE_ORDER;
  }

  async pre(req, res, next) {
    const uri = Uri.parse(res.locals._uu_app_uve_handler_orig_url || res.locals.uri);
    let session = res.locals.session;
    if (!session.getAuthenticationId()) {
      // empty session, oidc/callback etc...
      return next();
    }
    let uuApp;
    if (session.getClientIdentity() && session.getClientIdentity().getUuAppKey()) {
      uuApp = session.getClientIdentity().getUuAppKey().getAwid();
    }
    let quota = await SysQosConfigurationAbl.getConfiguration(this.asid);
    const clientIdentity = session.getClientIdentity();
    let reqData = {
      uuId: session.getIdentity().getUuIdentity(),
      clientUuId: clientIdentity && clientIdentity.getUuIdentity(),
      uuApp,
    };
    // processing of number of request
    let uuAppErrorMap = await RateLimitingComponent.limitRate(reqData, quota);
    if (Object.entries(uuAppErrorMap).length > 0) {
      return this._redirectWithRateIndication(req, res, next, uri, uuAppErrorMap);
    }
    return next();
  }

  async _redirectWithRateIndication(req, res, next, uri, newErrorMap) {
    let uuAppErrorMap = {};
    let errorKeys = [];
    let redirect = false;
    Object.keys(newErrorMap).forEach((key) => {
      if (redirect === false && newErrorMap[key].type === "error") {
        redirect = true;
        errorKeys.push(key);
      }
      ValidationHelper.addWarning(uuAppErrorMap, key, newErrorMap[key].message, newErrorMap[key].paramMap);
    });
    if (redirect) {
      let error = newErrorMap[errorKeys[0]];
      let counter = RequestCountHandler.getCounter;
      let retryAfter = await this._getRetryAfter(counter.lastResetTime);
      error.paramMap = { ...error.paramMap, retryAfter };
      await this._explicitLog(counter, errorKeys[0], error.message, error.paramMap);
      return next(new RateLimitError.RateError.RateLimitReachedError(errorKeys[0], error.message, error.paramMap));
    }
    // store warning array in shared place with other middleware
    res.locals.uuAppQOSWarningList = { ...res.locals.uuAppQOSWarningList, ...uuAppErrorMap };
    return next();
  }

  async _getRetryAfter(lastResetTime) {
    // set jitter to 0-15% (to prevent that all clients retry the request in the exact same time)
    let jitter = ~~(Math.random() * 16) / 100;
    let counterResetTime = lastResetTime || new Date().getTime();
    let quota = await SysQosConfigurationAbl.getConfiguration(this.asid);
    let counterResetTimeInterval = quota.counterResetTimeInterval * 1000;
    let retryAfterTimeInterval = counterResetTime + counterResetTimeInterval + jitter * counterResetTimeInterval;
    return new Date(retryAfterTimeInterval).toISOString();
  }

  async _explicitLog(counter, error, message, paramMap) {
    let explicitLog = RateLimitingComponent.getExplicitLog();
    let errorParam = ERROR_PARAMS.find((errorParam) => Object.prototype.hasOwnProperty.call(paramMap, errorParam));
    let logError = false;
    let counterParam = errorParam.slice(0, -10);
    if (errorParam && !explicitLog.includes(counterParam)) {
      if (counter[counterParam]) {
        if (counter[counterParam] === paramMap[errorParam]) {
          logError = true;
        }
      } else {
        if (counterParam === "uuIdentity") {
          let uuIdentityMap = counter["uuIdentityMap"];
          let curUuIdentity = paramMap.uuIdentity;
          if (curUuIdentity && uuIdentityMap[curUuIdentity] === paramMap[errorParam]) {
            logError = true;
          }
        }
        if (counterParam === "uuApp") {
          let uuAppMap = counter["uuAppMap"];
          let curUuApp = paramMap.awid;
          if (curUuApp && uuAppMap[curUuApp] === paramMap[errorParam]) {
            logError = true;
          }
        }
      }
    }
    if (logError) {
      let counterHistory = RequestCountHandler.getCounterHistory;
      RateLimitingComponent.addToExplicitLog(counterParam);
      paramMap = { httpStatus: 429, ...paramMap, counterHistory, errorCode: error };
      await AuditLog.log("ERROR", "uuAppQosExceeded", message, paramMap);
    }
  }
}

module.exports = QosMiddleware;
