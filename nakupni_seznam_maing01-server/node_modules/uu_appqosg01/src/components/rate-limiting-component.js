"use strict";
const QosIndicationHandler = require("./qos-indication-handler.js");
const ProgressBarUpdateManager = require("./progress-bar-update-manager.js");
const RequestCountHandler = require("./request-count-handler.js");
const RateLimitIndicationConstants = require("./constants/rate-limit-indication-constants.js");
const ANONYM_USER = "0-0";
const UNKNOWN_APP = "00000000000000000000000000000000";
const RUNNING_WITH_ERROR = "runningWithError";
const RUNNING_WITH_WARNING = "runningWithWarning";
const RUNNING = "running";
const INIT_COUNTER_STATUS = "init";
const COUNTER = {
  total: "Total",
  uuIdentityTotal: "UuIdentityTotal",
  uuIdentity: "UuIdentityMapById",
  uuIdentityUnknown: "UuIdentityUnknown",
  uuAppUnknown: "UuAppUnknown",
  uuApp: "UuAppMapByApp",
  uuAppTotal: "UuAppTotal",
};

class RateLimitingComponent {
  constructor() {
    this.lastResetTime = new Date().getTime();
    this.checkResult = [];
    this.uuAppErrorMap = {};
    this.counterResetTime = null;
    this.explicitLog = [];
  }

  getExplicitLog() {
    return this.explicitLog;
  }

  addToExplicitLog(log) {
    this.explicitLog.push(log);
  }

  async limitRate(reqData, quota) {
    // will be filled with QosIndicationHandler calls
    let uuAppErrorMap = {};
    let checkResult = [];
    this.resetCounters(quota);
    // HDS 3 - Increase and check counters
    // HDS 3.1 - total counter – This measures the total request count.
    checkResult.push(this._processTotal(quota));
    // HDS 3.2 - uuIdentity counters – This measures the request count for authenticated users. (A4)
    if (reqData.uuId !== ANONYM_USER) {
      checkResult.push(this._processUuIdentityTotal(quota, uuAppErrorMap));
      checkResult.push(this._processUuIdentity(reqData, quota, uuAppErrorMap));
    } else {
      // uuIdentityUnknown counter - This measures the request count for unknown users - not authenticated (anonymous) users
      checkResult.push(this._processUuIdentityUnknown(quota, uuAppErrorMap));
    }
    // HDS 3.3 - uuApp counter – This measures the total request count for AWID.
    if (reqData.uuApp && reqData.uuApp !== UNKNOWN_APP) {
      checkResult.push(this._processUuAppTotal(quota, uuAppErrorMap));
      checkResult.push(this._processUuApp(reqData, quota, uuAppErrorMap));
    } else {
      // uuAppUnknown counter This measures the total request for unknown uuApp
      checkResult.push(this._processUuAppUnknown(quota, uuAppErrorMap));
    }
    this.checkResult = this._increaseProperCounters(reqData, checkResult, uuAppErrorMap);
    this.uuAppErrorMap = { ...this.uuAppErrorMap, ...uuAppErrorMap };
    return uuAppErrorMap;
  }

  async updateStatus(quota) {
    if (!this.counterResetTime) {
      this.counterResetTime = this._getCounterResetTime(quota);
    }
    let progressUpdated = await this._updateStatusCheckTotalResults(this.checkResult, this.uuAppErrorMap);
    if (!progressUpdated) {
      await ProgressBarUpdateManager.updateProgress(
        {
          message: `<uu5string/>Total number of requests is ${RequestCountHandler.getTotal()} out of ${
            quota.totalLimitError
          }. <br/> The counter will restart at ${this.counterResetTime}.`,
        },
        this.uuAppErrorMap
      );
    }
  }

  resetCounters(quota) {
    let plannedReset = this._getPlannedResetTime(quota);
    if (plannedReset <= new Date().getTime()) {
      let resetTime = new Date().getTime();
      RequestCountHandler.resetCounters(resetTime);
      this.checkResult = [];
      this.uuAppErrorMap = {};
      this.explicitLog = [];
      this.lastResetTime = resetTime;
      this.counterResetTime = this._getCounterResetTime(quota);
    }
  }

  async _updateStatusCheckTotalResults(checkResult, uuAppErrorMap) {
    let message, state, totalLimitError;
    let warnRecord = this._findRecordByStateAndCounter(RUNNING_WITH_WARNING, COUNTER.total, checkResult);
    let errorRecord = this._findRecordByStateAndCounter(RUNNING_WITH_ERROR, COUNTER.total, checkResult);
    if (errorRecord || warnRecord) {
      if (errorRecord) {
        totalLimitError = errorRecord.paramMap && errorRecord.paramMap.totalLimitError;
        message = `<uu5string/>The total request count limit exceeded on hard error level. <br/> Total number of requests is ${RequestCountHandler.getTotal()} out of ${totalLimitError}. <br/> The counter will restart at ${
          this.counterResetTime
        }.`;
        state = RUNNING_WITH_ERROR;
      } else {
        let totalLimitError = warnRecord.paramMap && warnRecord.paramMap.totalLimitError;
        message = `<uu5string/>The total request count limit exceeded on soft warning level. <br/> Total number of requests is ${RequestCountHandler.getTotal()} out of ${totalLimitError}. <br/> The counter will restart at ${
          this.counterResetTime
        }.`;
      }
      await ProgressBarUpdateManager.updateProgress({ state, message }, uuAppErrorMap);
      return true;
    }
    return false;
  }

  _processTotal(quota) {
    // HDS - check "total" counter
    let totalLimitWarning = quota.totalLimitWarning;
    if (totalLimitWarning > 0 && RequestCountHandler.getTotal() + 1 >= totalLimitWarning) {
      let totalLimitError = quota.totalLimitError;
      let code = RateLimitIndicationConstants.tooManyTotalRequestIndicationCode;
      // A - if total >= totalLimitWarning and totalLimitWarning > 0
      if (totalLimitError > 0 && RequestCountHandler.getTotal() + 1 > totalLimitError) {
        // A - if total >= totalLimitError and totalLimitError > 0
        let message = `The total request count limit exceeded on hard error level. Total number of requests is ${RequestCountHandler.getTotal()} out of ${totalLimitError}. The counter will restart at ${
          this.counterResetTime
        }.`;
        let paramMap = { totalLimitError };
        return { state: RUNNING_WITH_ERROR, code, message, counter: COUNTER.total, paramMap };
      } else {
        let message = `The total request count limit exceeded on soft warning level. Total number of requests is ${
          RequestCountHandler.getTotal() + 1
        } out of ${quota.totalLimitError}. The counter will restart at ${this.counterResetTime}.`;
        let paramMap = { totalLimitWarning, totalLimitError };
        return { state: RUNNING_WITH_WARNING, code, message, counter: COUNTER.total, paramMap };
      }
    }
    return { state: RUNNING, counter: COUNTER.total };
  }

  _processUuIdentityTotal(quota, uuAppErrorMap) {
    // HDS - check "uuIdentityTotal" counter
    let uuIdentityTotalLimitWarning = quota.uuIdentityTotalLimitWarning;
    if (
      uuIdentityTotalLimitWarning > 0 &&
      RequestCountHandler.getUuIdentityTotal() + 1 >= uuIdentityTotalLimitWarning
    ) {
      // A - if uuIdentityTotal >= uuIdentityTotalLimitWarning and uuIdentityTotalLimitWarning > 0
      let uuIdentityTotalLimitError = quota.uuIdentityTotalLimitError;
      let code = RateLimitIndicationConstants.tooManyTotalIdentityRequestIndicationCode;
      if (uuIdentityTotalLimitError > 0 && RequestCountHandler.getUuIdentityTotal() + 1 > uuIdentityTotalLimitError) {
        // A - if uuIdentityTotal >= uuIdentityTotalLimitError and uuIdentityTotalLimitError > 0
        let message = `The uuIdentity total request count limit exceeded on hard error level.`;
        let paramMap = { uuIdentityTotalLimitError };
        return this._setDtoOut(RUNNING_WITH_ERROR, message, code, COUNTER.uuIdentityTotal, uuAppErrorMap, paramMap);
      } else {
        let message = `The uuIdentity total request count limit exceeded on soft warning level.`;
        let paramMap = { uuIdentityTotalLimitWarning };
        return this._setDtoOut(RUNNING_WITH_WARNING, message, code, COUNTER.uuIdentityTotal, uuAppErrorMap, paramMap);
      }
    }
    return { state: RUNNING, counter: COUNTER.uuIdentityTotal };
  }

  _processUuIdentity(reqData, quota, uuAppErrorMap) {
    let uuId = reqData.uuId;
    // HDS - uuIdentity counter – This measures the total request count for current authenticated user.
    let currUserRqNumber = RequestCountHandler.getUuIdentityMapById(uuId);
    // HDS - get or create uuIdentityCounter
    // Use uuIdentityMap and uuIdentity identifier to obtain counter for current user. If the counter is not found, create the new-one with 0 value.
    if (currUserRqNumber !== undefined) {
      // HDS - check "uuIdentityCounter"
      let uuIdentityLimitWarning = quota.uuIdentityLimitWarning;
      if (uuIdentityLimitWarning > 0 && RequestCountHandler.getUuIdentityMapById(uuId) + 1 >= uuIdentityLimitWarning) {
        // A - if uuIdentityCounter >= uuIdentityLimitWarning and uuIdentityLimitWarning > 0
        let uuIdentityLimitError = quota.uuIdentityLimitError;
        let code = RateLimitIndicationConstants.tooManyIdentityRequestIndicationCode;
        if (uuIdentityLimitError > 0 && RequestCountHandler.getUuIdentityMapById(uuId) + 1 > uuIdentityLimitError) {
          // A - if uuIdentity >= uuIdentityLimitError and uuIdentityLimitError > 0
          let message = `The uuIdentity request count limit exceeded on hard error level.`;
          let paramMap = { uuIdentity: uuId, uuIdentityLimitError };
          return this._setDtoOut(RUNNING_WITH_ERROR, message, code, COUNTER.uuIdentity, uuAppErrorMap, paramMap);
        } else {
          let message = `The uuIdentity ${uuId} request count limit exceeded on soft warning level.`;
          let paramMap = { uuIdentity: uuId, uuIdentityLimitWarning };
          return this._setDtoOut(RUNNING_WITH_WARNING, message, code, COUNTER.uuIdentity, uuAppErrorMap, paramMap);
        }
      }
    } else {
      RequestCountHandler.setUuIdentityMapById(uuId, 1);
      return { state: RUNNING, counter: COUNTER.uuIdentity, status: INIT_COUNTER_STATUS };
    }
    return { state: RUNNING, counter: COUNTER.uuIdentity };
  }

  _processUuIdentityUnknown(quota, uuAppErrorMap) {
    // HDS - check "uuIdentityUnknown" counter
    let uuIdentityUnknownLimitWarning = quota.uuIdentityUnknownLimitWarning;
    if (
      uuIdentityUnknownLimitWarning > 0 &&
      RequestCountHandler.getUuIdentityUnknown() + 1 >= uuIdentityUnknownLimitWarning
    ) {
      let uuIdentityUnknownLimitError = quota.uuIdentityUnknownLimitError;
      let code = RateLimitIndicationConstants.tooManyIdentityUnknownIndicationCode;
      // A - if uuIdentityUnknownLimitWarning > 0 and uuIdentityUnknown >= uuIdentityUnknownLimitWarning
      if (
        uuIdentityUnknownLimitError > 0 &&
        RequestCountHandler.getUuIdentityUnknown() + 1 > uuIdentityUnknownLimitError
      ) {
        // A - if uuIdentityUnknownLimitError > 0 and uuIdentityUnknown >= uuIdentityUnknownLimitError
        let message = `The uuIdentity unknown request count limit exceeded on hard error level.`;
        let paramMap = { uuIdentityUnknownLimitError };
        return this._setDtoOut(RUNNING_WITH_ERROR, message, code, COUNTER.uuIdentityUnknown, uuAppErrorMap, paramMap);
      } else {
        let message = `The uuIdentity unknown request count limit exceeded on soft warning level.`;
        let paramMap = { uuIdentityUnknownLimitWarning };
        return this._setDtoOut(RUNNING_WITH_WARNING, message, code, COUNTER.uuIdentityUnknown, uuAppErrorMap, paramMap);
      }
    }
    return { state: RUNNING, counter: COUNTER.uuIdentityUnknown };
  }

  _processUuAppTotal(quota, uuAppErrorMap) {
    // HDS - check "uuAppTotal" counter
    let uuAppTotalLimitWarning = quota.uuAppTotalLimitWarning;
    if (uuAppTotalLimitWarning > 0 && RequestCountHandler.getUuAppTotal() + 1 >= uuAppTotalLimitWarning) {
      // A - if uuAppTotal >= uuAppTotalLimitWarning and uuAppTotalLimitWarning > 0
      let uuAppTotalLimitError = quota.uuAppTotalLimitError;
      let code = RateLimitIndicationConstants.tooManyTotalAppRequestIndicationCode;
      if (uuAppTotalLimitError > 0 && RequestCountHandler.getUuAppTotal() + 1 > uuAppTotalLimitError) {
        // A - if uuAppTotal >= uuAppTotalLimitError and uuAppTotalLimitError > 0
        let message = `The uuApp total request count limit exceeded on hard error level.`;
        let paramMap = { uuAppTotalLimitError };
        return this._setDtoOut(RUNNING_WITH_ERROR, message, code, COUNTER.uuAppTotal, uuAppErrorMap, paramMap);
      } else {
        let message = `The uuApp total request count limit exceeded on soft warning level.`;
        let paramMap = { uuAppTotalLimitWarning };
        return this._setDtoOut(RUNNING_WITH_WARNING, message, code, COUNTER.uuAppTotal, uuAppErrorMap, paramMap);
      }
    }
    return { state: RUNNING, counter: COUNTER.uuAppTotal };
  }

  _processUuApp(reqData, quota, uuAppErrorMap) {
    // HDS - get or create uuAppCounter
    let uuApp = reqData.uuApp;
    // Use uuAppMap and AWID identifier to obtain counter for current AWID. If the counter is not found, create the new-one with 0 value.
    let currAwidRqNumber = RequestCountHandler.getUuAppMapByApp(uuApp);
    if (currAwidRqNumber !== undefined) {
      // HDS - increment "uuAppCounter"
      // RequestCountHandler.incrUuAppMapByApp(uuApp);
      let uuAppLimitWarning = quota.uuAppLimitWarning;
      // HDS - check "uuAppCounter"
      if (uuAppLimitWarning > 0 && RequestCountHandler.getUuAppMapByApp(uuApp) + 1 >= uuAppLimitWarning) {
        let uuAppLimitError = quota.uuAppLimitError;
        let code = RateLimitIndicationConstants.tooManyAppRequestIndicationCode;
        // A - if uuAppCounter >= uuAppLimitWarning and uuAppLimitWarning > 0
        if (uuAppLimitError > 0 && RequestCountHandler.getUuAppMapByApp(uuApp) + 1 > uuAppLimitError) {
          // A - if uuAppCounter >= uuAppLimitError and uuAppLimitError > 0
          let message = `The AWID ${uuApp} request count limit exceeded on hard error level.`;
          let paramMap = { awid: uuApp, uuAppLimitError };
          return this._setDtoOut(RUNNING_WITH_ERROR, message, code, COUNTER.uuApp, uuAppErrorMap, paramMap);
        } else {
          let message = `The AWID ${uuApp} request count limit exceeded on soft warning level.`;
          let paramMap = { awid: uuApp, uuAppLimitWarning };
          return this._setDtoOut(RUNNING_WITH_WARNING, message, code, COUNTER.uuApp, uuAppErrorMap, paramMap);
        }
      }
    } else {
      RequestCountHandler.setUuAppMapByApp(uuApp, 1);
      return { state: RUNNING, counter: COUNTER.uuApp, status: INIT_COUNTER_STATUS };
    }
    return { state: RUNNING, counter: COUNTER.uuApp };
  }

  _processUuAppUnknown(quota, uuAppErrorMap) {
    // HDS - check "uuAppUnknown" counter
    let uuAppUnknownLimitWarning = quota.uuAppUnknownLimitWarning;
    if (uuAppUnknownLimitWarning > 0 && RequestCountHandler.getUuAppUnknown() + 1 >= uuAppUnknownLimitWarning) {
      let uuAppUnknownLimitError = quota.uuAppUnknownLimitError;
      let code = RateLimitIndicationConstants.tooManyAppUnknownIndicationCode;
      // A - if uuIdentityUnknownLimitWarning > 0 and uuIdentityUnknown >= uuIdentityUnknownLimitWarning
      if (uuAppUnknownLimitError > 0 && RequestCountHandler.getUuAppUnknown() + 1 > uuAppUnknownLimitError) {
        // A - uuAppUnknownLimitError > 0 and uuAppUnknown >= uuAppUnknownLimitError
        let message = `The uuApp unknown request count limit exceeded on hard error level.`;
        let paramMap = { uuAppUnknownLimitError };
        return this._setDtoOut(RUNNING_WITH_ERROR, message, code, COUNTER.uuAppUnknown, uuAppErrorMap, paramMap);
      } else {
        let message = `The uuApp unknown request count limit exceeded on soft warning level.`;
        let paramMap = { uuAppUnknownLimitWarning };
        return this._setDtoOut(RUNNING_WITH_WARNING, message, code, COUNTER.uuAppUnknown, uuAppErrorMap, paramMap);
      }
    }
    return { state: RUNNING, counter: COUNTER.uuAppUnknown };
  }

  _increaseProperCounters(reqData, checkResult, uuAppErrorMap) {
    let isResultWithoutError = checkResult.every((item) => item.state !== RUNNING_WITH_ERROR);
    if (isResultWithoutError) {
      for (let item of checkResult) {
        let incrCounter = `incr${item.counter}`;
        if (item.counter === COUNTER.uuIdentity) {
          item.status !== INIT_COUNTER_STATUS && RequestCountHandler[incrCounter](reqData.uuId);
        } else if (item.counter === COUNTER.uuApp) {
          item.status !== INIT_COUNTER_STATUS && RequestCountHandler[incrCounter](reqData.uuApp);
        } else {
          RequestCountHandler[incrCounter]();
        }
      }
      this._processTotalLogging(RUNNING_WITH_WARNING, checkResult, uuAppErrorMap);
    } else {
      checkResult = checkResult.filter((item) => item.state === RUNNING_WITH_ERROR);
      this._processTotalLogging(RUNNING_WITH_ERROR, checkResult, uuAppErrorMap);
    }
    return checkResult;
  }

  _getCounterResetTime(quota) {
    // set jitter to 0-15%
    let jitter = ~~(Math.random() * 16) / 100;
    let counterResetTime = this.lastResetTime || new Date().getTime();
    let counterResetTimeInterval = quota.counterResetTimeInterval * 1000;
    let retryAfterTimeInterval = counterResetTime + counterResetTimeInterval + jitter * counterResetTimeInterval;
    return new Date(retryAfterTimeInterval).toISOString().split(".")[0] + "Z";
  }

  _getPlannedResetTime(quota) {
    return this.lastResetTime + quota.counterResetTimeInterval * 1000;
  }

  _processTotalLogging(state, checkResult, uuAppErrorMap) {
    let record = this._findRecordByStateAndCounter(state, COUNTER.total, checkResult);
    if (record && state === RUNNING_WITH_ERROR) {
      QosIndicationHandler.error(uuAppErrorMap, record.code, record.message, record.paramMap);
    } else if (record && state === RUNNING_WITH_WARNING) {
      QosIndicationHandler.warn(uuAppErrorMap, record.code, record.message, record.paramMap);
    }
  }

  _setDtoOut(state, message, code, counter, uuAppErrorMap, paramMap) {
    if (state === RUNNING_WITH_ERROR) {
      QosIndicationHandler.error(uuAppErrorMap, code, message, paramMap);
    } else {
      QosIndicationHandler.warn(uuAppErrorMap, code, message, paramMap);
    }
    return { state, code, message, counter, paramMap };
  }

  _findRecordByStateAndCounter(state, counter, records = []) {
    return records.find((item) => item.state === state && item.counter === counter);
  }
}

module.exports = new RateLimitingComponent();
