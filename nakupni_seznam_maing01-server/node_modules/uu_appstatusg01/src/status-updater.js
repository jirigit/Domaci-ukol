"use strict";

const { Sys } = require("uu_appg01_core-appserver");

const { UuSubAppInstance, Profile } = require("uu_appg01_workspace");

const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");
const { Config } = require("uu_appg01_server").Utils;
const { LoggerFactory } = require("uu_appg01_core-logging");
//const { AuthenticationService } = require("uu_appg01_core-authentication");
const { AuthenticationService } = require("uu_appg01_server").Authentication;
//const { AuthenticationService } = require("uu_appg01_oidc");
const AppStatusCounter = require("./components/app-status-counter.js");

const APP_STATUS_PROGRESS_BASE_URI_CONFIG_NAME = "uu_app_status_progress_base_uri";
const APP_STATUS_PROGRESS_BUS_CODE_CONFIG_NAME = "uu_app_status_progress_bus_code";
const APP_STATUS_PROGRESS_UUEE_CONFIG_NAME = "uu_app_status_progress_uuee";
const APP_STATUS_PROGRESS_UPDATE_PERIOD_CONFIG_NAME = "uu_app_status_progress_update_period";
const APP_STATUS_PROGRESS_UPDATE_PERIOD_DEFAULT_VALUE = 60;
const APP_STATUS_PROGRESS_DATA_HISTORY_COUNT_CONFIG_NAME = "uu_app_status_progress_data_history_count";
const APP_STATUS_PROGRESS_DATA_HISTORY_COUNT_DEFAULT_VALUE = 5;
const APP_STATUS_PROGRESS_UU_CLOUD_UNIVERSE = "uu_cloud_universe";
const APP_STATUS_PROGRESS_UU_CLOUD_UNIVERSE_DEFAULT = "main";
const APP_STATUS_PROGRESS_UU_CLOUD_REGION = "uu_cloud_region";
const APP_STATUS_PROGRESS_UU_CLOUD_REGION_DEFAULT = "undefined";
const APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_POOL = "uu_cloud_resource_pool";
const APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_POOL_DEFAULT = "undefined";
const APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_GROUP = "uu_cloud_resource_group";
const APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_GROUP_DEFAULT = "undefined";
const APP_STATUS_PROGRESS_UU_CLOUD_APP_RESOURCE_POOL = "uu_cloud_app_resource_pool";
const APP_STATUS_PROGRESS_UU_CLOUD_APP_RESOURCE_POOL_DEFAULT = "undefined";
const APP_STATUS_PROGRESS_UU_CLOUD_NODE_SIZE_DEFAULT = "undefined";

const APP_STATUS_PROGRESS_WARNING_PERIOD_CONFIG_NAME = "uu_app_status_progress_problem_warning_period";
const APP_STATUS_PROGRESS_WARNING_PERIOD_DEFAULT_VALUE = 15;
const APP_STATUS_PROGRESS_ERROR_PERIOD_CONFIG_NAME = "uu_app_status_progress_problem_error_period";
const APP_STATUS_PROGRESS_ERROR_PERIOD_DEFAULT_VALUE = 30;
const APP_STATUS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME = "uu_app_status_progress_expire_period";
const APP_STATUS_PROGRESS_EXPIRE_PERIOD_DEFAULT_VALUE = 3600;
const APP_STATUS_PROGRESS_UPDATE_RANDOM_DELAY_CONFIG_NAME = "uu_app_status_progress_update_random_delay";
const APP_STATUS_PROGRESS_UPDATE_RANDOM_DELAY_DEFAULT_VALUE = 5;
const APP_STATUS_PROGRESS_ITEMS_MAX_COUNT_CONFIG_NAME = "uu_app_status_progress_items_max_count";
const APP_STATUS_PROGRESS_ITEMS_MAX_COUNT_DEFAULT_VALUE = 40;
const PROGRESS_BUS_LOAD = "progressBus/load";
const PROGRESS_BUS_CREATE = "progressBus/create";
const PROGRESS_CREATE = "progressBus/progress/create";
const PROGRESS_START = "progressBus/progress/start";
const PROGRESS_PROCEED = "progressBus/progress/proceed";
const PROGRESS_END = "progressBus/progress/end";
const PROGRESS_DELETE = "progressBus/progress/delete";
const LOCKSECRET = "442bce0ca09d14fdea0077895468bf38857649da8c7034338aed94f71e501bc3";
const PROGRESS_BUS_DOES_NOT_EXIST = "progressBusDoesNotExist";
const PROGRESS_DOES_NOT_EXIST = "progressDoesNotExist";
const PROGRESS_IS_NOT_IN_PROPER_STATE = "progressIsNotInProperState";
const APP_STATUS = "uuappstatus";
const DEFAULT_AUTHZ_STRATEGY = "artifact";
// maps standard asid profiles to corresponding console progress(Bus) profiles
// if multiple profiles are mapped to the same console progress profile, the first one is used
const AUTHZ_ASID_PROFILE_MAP = {
  AsidAuthorities: "Authorities",
  AsidExecutives: "Writers",
  AsidAuditors: "Readers",
};
const AUTHZ_REQUIRED_PROFILES = ["Authorities", "Writers"];
const PROGRESS_STATES = ["waiting", "completed", "completedWithWarning", "completedWithError"];

const SPP_DEFAULT = "";

const LOGGER = LoggerFactory.get("Uu.AppStatus.Updater");
const APPINFO = Sys.getAppInfo();
const NODE_START_TIME = new Date().toISOString();

const DEFAULT_SCHEMA_VERSION = "1.0.0";

class StatusUpdater {
  constructor() {
    // 1. System sets progressUpdatePeriod
    this.progressUpdatePeriod =
      Config.getNumber(APP_STATUS_PROGRESS_UPDATE_PERIOD_CONFIG_NAME) ||
      APP_STATUS_PROGRESS_UPDATE_PERIOD_DEFAULT_VALUE;

    // 2. System sets progressWarningPeriod
    this.progressErrorPeriod =
      Config.getNumber(APP_STATUS_PROGRESS_ERROR_PERIOD_CONFIG_NAME) || APP_STATUS_PROGRESS_ERROR_PERIOD_DEFAULT_VALUE;

    // 3. System sets progressErrorPeriod
    this.progressWarningPeriod =
      Config.getNumber(APP_STATUS_PROGRESS_WARNING_PERIOD_CONFIG_NAME) ||
      APP_STATUS_PROGRESS_WARNING_PERIOD_DEFAULT_VALUE;

    // 4. System sets prgressRandomDelay
    this.progressUpdateRandomDelay =
      Config.getNumber(APP_STATUS_PROGRESS_UPDATE_RANDOM_DELAY_CONFIG_NAME) ||
      APP_STATUS_PROGRESS_UPDATE_RANDOM_DELAY_DEFAULT_VALUE;

    // 5. System sets progressUuEe
    this.progressUuEe = Config.get(APP_STATUS_PROGRESS_UUEE_CONFIG_NAME);

    // 6. System sets progressUri
    this.progressUri =
      Config.get(APP_STATUS_PROGRESS_BASE_URI_CONFIG_NAME) &&
      UriBuilder.parse(Config.get(APP_STATUS_PROGRESS_BASE_URI_CONFIG_NAME));

    // 7. System sets progressBusCode
    this.progressBusCode =
      Config.get(APP_STATUS_PROGRESS_BUS_CODE_CONFIG_NAME) || `${APP_STATUS}_${Config.get("asid")}`;

    // 8. System sets progressExpirePeriod
    this.progressExpirePeriod =
      Config.getNumber(APP_STATUS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME) ||
      APP_STATUS_PROGRESS_EXPIRE_PERIOD_DEFAULT_VALUE;

    // 9. System sets progressItemsMaxCount
    this.progressItemsMaxCount =
      Config.getNumber(APP_STATUS_PROGRESS_ITEMS_MAX_COUNT_CONFIG_NAME) ||
      APP_STATUS_PROGRESS_ITEMS_MAX_COUNT_DEFAULT_VALUE;

    // 10. System sets nodeName from environment (nodeName format example:   "nodeName": "uuappg01_async-uu_script_engineg02_async-1617198494548.1.nkvnwdhr0k5w5pvcw5x2vsfpj"),
    this.nodeName =
      process.env.UU_CLOUD_NODE_NAME ||
      `uuappg01-${APPINFO.uuSubApp.replace("-server", "")}-${new Date().getTime()}.1.${new Date().getTime()}`;

    // 11. System sets subAppName from environment (subAppName format example: "uuScriptEngineg02")
    const subAppNameRegex = /^[^-]+-([^-]+)/; // the name of the subapp is the second part of the node name (between the first and second dash)
    const [, subAppName] = subAppNameRegex.exec(this.nodeName) || [];
    if (!subAppName) {
      this.uuSubAppName = "unknownUnknownUnknowng00";
    } else {
      this.uuSubAppName = subAppName
        .split("_")
        .map((s, i) => (i === 0 ? s : s && s[0].toUpperCase() + s.slice(1)))
        .slice(0, 3)
        .join("");
    }

    // 12. System sets spp
    const sppRegex = /^[^-]+-(?:[^-_]+_){3}([^-_]+)/; // the name of the subapp is the second part of the node name (between the first and second dash), its fourth part delimited by underscores is the spp
    const [, spp] = sppRegex.exec(this.nodeName) || [];
    this.spp = spp || SPP_DEFAULT;

    // 13. System sets progressCode
    this.progressCode =
      this.nodeName.slice(this.nodeName.lastIndexOf("-") + 1).replace(/\./g, "_") + `${this.spp && "_" + this.spp}`;

    // 14. System sets asid
    this.asid = Config.get("asid");

    // 15. System sets runtime stack code
    this.runtimeStackCode = process.env.UU_CLOUD_RUNTIME_STACK_CODE || "";

    // 16. Systems sets node start time
    this.uuCloudNodeStartTime = NODE_START_TIME;

    // 17. Systems sets progressDataHistoryCount
    this.progressDataHistoryCount =
      Config.getNumber(APP_STATUS_PROGRESS_DATA_HISTORY_COUNT_CONFIG_NAME) ||
      APP_STATUS_PROGRESS_DATA_HISTORY_COUNT_DEFAULT_VALUE;

    // 18. Systems sets uuCloudUniverse, uuCloudAppResourcePool
    this.uuCloudAppResourcePool =
      Config.get(APP_STATUS_PROGRESS_UU_CLOUD_APP_RESOURCE_POOL) ||
      APP_STATUS_PROGRESS_UU_CLOUD_APP_RESOURCE_POOL_DEFAULT;
    this.uuCloudUniverse =
      Config.get(APP_STATUS_PROGRESS_UU_CLOUD_UNIVERSE) || APP_STATUS_PROGRESS_UU_CLOUD_UNIVERSE_DEFAULT;

    this.uuCloudResourcePoolUri = process.env.UU_CLOUD_RESOURCE_POOL_URI; // example - ues:[84723967990089199]:[571fb9c92792890902e2282a]
    if (this.uuCloudResourcePoolUri && typeof this.uuCloudResourcePoolUri === "string") {
      if (this.uuCloudAppResourcePool === APP_STATUS_PROGRESS_UU_CLOUD_APP_RESOURCE_POOL_DEFAULT) {
        this.uuCloudAppResourcePool = this.uuCloudResourcePoolUri;
      }
      if (this.uuCloudUniverse === APP_STATUS_PROGRESS_UU_CLOUD_UNIVERSE_DEFAULT) {
        let id = this.uuCloudResourcePoolUri.split(":")[1];
        if (id) {
          this.uuCloudUniverse = id.slice(1, -1);
        }
      }
    }

    // 19. Systems sets uuCloudRegion, uuCloudResourcePool, uuCloudResourceGroupCode
    this.uuCloudRegion = Config.get(APP_STATUS_PROGRESS_UU_CLOUD_REGION);
    this.uuCloudResourcePool = Config.get(APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_POOL);
    this.uuCloudResourceGroupCode = Config.get(APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_GROUP);

    this.uuCloudHostName = process.env.UU_CLOUD_HOST_NAME; // uuCloudHostName example - h-tfkeb1mc.rg-82c1fe80.uu-os8-apps2.eu-n-1.cloud.plus4u.net
    if (this.uuCloudHostName && typeof this.uuCloudHostName === "string") {
      let uuCloudHostNameArray = this.uuCloudHostName.split(".");
      if (!this.uuCloudRegion)
        this.uuCloudRegion = uuCloudHostNameArray[3] || APP_STATUS_PROGRESS_UU_CLOUD_REGION_DEFAULT;
      if (!this.uuCloudResourcePool)
        this.uuCloudResourcePool = uuCloudHostNameArray[2] || APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_POOL_DEFAULT;
      if (!this.uuCloudResourceGroupCode)
        this.uuCloudResourceGroupCode = uuCloudHostNameArray[1] || APP_STATUS_PROGRESS_UU_CLOUD_RESOURCE_GROUP_DEFAULT;
    }

    // 20. Systems sets schema version
    this.uuAppStatusDataSchemaVersion = DEFAULT_SCHEMA_VERSION;

    // 21. Systems sets uuNodeSize
    this.uuNodeSize = process.env.UU_CLOUD_NODE_SIZE || APP_STATUS_PROGRESS_UU_CLOUD_NODE_SIZE_DEFAULT;
  }

  /**
   * Updates progress data.
   * @param {Date} [atTime] - optional time for current counter data
   */
  async update(atTime = new Date()) {
    // 1-2. System prepares progress proceedDtoIn
    let proceedDtoIn = this._getProceedDtoIn(atTime);

    // 3. System sets progress/proceed useCase
    this.progressUri.setUseCase(PROGRESS_PROCEED);

    // 4. System waits a random amount between 0 and progressUpdateRandomDelay to avoid overwhelming the console
    const randomDelayMs = Math.floor(Math.random() * this.progressUpdateRandomDelay * 1000);
    await new Promise((resolve) => setTimeout(resolve, randomDelayMs));

    // 5. System sets session
    let session;
    if (this.progressUuEe) {
      // 5.A
      session = await AuthenticationService.authenticate(this.progressUuEe);
    } else {
      // 5.B
      session = await AuthenticationService.authenticateSystemIdentity();
    }

    // 6. System tries to proceed progress
    try {
      await AppClient.post(this.progressUri, proceedDtoIn, { session });
    } catch (e) {
      LOGGER.error(`Progress proceed failed: `, e);
      if (e.code && e.code.endsWith(PROGRESS_DOES_NOT_EXIST)) {
        await this._processMissingProgress(proceedDtoIn, session);
      } else if (e.code && e.code.endsWith(PROGRESS_IS_NOT_IN_PROPER_STATE)) {
        if (e.paramMap && e.paramMap.state && PROGRESS_STATES.includes(e.paramMap.state)) {
          await this.startAndProceedProgress(proceedDtoIn, session);
        }
      } else if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
        this._accessDeniedLogger(session);
      }
    }
  }

  /**
   * Updates the progress and resets the app status counter.
   * @param {Date} [atTime] - time at which the command is being executed. If specified, it is used as end time and start time for the app status counter.
   */
  async updateAndReset(atTime = new Date()) {
    LOGGER.debug(
      `Updating and resetting status for interval at ${atTime.toISOString()}. Actual time ${new Date().toISOString()}.`
    );
    await this.update(atTime);
    AppStatusCounter.reset(atTime);
  }

  /**
   * Builds the proceedDtoIn for the progress with app status counter data.
   * @param {Date} [atTime] - time at which the command is being executed. If specified, it is used as endTime for the counter.
   * @returns progressProceedDtoIn
   */
  _getProceedDtoIn(atTime = new Date()) {
    // 1. System sets estimatedNextProgressTs, expireAt
    const date = new Date();
    const estimatedNextProgressTs = new Date(date.getTime() + this.progressUpdatePeriod * 1000);
    const expireAt = new Date(date.getTime() + this.progressExpirePeriod * 1000);

    // 2. System prepares progress proceedDtoIn
    const componentData = AppStatusCounter.getData(atTime);
    let dataHistoryKey = componentData.dataHistoryKey;
    delete componentData.dataHistoryKey;
    return {
      code: this.progressCode,
      estimatedNextProgressTs: estimatedNextProgressTs.toISOString(),
      lockSecret: LOCKSECRET,
      delayWarning: this.progressWarningPeriod,
      delayError: this.progressErrorPeriod,
      expireAt: expireAt.toISOString(),
      dataHistoryKey,
      data: {
        uuAppStatusDataSchemaVersion: this.uuAppStatusDataSchemaVersion,
        uuSubAppName: this.uuSubAppName,
        uuSubAppVersion: APPINFO.uuSubAppVersion,
        uuNodeSize: this.uuNodeSize,
        asid: this.asid,
        spp: this.spp,
        uuAppRuntimeStack: this.runtimeStackCode,
        uuCloudUniverse: this.uuCloudUniverse,
        uuCloudRegion: this.uuCloudRegion,
        uuCloudResourcePool: this.uuCloudResourcePool,
        uuCloudResourceGroupCode: this.uuCloudResourceGroupCode,
        uuCloudAppResourcePool: this.uuCloudAppResourcePool,
        uuCloudNodeName: this.nodeName,
        uuCloudNodeStartTime: this.uuCloudNodeStartTime,
        runtimeData: {
          runtimeDataType: "nodejs",
          memoryUsage: process.memoryUsage(),
          resourceUsage: process.resourceUsage()
        },
        componentData,
      },
    };
  }

  async _getProgressBusCreateDtoIn(subAppInstance) {
    const authorizationStrategy = await this._getAuthorizationStategy();
    return {
      code: this.progressBusCode,
      name: subAppInstance.name || this.uuSubAppName,
      desc: this.asid,
      maxNumberOfProgressItems:this.progressItemsMaxCount,
      dataHistoryMaxSize: this.progressDataHistoryCount,
      data: {
        uuSubAppName: this.uuSubAppName,
        uuSubAppVersion: APPINFO.uuSubAppVersion,
        asid: this.asid,
        asidName: subAppInstance.name || undefined,
      },
      ...authorizationStrategy,
    };
  }

  async _processMissingProgress(proceedDtoIn, session) {
    // 6.B.1.A.
    LOGGER.info(`Progress representing the current node doesn't exist (code ${proceedDtoIn.code}). Creating...`);

    // 6.B.2.A.1. System parses node_set_unique_id and node_number_in_node_set from progressCode
    let [nodeSetUniqueId, nodeNumberInNodeSet] = this.progressCode.split("_");
    let nodeUniqueId = this.nodeName.split(".")[2];
    let uniqueIdLastSix = nodeUniqueId.slice(nodeUniqueId.length - 6, nodeUniqueId.length);
    let appVersion = APPINFO.uuSubAppVersion.split("-")[0];

    // 6.B.2.A.2. System prepares progressCreateDtoIn
    let progressCreateDtoIn = {
      code: this.progressCode,
      progressBusCode: this.progressBusCode,
      name: `<uu5string/>${uniqueIdLastSix}${this.spp === SPP_DEFAULT ? "" : `.${this.spp}`}<br/>[${appVersion}]`,
      dataHistoryMaxSize: 10,
    };

    await this._checkExistingNode(session, nodeNumberInNodeSet, nodeSetUniqueId);
    await this._createProgress(progressCreateDtoIn, session);
    // 6.B.2.A.6...
    await this.startAndProceedProgress(proceedDtoIn, session);
  }

  async _checkExistingNode(session, nodeNumberInNodeSet, nodeSetUniqueId) {
    // 6.B.2.A.3. node number 1 in each nodeSet checks if exist progressBus
    if (nodeNumberInNodeSet === "1") {
      // 6.B.2.A.3.A.1. System tries to get progressBus
      try {
        // 6.B.2.A.3.A.1.A.
        // 6.B.2.A.3.A.1.A.1. System sets use case to progressBus/load
        this.progressUri.setUseCase(PROGRESS_BUS_LOAD);
        // 6.B.2.A.3.A.1.A.2. System loads progressBus using AppClient with session from HDS 4.
        await AppClient.get(this.progressUri, { code: this.progressBusCode }, { session });
      } catch (e) {
        // 6.B.2.A.3.A.1.B.
        // 6.B.2.A.3.A.1.B.1. progressBus/load failed
        if (e.code && e.code.endsWith(PROGRESS_BUS_DOES_NOT_EXIST)) {
          // 6.B.2.A.3.A.1.B.1.A.
          LOGGER.info(`ProgressBus for the current asid (${this.asid}) doesn't exist. Creating...`);

          // 6.B.2.A.3.A.1.B.1.A.1. System prepares progressBusCreateDtoIn
          let subAppInstance;
          try {
            subAppInstance = await UuSubAppInstance.get(this.asid);
          } catch (e) {
            LOGGER.warn(
              `UuSubAppInstance get for the current asid (${this.asid}) failed, progress bus name will only be set to uuSubApp name: `,
              e
            );
            subAppInstance = {};
          }
          let progressBusCreateDtoIn = await this._getProgressBusCreateDtoIn(subAppInstance);

          await this._createProgressBus(progressBusCreateDtoIn, session);
        } else {
          // 6.B.2.A.3.A.1.B.1.B.
          LOGGER.error(`ProgressBus load failed: `, e);
          return;
        }
      }
    }
  }

  async startAndProceedProgress(proceedDtoIn, session) {
    // 6.B.2.A.6. System sets progress/start use case
    this.progressUri.setUseCase(PROGRESS_START);

    // 6.B.2.A.7. System prepares progressStartDtoIn
    let progressStartDtoIn = {
      code: this.progressCode,
      lockSecret: LOCKSECRET,
    };

    // 6.B.2.A.8. System tries to start progress
    try {
      // 6.B.2.A.8.A.
      await AppClient.post(this.progressUri, progressStartDtoIn, { session });
    } catch (e) {
      // 6.B.2.A.8.B.
      LOGGER.error(`Progress start failed: `, e);
      return;
    }

    // 6.B.2.A.9. System sets progress/proceed use case
    this.progressUri.setUseCase(PROGRESS_PROCEED);

    // 6.B.2.A.10. System tries to proceed progress
    try {
      // 6.B.2.A.10.A.
      await AppClient.post(this.progressUri, proceedDtoIn, { session });
    } catch (e) {
      // 6.B.2.A.10.B.
      LOGGER.error(`Progress proceed failed: `, e);
    }
  }

  async _createProgressBus(progressBusCreateDtoIn, session) {
    // 6.B.2.A.3.A.1.B.1.A.2. System sets use case to progressBus/create
    this.progressUri.setUseCase(PROGRESS_BUS_CREATE);

    // 6.B.2.A.3.A.1.B.1.A.3. System tries to create progressBus
    try {
      // 6.B.2.A.3.A.1.B.1.A.3.A.
      await AppClient.post(this.progressUri, progressBusCreateDtoIn, { session });
    } catch (e) {
      // 6.B.2.A.3.A.1.B.1.A.3.B.
      LOGGER.error(`ProgressBus create failed: `, e);
    }
  }

  async _createProgress(progressCreateDtoIn, session) {
    // 6.B.2.A.4. System sets progress/create use case
    this.progressUri.setUseCase(PROGRESS_CREATE);

    // 6.B.2.A.5. System tries to create new progress
    try {
      // 6.B.2.A.6.A.
      await AppClient.post(this.progressUri, progressCreateDtoIn, { session });
    } catch (e) {
      // 6.B.2.A.6.B.
      LOGGER.error(`Progress create failed: `, e);
    }
  }

  async _deleteProgress(progress, session) {
    // 6.B.2.A.3.A.1.A.3.A.1.2.A.4. System sets use case to progress/delete
    this.progressUri.setUseCase(PROGRESS_DELETE);

    // 6.B.2.A.3.A.1.A.3.A.1.2.A.5. System tries to delete old progress
    try {
      // 6.B.2.A.3.A.1.A.3.A.1.2.A.6.A.
      await AppClient.post(this.progressUri, { code: progress.code }, { session });
    } catch (e) {
      // 6.B.2.A.3.A.1.A.3.A.1.2.A.6.B.
      LOGGER.error(`Progress delete failed: `, e);
    }
  }

  async _endProgress(progressEndDtoIn, session) {
    // 6.B.2.A.3.A.1.A.3.A.1.2.A.2. System sets use case to progress/end
    this.progressUri.setUseCase(PROGRESS_END);

    // 6.B.2.A.3.A.1.A.3.A.1.2.A.3. System tries to end old progress
    try {
      // 6.B.2.A.3.A.1.A.3.A.1.2.A.3.A.
      await AppClient.post(this.progressUri, progressEndDtoIn, { session });
    } catch (e) {
      // 6.B.2.A.3.A.1.A.3.A.1.2.A.3.B.
      LOGGER.error(`Progress end failed: `, e);
    }
  }

  _accessDeniedLogger(session) {
    LOGGER.error(
      `Failed to update progress. User ${session.getIdentity().getUuIdentity()} doesn't have permission to call ${
        this.progressUri
      } with code ${
        this.progressCode
      }. Please configure permissions properly (or use different user using ${APP_STATUS_PROGRESS_UUEE_CONFIG_NAME} deploy parameter.`
    );
  }

  /**
   * Loads and maps subAppInstance authorization strategy to corresponding progress authorization strategy
   * This allows AsidAuthorities, AsidExecutives and AsidAuditors to inherit casts from subApp as progress(Bus) Authorities, Writers, etc.
   * @returns {Promise<{authorizationStrategy: string}>}
   */
  async _getAuthorizationStategy() {
    const DEFAULT_AUTHZ_FALLBACK = { authorizationStrategy: DEFAULT_AUTHZ_STRATEGY };

    let subAppInstance;
    try {
      subAppInstance = await UuSubAppInstance.get(this.asid);
    } catch (e) {
      LOGGER.warn(
        `UuSubAppInstance get for the current asid (${this.asid}) failed. Progress will use default authz strategy: `,
        e
      );
      subAppInstance = {};
    }
    const authorizationData = subAppInstance.authorizationData;

    const mapAsidProfilesToConsoleProfiles = (profileList) =>
      profileList
        .filter((profile) => Object.keys(AUTHZ_ASID_PROFILE_MAP).includes(profile))
        .map((profile) => AUTHZ_ASID_PROFILE_MAP[profile]);
    const getMissingProfiles = (profileList) =>
      AUTHZ_REQUIRED_PROFILES.filter((profile) => !profileList.includes(profile));

    const logMissingProfiles = (missingConsoleProfiles, authStrategy, DEFAULT_AUTHZ_FALLBACK) => {
      if (missingConsoleProfiles.length > 0) {
        LOGGER.warn(
          `Current asid (${
            this.asid
          }) is set to ${authStrategy} authorization strategy, but is missing profiles that map to these required progress profiles: ${missingConsoleProfiles.join(
            ", "
          )}. Progress will use default authz strategy.`
        );
        return DEFAULT_AUTHZ_FALLBACK;
      }
    };

    switch (subAppInstance.authorizationStrategy) {
      // maps subAppInstance bound artifact asid profiles to console profiles
      case "boundArtifact": {
        const boundArtifactInfo = authorizationData.boundArtifact;

        let params = {};
        if (boundArtifactInfo.boundArtifactId) params.id = boundArtifactInfo.boundArtifactId;
        if (boundArtifactInfo.boundArtifactCode) params.code = boundArtifactInfo.boundArtifactCode;

        const boundArtifactUri = UriBuilder.parse(boundArtifactInfo.uuTerritoryBaseUri)
          .setUseCase("userGate/artifact")
          .setParameters(params)
          .toUri()
          .toString();
        const boundArtifactPermissionMatrix = { ...authorizationData.boundArtifact.boundArtifactProfileMap };
        for (const boundProfile in boundArtifactPermissionMatrix) {
          const profileList = mapAsidProfilesToConsoleProfiles(boundArtifactPermissionMatrix[boundProfile]);
          if (profileList.length === 0) {
            delete boundArtifactPermissionMatrix[boundProfile];
          } else {
            boundArtifactPermissionMatrix[boundProfile] = profileList;
          }
        }

        // check that all required console profiles are present
        const missingConsoleProfiles = getMissingProfiles(Object.values(boundArtifactPermissionMatrix).flat());
        logMissingProfiles(missingConsoleProfiles, "boundArtifact", DEFAULT_AUTHZ_FALLBACK);

        return {
          authorizationStrategy: "boundArtifact",
          boundArtifactUri,
          boundArtifactPermissionMatrix,
        };
      }

      // maps subAppInstance uuIdentity profiles to console profiles
      case "uuIdentityList": {
        const permissionMap = { ...authorizationData.uuIdentityList.permissionMap };
        for (const uuIdentity in permissionMap) {
          const profileList = mapAsidProfilesToConsoleProfiles(permissionMap[uuIdentity]);
          if (profileList.length === 0) {
            delete permissionMap[uuIdentity];
          } else {
            permissionMap[uuIdentity] = profileList;
          }
        }

        // check that all required console profiles are present
        const missingConsoleProfiles = getMissingProfiles(Object.values(permissionMap).flat());
        logMissingProfiles(missingConsoleProfiles, "uuIdentityList", DEFAULT_AUTHZ_FALLBACK);

        return {
          authorizationStrategy: "uuIdentityList",
          permissionMap,
        };
      }

      // maps asid-prefixed roleGroups to console profiles
      case "roleGroupInterface": {
        // gather roleGroup uris for asid roleGroups
        let asidAuthorizationUris = {};
        for (const asidProfileName in AUTHZ_ASID_PROFILE_MAP) {
          const asidProfile = (await Profile.get(this.asid, asidProfileName).catch()) || {};
          if (asidProfile.roleGroupUri) {
            asidAuthorizationUris[asidProfileName] = asidProfile.roleGroupUri;
          }
        }

        // check that all required console profiles are present
        const missingConsoleProfiles = getMissingProfiles(
          Object.keys(asidAuthorizationUris).map((asidProfileName) => AUTHZ_ASID_PROFILE_MAP[asidProfileName])
        );
        logMissingProfiles(missingConsoleProfiles, "roleGroupInterface", DEFAULT_AUTHZ_FALLBACK);

        return {
          authorizationStrategy: "roleGroupInterface",
          authorizationUriMap: Object.fromEntries(
            Object.entries(asidAuthorizationUris)
              .reverse() // last profile in the list has precedence
              .map(([profileName, roleGroupUri]) => [AUTHZ_ASID_PROFILE_MAP[profileName], roleGroupUri])
          ),
        };
      }

      // fallback artifact authorization
      default:
        return DEFAULT_AUTHZ_FALLBACK;
    }
  }

  getProgressUpdatePeriod() {
    return this.progressUpdatePeriod;
  }

  getAppStatusProgressBaseUriConfigName() {
    return APP_STATUS_PROGRESS_BASE_URI_CONFIG_NAME;
  }

  getAppStatusProgressUuEeConfigName() {
    return APP_STATUS_PROGRESS_UUEE_CONFIG_NAME;
  }
}

module.exports = new StatusUpdater();
