"use strict";
const { Sys } = require("uu_appg01_core-appserver");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");
const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { AuthenticationService } = require("uu_appg01_oidc");
const SysQosConfigurationAbl = require("../abl/sys-qos-configuration-abl.js");
const RequestCountHandler = require("./request-count-handler.js");
const PROGRESS_BUS_LOAD = "progressBus/load";
const PROGRESS_BUS_CREATE = "progressBus/create";
const PROGRESS_CREATE = "progressBus/progress/create";
const PROGRESS_START = "progressBus/progress/start";
const PROGRESS_PROCEED = "progressBus/progress/proceed";
const PROGRESS_END = "progressBus/progress/end";
const PROGRESS_DELETE = "progressBus/progress/delete";
const LOCKSECRET = "442bce0ca09d14fdea0077895468bf38857649da8b7034338aed94f71e501bc3";
const PROGRESS_BUS_DOES_NOT_EXIST = "progressBusDoesNotExist";
const PROGRESS_DOES_NOT_EXIST = "progressDoesNotExist";
const PROGRESS_IS_NOT_IN_PROPER_STATE = "progressIsNotInProperState";
const APP_QOS = "uuAppQoS";
const APP_QOS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME = "uu_app_qos_progress_expire_period_ms";
const APP_QOS_PROGRESS_EXPIRE_PERIOD_DEFAULT_VALUE = 60 * 60 * 1000;
const AUTHORIZATION_STRATEGY = "artifact";
const PROGRESS_STATES = ["waiting", "completed", "completedWithWarning", "completedWithError"];
const DEFAULT_STATE = "running";
const SPP_DEFAULT = "";
const LOGGER = LoggerFactory.get("uuapp.qos.RateLimiting");
const APPINFO = Sys.getAppInfo();
const PROGRESS_DELAY_WARNING = 15;
const PROGRESS_DELAY_ERROR = 30;
const MAX_NUMBER_OF_PROGRESS_ITEMS = 40;

class ProgressBarUpdateManager {
  // 4.1.2. is unclear
  constructor() {
    this.asid = Config.get("asid");
    // System sets nodeName from environment (nodeName format example:   "nodeName": "uuappg01_async-uu_script_engineg02_async-1617198494548.1.nkvnwdhr0k5w5pvcw5x2vsfpj"),
    this.nodeName =
      typeof process.env.UU_CLOUD_NODE_NAME !== "undefined"
        ? process.env.UU_CLOUD_NODE_NAME
        : `uuappg01-${APPINFO.uuSubApp.replace("-server", "")}-${new Date().getTime()}.1.${new Date().getTime()}`;
    // System sets spp
    this.spp =
      this.nodeName.split("-")[1] !== APPINFO.uuSubApp.replace("-server", "")
        ? this.nodeName.split("-")[1].slice(this.nodeName.split("-")[1].lastIndexOf("_") + 1)
        : SPP_DEFAULT;
    // System sets progressCode
    const progressCodePostfix = this.nodeName.split("-")[2].replace(/\./g, "_");
    this.progressCode = `${APP_QOS}_${progressCodePostfix}`;
    this.nodeNumber = progressCodePostfix.split("_")[1];
    this.progressName = this.spp === SPP_DEFAULT ? `node ${this.nodeNumber}` : `${this.spp} - node ${this.nodeNumber}`;

    this.uuSubAppName = ProgressBarUpdateManager._getSubAppName();
    this.progressBusName = `${this.uuSubAppName} - ${this.asid}`;
  }

  async updateProgress(indicationData = {}, uuAppErrorMap = {}) {
    let date = new Date();
    let estimatedNextProgressTs = new Date(date.getTime());
    estimatedNextProgressTs.setSeconds(
      estimatedNextProgressTs.getSeconds() + SysQosConfigurationAbl.getProgressUpdatePeriod()
    );
    let quota = await SysQosConfigurationAbl.getConfiguration();
    let proceedData = {
      limitError: quota.totalLimitError,
      counterResetTimeInterval: quota.counterResetTimeInterval,
    };
    let proceedDtoIn = this._composeProceedDtoIn(
      this.uuSubAppName,
      proceedData,
      this.progressCode,
      indicationData,
      estimatedNextProgressTs,
      uuAppErrorMap
    );
    let progressBaseUri = UriBuilder.parse(quota.progressBaseUri);
    await this._updateProgress(progressBaseUri, proceedDtoIn);
  }

  isConsoleUriConfigured() {
    return !!(SysQosConfigurationAbl.getProgressBaseUri() && SysQosConfigurationAbl.getProgressUpdateEnabled());
  }

  async _updateProgress(progressBaseUri, proceedDtoIn) {
    let session = await AuthenticationService.authenticate({ systemIdentity: this.asid });
    try {
      let appClient = new AppClient({ baseUri: progressBaseUri });
      await appClient.post(PROGRESS_PROCEED, proceedDtoIn, { session });
    } catch (e) {
      if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
        LOGGER.error(this._getAuthorizationErrorMessage(progressBaseUri, session, "Failed to update progress."));
        return;
      }
      await this._runAlternativeScenario(e, session, progressBaseUri, proceedDtoIn);
    }
  }

  _composeProceedDtoIn(
    uuSubAppName,
    proceedData,
    progressCode,
    indicationData,
    estimatedNextProgressTs,
    uuAppErrorMap
  ) {
    let counter = RequestCountHandler.getCounter;
    let data = {
      uuSubAppName,
      uuSubAppVersion: APPINFO.uuSubAppVersion,
      nodeName: this.nodeName,
      spp: this.spp,
      asid: this.asid,
      uuAppErrorMap,
    };
    data = { ...data, ...RequestCountHandler.getCounterHistory };

    return {
      code: progressCode,
      estimatedNextProgressTs: estimatedNextProgressTs.toISOString(),
      delayWarning: PROGRESS_DELAY_WARNING,
      delayError: PROGRESS_DELAY_ERROR,
      lockSecret: LOCKSECRET,
      message: indicationData.message,
      totalWork: proceedData.limitError,
      doneWork: counter.total,
      state: indicationData.state || DEFAULT_STATE,
      expireAt: this._getExpirationTime(),
      data,
    };
  }

  async _runAlternativeScenario(error, session, progressBaseUri, proceedDtoIn) {
    // System checks if progressDoesNotExist or progressIsNotInProperState error occured and procceses it
    if (error.code && error.code.endsWith(PROGRESS_DOES_NOT_EXIST)) {
      LOGGER.debug(`Progress with code ${proceedDtoIn.code} doesn't exist. Creating...`);

      // System parses node set ids from progressCode
      let nodeIdsFromEnv = proceedDtoIn.code.split("_");
      //System prepares progressCreateDtoIn
      let progressCreateDtoIn = {
        code: proceedDtoIn.code,
        progressBusCode: SysQosConfigurationAbl.getProgressBusCode(),
        name: this.progressName,
        expireAt: this._getExpirationTime(),
      };
      //node number 1 in each nodeSet checks if exist progressBus and old progresses
      if (this.nodeNumber === "1") {
        // System tries to get progressBus with all progresses
        try {
          // System sets use case to progressBus/load
          let appClient = new AppClient({ baseUri: progressBaseUri });
          // System loads progressBus using AppClient with session from HDS 4.
          let progressBus = await appClient.get(
            PROGRESS_BUS_LOAD,
            { code: SysQosConfigurationAbl.getProgressBusCode() },
            { session }
          );
          // System checks for progresses and removes old ones if necessary
          if (progressBus.progressList.length > 0) {
            //  For each progress
            await this._cleanUpProgressBar(
              progressBaseUri,
              progressBus,
              nodeIdsFromEnv,
              session,
              proceedDtoIn.lockSecret
            );
          }
        } catch (e) {
          // progressBus/load failed
          await this._createProgressBus(e, session, progressBaseUri);
        }
      }
      // System sets progress/create use case
      // System tries to create new progress
      try {
        let appClient = new AppClient({ baseUri: progressBaseUri });
        await appClient.post(PROGRESS_CREATE, progressCreateDtoIn, { session });
      } catch (e) {
        if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
          LOGGER.error(this._getAuthorizationErrorMessage(progressBaseUri, session, "Failed to create progress."));
          return;
        } else {
          LOGGER.error(`Failed to create progress:`, e);
        }
      }
      await this._startAndProceedProgress(progressBaseUri, proceedDtoIn, session);
    } else if (error.code && error.code.endsWith(PROGRESS_IS_NOT_IN_PROPER_STATE)) {
      // If e.paramMap.state exist and is in one of the state "waiting", "completed", "completedWithWarning" or "completedWithError"
      if (error.paramMap && error.paramMap.state && PROGRESS_STATES.includes(error.paramMap.state)) {
        await this._startAndProceedProgress(progressBaseUri, proceedDtoIn, session);
      }
    } else {
      LOGGER.error(`Progress proceed failed: `, error);
    }
  }

  async _createProgressBus(error, session, progressBaseUri) {
    if (error.code && error.code.endsWith(PROGRESS_BUS_DOES_NOT_EXIST)) {
      LOGGER.debug(`ProgressBus with code ${SysQosConfigurationAbl.getProgressBusCode()} doesn't exist. Creating...`);

      // System prepares progressBusCreateDtoIn
      let progressBusCreateDtoIn = {
        code: SysQosConfigurationAbl.getProgressBusCode(),
        name: this.progressBusName,
        maxNumberOfProgressItems: MAX_NUMBER_OF_PROGRESS_ITEMS,
        authorizationStrategy: AUTHORIZATION_STRATEGY,
        data: {
          uuSubAppName: this.uuSubAppName,
          uuSubAppVersion: APPINFO.uuSubAppVersion,
          asid: this.asid,
        },
      };
      // System sets use case to progressBus/create;
      // System tries to create progressBus
      try {
        let appClient = new AppClient({ baseUri: progressBaseUri });
        await appClient.post(PROGRESS_BUS_CREATE, progressBusCreateDtoIn, { session });
      } catch (e) {
        if (e.code && e.code === "uu-appg01/authorization/accessDenied") {
          LOGGER.error(this._getAuthorizationErrorMessage(progressBaseUri, session, "Failed to create progressBus."));
          return;
        }
        LOGGER.error(`ProgressBus create failed: `, e);
      }
    } else {
      LOGGER.error(`ProgressBus load failed: `, error);
    }
  }

  async _startAndProceedProgress(progressBaseUri, proceedDtoIn, session) {
    // System prepares progressStartDtoIn
    let progressStartDtoIn = {
      code: proceedDtoIn.code,
      lockSecret: LOCKSECRET,
    };
    // System sets progress/start use case
    // System tries to start progress
    try {
      let appClient = new AppClient({ baseUri: progressBaseUri });
      await appClient.post(PROGRESS_START, progressStartDtoIn, { session });
    } catch (e) {
      LOGGER.error(`Progress start failed: `, e);
      return;
    }
    // System sets progress/proceed use case
    // System tries to proceed progress
    try {
      let appClient = new AppClient({ baseUri: progressBaseUri });
      await appClient.post(PROGRESS_PROCEED, proceedDtoIn, { session });
    } catch (e) {
      LOGGER.error(`Progress proceed failed: `, e);
    }
  }

  async _cleanUpProgressBar(progressBaseUri, progressBus, nodeIdsFromEnv, session, lockSecret) {
    for (let progress of progressBus.progressList) {
      // System parses node ids from progress.code
      let nodeIdsFromProgress = progress.code.split("_");
      // System checks if app is deployed after undeploy or redeployed with different version
      if (this._checkCorruptedDeploy(nodeIdsFromEnv, nodeIdsFromProgress, progress)) {
        // System prepares progressEndDtoIn for ending progress.
        let progressEndDtoIn = {
          code: progress.code,
          lockSecret,
        };
        // System sets use case to progress/end
        // System tries to end old progress
        try {
          let appClient = new AppClient({ baseUri: progressBaseUri });
          await appClient.post(PROGRESS_END, progressEndDtoIn, { session });
        } catch (e) {
          LOGGER.error(`Progress end failed: `, e);
        }
        // System sets use case to progress/delete
        // System tries to delete old progress
        try {
          let appClient = new AppClient({ baseUri: progressBaseUri });
          await appClient.post(PROGRESS_DELETE, { code: progress.code }, { session });
        } catch (e) {
          LOGGER.error(`Progress delete failed: `, e);
        }
      }
    }
  }

  _checkCorruptedDeploy(nodeIdsFromEnv, nodeIdsFromProgress, progress) {
    return progress.data.uuSubAppVersion !== APPINFO.uuSubAppVersion && this.spp === progress.data.spp;
  }

  static _getSubAppName() {
    return APPINFO.uuSubApp
      .split("_")
      .map((s, i) => (i === 0 ? s : s && s[0].toUpperCase() + s.slice(1)))
      .join("")
      .replace("-server", "");
  }

  _getAuthorizationErrorMessage(progressBaseUri, session, msg) {
    return (
      msg +
      " User " +
      session.getIdentity().getUuIdentity() +
      " doesn't have permission to call " +
      progressBaseUri.toString() +
      " with code " +
      this.progressCode +
      ". Please configure permissions properly."
    );
  }

  _getExpirationTime() {
    let date = new Date();
    let expireAt = new Date(date.getTime());
    let progressExpirePeriod = Config.get(APP_QOS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME)
      ? Config.getNumber(APP_QOS_PROGRESS_EXPIRE_PERIOD_CONFIG_NAME)
      : APP_QOS_PROGRESS_EXPIRE_PERIOD_DEFAULT_VALUE;
    expireAt.setTime(expireAt.getTime() + progressExpirePeriod);
    return expireAt.toISOString();
  }
}

module.exports = new ProgressBarUpdateManager();
