/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_core", ["module"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_core"] = factory(require("module"));
	else
		root["UuApp"] = factory(root["undefined"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_module__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/base64-js/index.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

/***/ }),

/***/ "../node_modules/buffer/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _assertThisInitialized = (__webpack_require__("../node_modules/@babel/runtime/helpers/assertThisInitialized.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var base64 = __webpack_require__("../node_modules/base64-js/index.js");
var ieee754 = __webpack_require__("../node_modules/ieee754/index.js");
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  var i;
  for (i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
        thirdByte = void 0,
        fourthByte = void 0,
        tempCodePoint = void 0;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = (first << 24) +
  // Overflow
  this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
var errors = {};
function E(sym, getMessage, Base) {
  errors[sym] = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError() {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this);
      Object.defineProperty(_assertThisInitialized(_this), 'message', {
        value: getMessage.apply(_assertThisInitialized(_this), arguments),
        writable: true,
        configurable: true
      });

      // Add the error code to the name to include it in the stack trace.
      _this.name = `${_this.name} [${sym}]`;
      // Access the stack to generate the error message including the error code
      // from the name.
      _this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete _this.name;
      return _this;
    }
    _createClass(NodeError, [{
      key: "code",
      get: function get() {
        return sym;
      },
      set: function set(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    }]);
    return NodeError;
  }(Base);
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return `${name} is outside of buffer bounds`;
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = `The value of "${str}" is out of range.`;
  var received = input;
  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);
    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }
    received += 'n';
  }
  msg += ` It must be ${range}. Received ${received}`;
  return msg;
}, RangeError);
function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}

// CHECK FUNCTIONS
// ===============

function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`;
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }
  checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }
  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  var i;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();

// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}

/***/ }),

/***/ "../node_modules/ieee754/index.js":
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "../node_modules/js-sha1/src/sha1.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var root = typeof window === 'object' ? window : {};
  var NODE_JS = !root.JS_SHA1_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = __webpack_require__.g;
  }
  var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];
  var blocks = [];
  var createOutputMethod = function createOutputMethod(outputType) {
    return function (message) {
      return new Sha1(true).update(message)[outputType]();
    };
  };
  var createMethod = function createMethod() {
    var method = createOutputMethod('hex');
    if (NODE_JS) {
      method = nodeWrap(method);
    }
    method.create = function () {
      return new Sha1();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };
  var nodeWrap = function nodeWrap(method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var nodeMethod = function nodeMethod(message) {
      if (typeof message === 'string') {
        return crypto.createHash('sha1').update(message, 'utf8').digest('hex');
      } else if (message.constructor === ArrayBuffer) {
        message = new Uint8Array(message);
      } else if (message.length === undefined) {
        return method(message);
      }
      return crypto.createHash('sha1').update(new Buffer(message)).digest('hex');
    };
    return nodeMethod;
  };
  function Sha1(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;
    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  Sha1.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString = typeof message !== 'string';
    if (notString && message.constructor === root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var code,
      index = 0,
      i,
      length = message.length || 0,
      blocks = this.blocks;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }
      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };
  Sha1.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };
  Sha1.prototype.hash = function () {
    var a = this.h0,
      b = this.h1,
      c = this.h2,
      d = this.h3,
      e = this.h4;
    var f,
      j,
      t,
      blocks = this.blocks;
    for (j = 16; j < 80; ++j) {
      t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
      blocks[j] = t << 1 | t >>> 31;
    }
    for (j = 0; j < 20; j += 5) {
      f = b & c | ~b & d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1518500249 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | ~a & c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1518500249 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | ~e & b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1518500249 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | ~d & a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1518500249 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | ~c & e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1518500249 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 40; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1859775393 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1859775393 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1859775393 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1859775393 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1859775393 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 60; j += 5) {
      f = b & c | b & d | c & d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 1894007588 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | a & c | b & c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 1894007588 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | e & b | a & b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 1894007588 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | d & a | e & a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 1894007588 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | c & e | d & e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 1894007588 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 80; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 899497514 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 899497514 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 899497514 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 899497514 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 899497514 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
  };
  Sha1.prototype.hex = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4;
    return HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h4 >> 28 & 0x0F] + HEX_CHARS[h4 >> 24 & 0x0F] + HEX_CHARS[h4 >> 20 & 0x0F] + HEX_CHARS[h4 >> 16 & 0x0F] + HEX_CHARS[h4 >> 12 & 0x0F] + HEX_CHARS[h4 >> 8 & 0x0F] + HEX_CHARS[h4 >> 4 & 0x0F] + HEX_CHARS[h4 & 0x0F];
  };
  Sha1.prototype.toString = Sha1.prototype.hex;
  Sha1.prototype.digest = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4;
    return [h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF];
  };
  Sha1.prototype.array = Sha1.prototype.digest;
  Sha1.prototype.arrayBuffer = function () {
    this.finalize();
    var buffer = new ArrayBuffer(20);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    return buffer;
  };
  var exports = createMethod();
  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha1 = exports;
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/client.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _objectSpread = (__webpack_require__("../node_modules/@babel/runtime/helpers/objectSpread2.js")["default"]);
var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var Helpers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js");
var HttpClient = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/http-client.browser.js");
var PerflogHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/perflog-handler.js");
var RemoteErrorHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/remote-error-handler.js");
var TransformParametersHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/transform-parameters-handler.browser.js");
var UriHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/uri-handler.js");
var CsrfTokenHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/csrf-token-handler.browser.js");
var RetryHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler.browser.js");
var DEFAULT_INTERCEPTORS = [PerflogHandler, UriHandler, CsrfTokenHandler, RemoteErrorHandler, RetryHandler, TransformParametersHandler];

/**
 * Creates an instance of command client which will use specified configuration when invoking commands.
 * Unspecified values are taken from global defaults ({@link UuApp.AppClient.Client.defaults Client.defaults}). Most
 * values can be further overridden when invoking the remote call - see {@link UuApp.AppClient.Client#post Client#post}.
 *
 * **Interceptors**
 *
 * It's possible to provide a list of interceptors which pre-/post-process HTTP requests. An interceptor
 * is a JavaScript function {Promise<Response>} interceptorFn({Object} request, {Object} options, {Function} nextInterceptorFn).
 * Request object contains fields uri, method, body and options object contains any remaining options passed down to
 * interceptors, e.g. transformParameters). Example:
 *
 *     function MyInterceptor(request, options, nextInterceptorFn) {
 *       // pre-process in any way
 *       request.headers["x-extra-header-computed-value"] = Math.random() + "";
 *       console.log("Launching Ajax request. Method:", request.method, "Uri:", request.uri, "Parameters:", request.body, "Other options:", options);
 *       let start = new Date().getTime();
 *       return nextInterceptorFn(request, options).then(function (response) {
 *         // post-process in any way, e.g. add extra field to the response object
 *         response.timeTaken = new Date().getTime() - start;
 *         return response;
 *       }, function error(response) {
 *         // ...
 *         return Promise.reject(response); // keep it rejected (i.e. in error state)
 *       });
 *     }
 *
 *     // usage of the interceptor
 *     let client = new UuApp.AppClient.Client({
 *       interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *     });
 *
 * @class UuApp.AppClient.Client
 * @classdesc
 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
 * Besides communication, the client solves also other points of interest, such as authentication or
 * performance logging.
 *
 * Client uses standardized {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise API}
 * to provide access to the result of the call.
 *
 *     UuApp.AppClient.Client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function (response) {
 *       console.log(response.data, response.status, response.headers());
 *     }, function (response) { // error
 *       console.log(response.error, response.status, response.headers());
 *     });
 *
 * When used as above, client uses global defaults (timeout, headers, ...). If the call needs to be parametrized, it can
 * be parametrized directly in {@link UuApp.AppClient.Client#post Client#post} ({@link UuApp.AppClient.Client#get Client#get})
 * call or, alternatively, a client instance can be created with defaults that override the global ones.
 *
 * For pre-/post-processing of HTTP requests use custom interceptors (see constructor).
 *
 * **Configuration**
 *
 * Some options are automatically configured from the environment during
 * {@link UuApp.Util.Config.init Config.init} call. These can be overridden when instantiating
 * the client or in method invocations. Supported environment options:
 *
 *     {
 *       "gatewayUri": "https://uuappg01.plus4u.net", // default gateway for command calls using uuUri that doesn't contain gateway
 *       "vendor-app-subapp-spp.gatewayUri": "https://elsewhere.plus4u.net"
 *     }
 *
 * @param {Object} options Default options for this instance of the command client.
 * @param {number} options.requestTimeout The default HTTP timeout for this instance of the command client, in seconds.
 * @param {Object} options.headers The default HTTP headers for command invocations using this instance of the command client.
 * @param {Object[]} options.interceptors List of interceptors to use. Interceptors can arbitrarily pre-/post-process
 * @param options {object}
 * @param options.retryPolicy {object}
 * @param [options.retryPolicy.maxAttempts=3] {number} - Max attempts
 * @param [options.retryPolicy.maxTimeInterval=30000] {number} - Max time interval in ms
 * @param [options.retryPolicy.baseTimeInterval=100] {number} - Base time interval in ms
 * @param options.retryPolicy.retryCondition {object}
 * @param [options.retryPolicy.retryCondition.httpMethods = ["POST", "GET"]] {array<string>}
 * @param [options.retryPolicy.retryCondition.httpStatusCodes = ["502", "503"]] {array<string>} - Pass "5xx" to work with all 5xx status codes
 * @param [options.retryPolicy.retryCondition.errorCodes = [] ] {array<string>} - Pass "5xx" to work with all 5xx status codes
 *   HTTP requests.
 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
 *   as "gatewayUri" which then take precedence over those from global environment.
 *
 * @example
 *    let client = new UuApp.AppClient.Client({
 *      requestTimeout: 20,
 *      headers: {
 *        "x-my-extra-header": "abcd"
 *      },
 *      interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *    });
 *
 *    // ... all calls using "client.get(...)" or "client.post()" will have timeout 20s (unless the timeout
 *    // is overridden in the invoke call directly) and will have an extra HTTP header.
 */
var Client = /*#__PURE__*/function () {
  function Client() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Client);
    this._options = {
      // default options
      retryPolicy: {
        maxAttempts: 3,
        maxTimeInterval: 30000,
        baseTimeInterval: 100,
        retryCondition: {
          httpMethods: ["GET", "POST"],
          httpStatusCodes: ["503", "599"]
        }
      }
    };
    Helpers.mergeOptions(this._options, options); // override options with the custom ones

    this._options.headers = Helpers.keysToLowerCase(this._options.headers);
    this._aborted = false;
  }

  /**
   * Invokes remote call using HTTP GET request. See {@link UuApp.AppClient.Client#post Client#post}
   * for detailed options and behaviour.
   *
   * Keep in mind that the "dtoIn" parameter is sent via URL parameter(s)
   * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
   * doesn't exceed 2048 bytes.
   *
   * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
   * @param {*} dtoIn The parameters to send in the request URL.
   * @param {Object} options Optional options for the remote call.
   * @return Promise resolving to a response object (or rejecting to a response object with error field).
   * @method UuApp.AppClient.Client#get
   * @see {@link UuApp.AppClient.Client#post Client#post}
   *
   * @example
   *    // simple call
   *    let baseUri = Uri.parse(location.protocol + "//" + location.host + location.pathname).baseUri; // "http://example.com/vendor-app/tid-awid"
   *    Client.get(baseUri.join("+/getAttributes"), { param1: "v1" }).then(function success(response) {
   *      let data = response.data; // contains parsed response entity
   *      console.log(response.status, response.headers(), response.data);
   *    }, function error(response) {
   *      let error = response.error; // contains parsed response error
   *      console.log(response.status, response.headers(), response.error);
   *    });
   *
   * @example
   *    // parameterizing uuUri and the call
   *    let uri = new UuApp.Uri.UriBuilder("/cds-gb-main/0-0/getAttributes", {
   *      workspace: "15634-34e5684da3435",
   *      useCase: "getConfig",
   *      parameters: { p1: "v1" }
   *    }).toUri();
   *    client.get(uri, null, {
   *      requestTimeout: 5,
   *      headers: {
   *        "x-my-header": "abc"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   *
   * @example
   *    // accept any response and don't parse it
   *    let workspace = "...";
   *    let guestbookId = "...";
   *    client.get(`/cds-gb/${workspace}/guestbook/${guestbookId}/downloadData`, null, {
   *      transformResponse: false,
   *      headers: {
   *        "accept": "*\/*"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   */
  _createClass(Client, [{
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uri, dtoIn, options) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this._invoke("get", uri, dtoIn, options));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function get(_x, _x2, _x3) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
    /**
     * Analog to async get() public method
     * Main difference - Returns properly filled dtoOut described in CMD design
     * Invokes remote call using HTTP GET request.
     * for detailed options and behaviour.
     *
     * Keep in mind that the "dtoIn" parameter is sent via URL parameter(s)
     * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
     * doesn't exceed 2048 bytes.
     *
     * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
     * @param {*} dtoIn The parameters to send in the request URL.
     * @param {Object} options Optional options for the remote call.
     * @return Promise resolving to a response object (or rejecting to a response object with error field).
     * @method UuApp.AppClient.Client#get
     */
  }, {
    key: "cmdGet",
    value: function () {
      var _cmdGet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uri, dtoIn, options) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this._invoke("get", uri, dtoIn, options, true));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function cmdGet(_x4, _x5, _x6) {
        return _cmdGet.apply(this, arguments);
      }
      return cmdGet;
    }()
    /**
     * Invokes remote call using HTTP POST request. Default values for settings will
     * be filled in from Client instance configuration and then from global defaults.
     *
     * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
     * to the specified "content-type" HTTP request/response header.
     * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
     * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
     * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
     * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
     *
     * **Return value**
     *
     * Return value is a {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
     * resolving / rejecting to a response object which contains following fields:
     *
     * * {Object} data - response data. Data is parsed with content handler according to "content-type" response header
     *     unless option transformResponse is false (in which case it's left as received from browser).
     * * {Error} error - the error instance (see Error handling below). This field is set if and only if the Promise is rejected.
     * * {number} status - the HTTP status code.
     * * {function(string)} headers - function which returns value of the specified (case-insenstive) response header.
     *   If called with no arguments, an array with all response headers is returned.
     * * {Object} config - final configuration options that were used for launching AJAX request.
     *
     * The returned Promise instance additionally contains method {function()} abort for aborting ongoing remote call.
     *
     * **File upload**
     *
     * Use "content-type" header with "multipart/form-data" value when uploading binary data (File, Blob). Alternatively, it's
     * possible to use standard {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object - see examples
     * below. Note that when using FormData object, the order of appending the form fields matters - append simple values first
     * and only in the end append file objects. The reason is that in this order, the server might decide not to allow the upload
     * based on the other already-available fields thus allowing to end the connection without full upload of the file(s).
     * _(Client will fix the order of values in FormData object, however not all browsers support this operation.)_
     *
     * **Error handling**
     *
     * If an error happens during the call invocation (determined by HTTP response status code), the resulting Promise is
     * rejected with response object which will contain "error" field set to an instance of one of these error types
     * (when using default interceptors):
     *
     *   * null - if server sent response with error HTTP status code but it contained no recognizable error data.
     *   * {@link UuApp.Error.RemoteError} - error as sent from remote server. Note that the response can contain
     *     several errors - in such case only first error is extracted into "error" field.
     *   * {@link UuApp.Error.NetworkError} - in case of problems with connecting to remote server.
     *   * {@link UuApp.Error.TimeoutError} - when the request didn't end within specified timeout.
     *   * {@link UuApp.Error.AbortError} - when invocation is aborted by invoking promise.abort() method.
     *
     * The resulting response object contains also HTTP status code and will contain "data"
     * field set to the response entity (usually containing parsed error list).
     *
     * **Timeout**
     *
     * The timeout applies to the remote call duration only. If an interceptor is used which performs lengthy or asynchronous
     * operation prior to executing the remote call, it's not counted towards the timeout.
     *
     * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
     * @param {(FormData|*)} dtoIn The DTO to send in the request body.
     * @param {Object} options Optional options for the remote call.
     * @param {number} options.requestTimeout The timeout for the command invocation. Default is 0 (no timeout).
     * @param {Object} options.headers The HTTP headers to send. Header names are case-insensitive, but it's advised
     *   to use lowercased names to prevent duplicities within the map. Headers are merged with default headers from
     *   Client / global configuration. If a header is in defaults and it's required to prevent it from being
     *   sent during this invocation, specify the header and use null as its value.
     * @param {boolean} options.transformParameters If false, processing of the command parameters (DTO) will be skipped so they'll be
     *   sent exactly as-is (the browser must support sending the value as-is in XmlHttpRequest). Default value is true.
     * @param {boolean} options.transformResponse If false, processing of the response (such as parsing the response as JSON) will be skipped. Default is true.
     * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
     *   as "gatewayUri" which then take precedence over those from global environment.
     * @return Promise resolving to a response object (or rejecting to a response object with error field).
     * @method UuApp.AppClient.Client#post
     *
     * @example
     *    // command call sending data
     *    let tenant = "UU-BT";
     *    let guestbookId = "123";
     *    client.post(`/cds-gb/${tenant}/guestbook/${guestbookId}/setAttributes`, {
     *      name: "Modified guestbook",
     *      invitesLimit: 10,
     *      public: true
     *    }).then(console.log.bind(console), console.log.bind(console));
     *
     * @example
     *     // uploading file(s) - variant 1 (explicit Content-Type header)
     *     let file = inputElement.files[0];
     *     let params = {
     *       file: file,
     *       anotherValue: "abc"
     *     }
     *     client.post("/cds-gb/UU-BT/guestbook/123/uploadData", params, {
     *       headers: {
     *         "content-type": "multipart/form-data"
     *       }
     *     });
     *
     *     // uploading file(s) - variant 2 (usage of FormData)
     *     // !!! append files as the last values
     *     let formData = new FormData();
     *     formData.append("anotherValue", "abc");
     *     formData.append("file", file);
     *     let promise = client.post("/cds-gb/UU-BT/guestbook/123/uploadData", formData);
     *     promise.then(...); // process response / error
     *
     *     // aborting ongoing call
     *     elementForUploadCancel.onclick = function (e) {
     *       promise.abort(); // promise will be rejected with UuApp.Error.AbortError instance
     *     };
     *
     * @example
     *    // error distinguishing
     *    client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function success(response) {
     *      console.log(response.status, response.headers(), response.data);
     *    }, function error(response) {
     *      console.log(response.status, response.headers(), response.data);
     *      let error = response.error;
     *      if (error instanceof UuApp.Error.TimeoutError) console.log("Timed out.");
     *      else if (error instanceof UuApp.Error.AbortError) console.log("Aborted.");
     *      else if (error instanceof UuApp.Error.NetworkError) console.log("Communication / network error.");
     *      else if (response.status == 401) console.log("Not authenticated.");
     *      else if (response.status < 500) {
     *        console.log("User or client problem - invalid data / unfulfilled business rules / invalid call / ...", response.data);
     *      } else if (response.status >= 500) console.log("Server-side problem.", response.data);
     *      else console.log("Unrecognized problem.", error);
     *    });
     *
     * @example
     *    // send data in custom format
     *    client.post("/cds-gb/UU-BT/guestbook/123/setSomething", convertToMySuperFormat(dto), {
     *      transformParameters: false,
     *      headers: {
     *        "content-type": "text/x-my-super-format"
     *      }
     *    }).then(console.log.bind(console), console.log.bind(console));
     */
  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(uri, dtoIn, options) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this._invoke("post", uri, dtoIn, options));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function post(_x7, _x8, _x9) {
        return _post.apply(this, arguments);
      }
      return post;
    }()
    /**
     * Analog to async post() public method
     * Invokes remote call using HTTP POST request. Default values for settings will
     * be filled in from Client instance configuration and then from global defaults.
     *
     * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
     * to the specified "content-type" HTTP request/response header.
     * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
     * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
     * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
     * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
     *
     * Returns properly filled dtoOut described in CMD design
     */
  }, {
    key: "cmdPost",
    value: function () {
      var _cmdPost = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(uri, dtoIn, options) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this._invoke("post", uri, dtoIn, options, true));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function cmdPost(_x10, _x11, _x12) {
        return _cmdPost.apply(this, arguments);
      }
      return cmdPost;
    }()
  }, {
    key: "_invoke",
    value: function () {
      var _invoke2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(method, uri, dtoIn, options) {
        var _this = this;
        var shouldUnwrap,
          request,
          invocationChain,
          result,
          _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              shouldUnwrap = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : false;
              // prepare request
              request = {
                method: (method || "post").toLowerCase(),
                uri: uri,
                body: dtoIn,
                headers: _objectSpread(_objectSpread({}, this._options.headers), Helpers.keysToLowerCase((options || {}).headers))
              }; // build invocation chain
              invocationChain = ((options || {}).interceptors || (this._options || {}).interceptors || this.constructor.getDefaultInterceptors() || []).reduceRight(function (result, interceptorClass) {
                return new interceptorClass(result, _this._options);
              }, new HttpClient(this._options)); // invoke request
              _context5.next = 5;
              return invocationChain.invoke(request, options);
            case 5:
              result = _context5.sent;
              if (shouldUnwrap) {
                if (typeof window === "object") {
                  result = result.data;
                } else if (result.unwrap) {
                  result = result.unwrap().body;
                }
              }
              return _context5.abrupt("return", result);
            case 8:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function _invoke(_x13, _x14, _x15, _x16) {
        return _invoke2.apply(this, arguments);
      }
      return _invoke;
    }()
  }], [{
    key: "get",
    value:
    /**
     * Equivalent to {@link UuApp.AppClient.Client#get} using Client with default
     * configuration, i.e.:
     *
     *     new UuApp.AppClient.Client().get(uri, options)
     *
     * @see {@link UuApp.AppClient.Client#get Client#get}
     * @method UuApp.AppClient.Client.get
     */
    function () {
      var _get2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(uri) {
        var dtoIn,
          options,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              dtoIn = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : null;
              options = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : null;
              return _context6.abrupt("return", new Client().get(uri, dtoIn, options));
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      function get(_x17) {
        return _get2.apply(this, arguments);
      }
      return get;
    }()
    /**
     * Equivalent to UuApp.AppClient.Client.cmdGet using Client with default
     * configuration, i.e.:
     *
     *     new UuApp.AppClient.Client().cmdGet(uri, options)
     *
     * @method UuApp.AppClient.Client.cmdGet
     */
  }, {
    key: "cmdGet",
    value: function () {
      var _cmdGet2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(uri) {
        var dtoIn,
          options,
          _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              dtoIn = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : null;
              options = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : null;
              return _context7.abrupt("return", new Client().cmdGet(uri, dtoIn, options));
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      function cmdGet(_x18) {
        return _cmdGet2.apply(this, arguments);
      }
      return cmdGet;
    }()
    /**
     * Equivalent to {@link UuApp.AppClient.Client#post} using Client with default
     * configuration, i.e.:
     *
     *     new UuApp.AppClient.Client().post(uri, dtoIn, options)
     *
     * @see {@link UuApp.AppClient.Client#post Client#post}
     * @method UuApp.AppClient.Client.post
     */
  }, {
    key: "post",
    value: function () {
      var _post2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(uri) {
        var dtoIn,
          options,
          _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              dtoIn = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : null;
              options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : null;
              return _context8.abrupt("return", new Client().post(uri, dtoIn, options));
            case 3:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function post(_x19) {
        return _post2.apply(this, arguments);
      }
      return post;
    }()
    /**
     * Equivalent to UuApp.AppClient.Client.cmdPost using Client with default
     * configuration, i.e.:
     *
     *     new UuApp.AppClient.Client().cmdPost(uri, dtoIn, options)
     *
     * @method UuApp.AppClient.Client.cmdPost
     */
  }, {
    key: "cmdPost",
    value: function () {
      var _cmdPost2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(uri) {
        var dtoIn,
          options,
          _args9 = arguments;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              dtoIn = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : null;
              options = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : null;
              return _context9.abrupt("return", new Client().cmdPost(uri, dtoIn, options));
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function cmdPost(_x20) {
        return _cmdPost2.apply(this, arguments);
      }
      return cmdPost;
    }()
  }, {
    key: "getDefaultInterceptors",
    value: function getDefaultInterceptors() {
      return DEFAULT_INTERCEPTORS;
    }
  }]);
  return Client;
}();
module.exports = Client;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers-multipart.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var _require2 = __webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js"),
  LoggerFactory = _require2.LoggerFactory;
var dotNotate = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/dot-notate.js");
var logger;
var MultiPart = {
  serialize: function serialize(value) {
    if (!value) return value;
    if (typeof value !== "object") {
      this._getLogger().warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", {
        value: value
      });
      return value;
    }
    if (value instanceof FormData && typeof value.entries !== "function") return value; // FormData without support for iterating over its entries
    if (value instanceof Blob) value = {
      file: value
    };

    // make a list and reorder values so that the file instances are at the end of the list
    var data = {};
    if (value instanceof FormData) {
      var _iterator = _createForOfIteratorHelper(value.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pair = _step.value;
          data[pair[0]] = pair[1];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      data = value;
    }
    var list = [];
    var hasBinary;
    for (var k in data) {
      var item = data[k];
      if (item instanceof Blob) {
        if (hasBinary) {
          this._getLogger().warn("Too many binary fields. Only single binary field per multipart request is supported.");
        }
        hasBinary = true;
      } else if (typeof item === "object") {
        try {
          list = list.concat(dotNotate(item, k));
          continue;
        } catch (e) {
          throw new BaseError(`Serialization of key: ${k} into FormData failed.` + `Try serializing the nested object beforehand.`, e);
        }
      }
      list.push({
        key: k,
        value: item
      });
    }
    var max = list.length;
    var idx = 0;
    list.sort(function (a, b) {
      // stable sort
      var result = (a.value instanceof Blob ? idx + max : idx) - (b.value instanceof Blob ? idx + max : idx);
      idx++;
      return result;
    });

    // fill values into FormData
    var formData = new FormData();
    list.forEach(function (it) {
      if (it.value instanceof Blob) {
        formData.append(it.key, it.value, it.value.name || `${Date.now()}.bin`);
      } else if (typeof it.value === "boolean") {
        formData.append(it.key, it.value.toString());
      } else {
        formData.append(it.key, it.value);
      }
    });
    return formData;
  },
  deserialize: function deserialize(value) {
    throw new BaseError("Deserializing multipart/form-data is not supported. Value: " + value);
  },
  _getLogger: function _getLogger() {
    if (!logger) {
      logger = LoggerFactory.get("UuApp.AppClient.Client");
    }
    return logger;
  }
};
module.exports = MultiPart;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  Json = _require.Json;
var _require2 = __webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js"),
  LoggerFactory = _require2.LoggerFactory;
var MultiPart = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers-multipart.browser.js");
var dotNotate = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/dot-notate.js");
var logger;
var ContentTransformers = /*#__PURE__*/function () {
  function ContentTransformers() {
    _classCallCheck(this, ContentTransformers);
  }
  _createClass(ContentTransformers, null, [{
    key: "contentTransformers",
    get:
    /**
     * Transformers which serialize / deserialize content that is sent to / received from
     * server using specific MIME type.
     */
    function get() {
      return Object.freeze({
        "application/json": ContentTransformers.Json,
        // "application/json+extended": Json,
        //"application/x-msgpack": MessagePack,
        //"application/msgpack": MessagePack,
        "application/x-www-form-urlencoded": ContentTransformers.Form,
        "multipart/form-data": ContentTransformers.MultiPart
      });
    }
  }, {
    key: "Json",
    get: function get() {
      return {
        serialize: function serialize(value) {
          return Json.stringify(value);
        },
        deserialize: function deserialize(value) {
          return value ? Json.parse(value) : null;
        }
      };
    }
  }, {
    key: "Form",
    get: function get() {
      return {
        serialize: function serialize(value) {
          if (value == null) return value;
          if (typeof value !== "object") {
            ContentTransformers._getLogger().warn("Unrecognized value when serializing as application/x-www-form-urlencoded - passing as-is. Value:", {
              value: value
            });
            return value;
          }
          var result = dotNotate(value);
          return result.map(function (_ref) {
            var key = _ref.key,
              value = _ref.value;
            return value == null ? "" : `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
          }).join("&");
        },
        deserialize: function deserialize(value) {
          if (value == null) return value;
          if (typeof value !== "string") {
            ContentTransformers._getLogger.warn("Unrecognized value when deserializing as application/x-www-form-urlencoded - passing as-is. Value:", {
              value: value
            });
            return value;
          }
          var pairs = value.replace(/\+/g, " ").split("&");
          var result = {};
          for (var i = 0; i < pairs.length; ++i) {
            var pair = pairs[i];
            pair.replace(/^([^=]*)=?(.*)$/, function (m, g1, g2) {
              var dg1 = decodeURIComponent(g1);
              var dg2 = decodeURIComponent(g2);
              if (result.hasOwnProperty(dg1)) {
                if (!Array.isArray(result[dg1])) {
                  result[dg1] = [result[dg1]];
                }
                result[dg1].push(dg2);
              } else {
                result[dg1] = dg2;
              }
            });
          }
          return result;
        }
      };
    }
  }, {
    key: "MultiPart",
    get: function get() {
      return MultiPart;
    }
  }, {
    key: "_getLogger",
    value: function _getLogger() {
      if (!logger) {
        logger = LoggerFactory.get("UuApp.AppClient.Client");
      }
      return logger;
    }
  }, {
    key: "_stringify",
    value: function _stringify(key, value, result, topLevel) {
      if (Array.isArray(value)) {
        value.forEach(function (item, i) {
          return ContentTransformers._stringify(`${key}[${i}]`, item, result, false);
        });
      } else if (value && typeof value === "object") {
        for (var k in value) ContentTransformers._stringify(`${key}${topLevel ? "" : "."}${k}`, value[k], result, false);
      } else {
        result.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
      }
    }
  }]);
  return ContentTransformers;
}();
module.exports = ContentTransformers;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/dot-notate.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
module.exports = function dotNotate(object) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var result = [];
  recurse(parent, object, result, parent ? 1 : 0);
  return result;
};
function recurse(key, value, result, level) {
  if (level > 5) throw new BaseError("Nesting level too deep. Possible circular reference.");
  if (Array.isArray(value)) {
    value.forEach(function (item, i) {
      return recurse(`${key}[${i}]`, item, result, level + 1);
    });
  } else if (value instanceof Date) {
    result.push({
      key,
      value: value.toISOString()
    });
  } else if (value && typeof value === "object") {
    for (var k in value) {
      recurse(`${key}${level ? "." : ""}${k}`, value[k], result, level + 1);
    }
  } else {
    result.push({
      key,
      value
    });
  }
}

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/helpers-make-response.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _objectSpread = (__webpack_require__("../node_modules/@babel/runtime/helpers/objectSpread2.js")["default"]);
var _slicedToArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/slicedToArray.js")["default"]);
var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
function makeResponse(responseInfo, error) {
  var response = responseInfo ? responseInfo.response : null;
  var res = {
    status: response ? response.status : 0,
    headers: function headers(aHeader) {
      if (!aHeader) {
        if (!response) return "";
        var result = [];
        var _iterator = _createForOfIteratorHelper(response.headers),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              k = _step$value[0],
              v = _step$value[1];
            result.push(k + ": " + v);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return result.join("\r\n");
      }
      return response ? response.headers.get(aHeader) : null;
    },
    data: responseInfo && responseInfo.body != null ? responseInfo.body : responseInfo
  };
  if (responseInfo) {
    if (responseInfo.filename !== undefined) {
      res.filename = responseInfo.filename;
      if (res.data) res.data.filename = res.filename;
    }
    if (responseInfo.contentType !== undefined) {
      res.contentType = responseInfo.contentType;
      if (res.data) res.data.contentType = res.contentType;
    }
    if (responseInfo.encoding !== undefined) {
      res.encoding = responseInfo.encoding;
      if (res.data) res.data.encoding = res.encoding;
    }
  }
  return error ? _objectSpread(_objectSpread({}, res), error) : res;
}
module.exports = makeResponse;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var makeResponse = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers-make-response.browser.js");
var Helpers = /*#__PURE__*/function () {
  function Helpers() {
    _classCallCheck(this, Helpers);
  }
  _createClass(Helpers, null, [{
    key: "keysToLowerCase",
    value: function keysToLowerCase(map) {
      if (!map || typeof map !== "object") return null;
      var result = {};
      for (var k in map) {
        result[k.toLowerCase()] = map[k];
      }
      return result;
    }
  }, {
    key: "interceptorMakeResponse",
    value: function interceptorMakeResponse(response, request, extraArgs) {
      var rawResponse = makeResponse(response, request, extraArgs);
      if (typeof window == "undefined") {
        // Allow "flat" access to attributes of dtoOut. See test "response-wrapper.test.js" for details.
        // Downside is that it is not possible to flatly access dtoOut attributes in case they are named
        // "status" or "headers".
        // TODO This is only temporary solution for backward compatibility. In can be dropped once proxy
        // is supported by all browsers (so that new API can be used on backend and frontend for some
        // time before old response object is removed).
        return new Proxy(rawResponse, {
          get(target, prop) {
            var result;
            if (prop === "unwrap") {
              result = function result() {
                return {
                  status: target.status,
                  headers: target.headers,
                  body: target.data
                };
              };
            } else if (prop === "status" || prop === "headers") {
              // TODO Do not print deprecation warning until same API is available on frontend
              // console.warn(`Using deprecated property ${prop} on AppClient result. Use unwrap() to access raw response data.`);
              result = target[prop];
            } else if (prop === "data") {
              var body = target.data;
              if (typeof body == "undefined" || body === null) {
                result = body;
              } else if (body.hasOwnProperty("data")) {
                result = new Proxy(body, {
                  get(target, prop) {
                    var bodyData = target.data;
                    if (prop == "toJSON") {
                      return function () {
                        return target;
                      };
                    } else if (typeof bodyData == "undefined" || bodyData === null) {
                      return target[prop];
                    } else {
                      var _result = bodyData[prop];
                      if (typeof _result === "undefined") {
                        return target[prop];
                      }
                      if (typeof _result === "function") {
                        _result = _result.bind(bodyData);
                      }
                      return _result;
                    }
                  }
                });
              } else {
                // TODO Do not print deprecation warning until same API is available on frontend
                // console.warn(`Using deprecated property ${prop} on AppClient result. Use unwrap() to access raw response data.`);
                result = body;
              }
            } else if (prop == "toJSON") {
              result = function result() {
                return target.data;
              };
            } else {
              var _body = target.data;
              if (typeof _body != "undefined" && _body != null && typeof _body[prop] != "undefined") {
                result = _body[prop];
                if (typeof result === "function") {
                  result = result.bind(_body);
                }
              } else {
                result = target[prop];
              }
            }
            return result;
          },
          ownKeys(target) {
            var body = target.data;
            if (typeof body == "undefined" || body === null) {
              return null;
            } else {
              return Object.keys(body);
            }
          },
          getOwnPropertyDescriptor(target, prop) {
            var body = target.data;
            if (typeof body == "undefined" || body === null) {
              return null;
            } else {
              var descriptor = Object.getOwnPropertyDescriptor(body, prop);
              if (descriptor) {
                descriptor.configurable = true;
              }
              return descriptor;
            }
          },
          has(target, key) {
            var body = target.data;
            if (typeof body == "undefined" || body === null) {
              return false;
            } else {
              return key in body;
            }
          }
        });
      } else {
        // TODO Proxy is not supported by IE
        return rawResponse;
      }
    }
  }, {
    key: "isObject",
    value: function isObject(item) {
      return item && typeof item === 'object' && !Array.isArray(item);
    }
  }, {
    key: "mergeOptions",
    value: function mergeOptions(options, overridingOptions) {
      if (!Helpers.isObject(overridingOptions)) {
        return options;
      }
      Object.keys(overridingOptions).forEach(function (key) {
        if (Helpers.isObject(overridingOptions[key])) {
          if (!(key in options)) {
            options[key] = overridingOptions[key];
          } else {
            options[key] = Helpers.mergeOptions(options[key], overridingOptions[key]);
          }
        } else {
          options[key] = overridingOptions[key];
        }
      });
      return options;
    }
  }]);
  return Helpers;
}();
module.exports = Helpers;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/http-client.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _toConsumableArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/toConsumableArray.js")["default"]);
var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _objectSpread = (__webpack_require__("../node_modules/@babel/runtime/helpers/objectSpread2.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _asyncIterator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncIterator.js")["default"]);
var _awaitAsyncGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js")["default"]);
var _wrapAsyncGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js"),
  LoggerFactory = _require.LoggerFactory;
var _require2 = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  Config = _require2.Config,
  OptsReader = _require2.OptsReader,
  BaseError = _require2.BaseError,
  Json = _require2.Json;
var _require3 = __webpack_require__("../node_modules/uu_appg01_core-authentication/src/index.js"),
  TokenSanitizer = _require3.TokenSanitizer;
var Helpers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js");
var ACCESS_TOKEN_PARAM = "access_token";
var HttpClient = /*#__PURE__*/function () {
  function HttpClient() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, HttpClient);
    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  }

  // function InvokeClient (cmdClient, httpClientOpts, finalRequest, finalOpts) {
  _createClass(HttpClient, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var options,
          opts,
          canHaveBody,
          url,
          body,
          headers,
          timeout,
          usedHeaders,
          k,
          v,
          result,
          responseInfo,
          doFetch,
          response,
          transformResponse,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
              opts = new OptsReader(options, this._options, Config); // TODO Implement abortion support
              // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));
              canHaveBody = request.method.match(/^(put|post)$/i);
              url = request.uri.toString();
              if (!canHaveBody) {
                if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
              } else {
                body = request.body;
              }
              headers = request.headers;
              timeout = opts.getNumber("requestTimeout", 0);
              if (this._logger.isDebugLoggable()) {
                this._logger.debug("Invoking request: " + Json.stringify({
                  method: request.method,
                  url: this._sanitizeQueryParameters(url),
                  headers: this._sanitizeHeaders(_objectSpread({}, headers)),
                  body: this._sanitizeBody(body),
                  requestTimeout: timeout
                }));
              }
              usedHeaders = {};
              _context2.t0 = _regeneratorRuntime().keys(headers);
            case 10:
              if ((_context2.t1 = _context2.t0()).done) {
                _context2.next = 19;
                break;
              }
              k = _context2.t1.value;
              v = headers[k];
              if (!(k && v != null)) {
                _context2.next = 17;
                break;
              }
              if (!(k === "content-type" && body instanceof FormData && v === "multipart/form-data")) {
                _context2.next = 16;
                break;
              }
              return _context2.abrupt("continue", 10);
            case 16:
              usedHeaders[k.replace(/(^|-)./g, function (m) {
                return m.toUpperCase();
              })] = v + "";
            case 17:
              _context2.next = 10;
              break;
            case 19:
              _context2.prev = 19;
              doFetch = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  var requestData, credentialsPolicy;
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        requestData = {
                          method: request.method,
                          headers: usedHeaders,
                          body
                        };
                        credentialsPolicy = opts.getString("credentialsPolicy");
                        if (credentialsPolicy) {
                          requestData.credentials = credentialsPolicy;
                        }
                        _context.next = 5;
                        return fetch(url, requestData);
                      case 5:
                        return _context.abrupt("return", _context.sent);
                      case 6:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function doFetch() {
                  return _ref.apply(this, arguments);
                };
              }();
              if (timeout > 0) doFetch = this._addAsyncFnTimeout(doFetch, timeout * 1000);
              _context2.next = 24;
              return doFetch();
            case 24:
              response = _context2.sent;
              responseInfo = {
                response
              };
              transformResponse = opts.getBoolean("transformResponse", true) === true;
              if (!transformResponse) responseInfo.responseType = "arraybuffer";else Object.assign(responseInfo, this._autodetectBinaryData(response));
              if (opts.getBoolean("enableStreamApi", false) === true && responseInfo.responseType === "arraybuffer") {
                responseInfo.responseType = "stream";
              }

              // status 200 - 5xx
              if (!(responseInfo.responseType === "stream")) {
                _context2.next = 33;
                break;
              }
              responseInfo.body = this._getResponseStream(response);
              _context2.next = 44;
              break;
            case 33:
              if (!(responseInfo.responseType === "arraybuffer")) {
                _context2.next = 41;
                break;
              }
              _context2.t2 = Uint8Array;
              _context2.next = 37;
              return response.arrayBuffer();
            case 37:
              _context2.t3 = _context2.sent;
              responseInfo.body = new _context2.t2(_context2.t3);
              _context2.next = 44;
              break;
            case 41:
              _context2.next = 43;
              return response.text();
            case 43:
              responseInfo.body = _context2.sent;
            case 44:
              if (this._logger.isDebugLoggable()) {
                this._logger.debug("Received response: " + Json.stringify({
                  url: url,
                  status: response.status,
                  data: responseInfo.body
                }));
              }
              result = Helpers.interceptorMakeResponse(responseInfo);
              _context2.next = 51;
              break;
            case 48:
              _context2.prev = 48;
              _context2.t4 = _context2["catch"](19);
              if (_context2.t4.name === "AbortError") {
                // user / developer abort; AbortError
                this._logger.warn("Request has been aborted: " + Json.stringify({
                  url: url
                }), _context2.t4);
                result = Promise.reject(Helpers.interceptorMakeResponse(responseInfo, {
                  error: new BaseError("Request has been aborted - " + url, _context2.t4)
                }));
              } else if (_context2.t4.name === "TimeoutError") {
                // TimeoutError
                this._logger.error("Request timed out: " + Json.stringify({
                  url: url
                }), _context2.t4);
                result = Promise.reject(Helpers.interceptorMakeResponse(responseInfo, {
                  error: new BaseError("Request timed out - " + url, _context2.t4)
                }));
              } else {
                // network / other error
                this._logger.error("Request ended with error: " + Json.stringify({
                  url: url
                }), _context2.t4);
                result = Promise.reject(Helpers.interceptorMakeResponse(responseInfo, {
                  error: new BaseError("Error - " + url, _context2.t4),
                  data: responseInfo ? responseInfo.body : null
                }));
              }
            case 51:
              return _context2.abrupt("return", result);
            case 52:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[19, 48]]);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_addAsyncFnTimeout",
    value: function _addAsyncFnTimeout(runnableFn, timeout) {
      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var timeoutId, timeoutPromise, runnablePromise;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              timeoutPromise = new Promise(function (resolve, reject) {
                return timeoutId = setTimeout(function () {
                  var error = new Error("Timed out.");
                  error.name = "TimeoutError";
                  reject(error);
                }, timeout);
              });
              runnablePromise = runnableFn();
              return _context3.abrupt("return", Promise.race([runnablePromise, timeoutPromise]).finally(function () {
                return clearTimeout(timeoutId);
              }));
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
    }
  }, {
    key: "_autodetectBinaryData",
    value: function _autodetectBinaryData(fetchResponse) {
      function _findMatch(cDisp) {
        var regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
        var match;
        var results = [];
        while ((match = regex.exec(cDisp)) != null) {
          results = results.concat(match.slice(1).filter(function (m) {
            return m;
          }));
        }
        var last = results[results.length - 1];
        return last ? decodeURIComponent(last) : null;
      }
      var cDisp;
      try {
        cDisp = fetchResponse.headers.get("Content-Disposition");
      } catch (e) {
        // do nothing
      }
      if (!cDisp) return;
      var responseInfo = {};
      responseInfo.responseType = "arraybuffer";
      responseInfo.filename = _findMatch(cDisp);
      var cType = fetchResponse.headers.get("Content-Type");
      if (cType) {
        var cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
        responseInfo.contentType = cTypeItems[1] || null;
        responseInfo.encoding = cTypeItems[2] || null;
      }
      return responseInfo;
    }
  }, {
    key: "_getResponseStream",
    value: function _getResponseStream(response) {
      var _this = this;
      var listeners = {};
      var emitEvent = function emitEvent(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var list = listeners[event];
        if (list) {
          var listCopy = _toConsumableArray(list);
          listCopy.forEach(function (listenerFn) {
            try {
              listenerFn.apply(void 0, args);
            } catch (e) {
              _this._logger.error(e);
              // continue with next listener
            }
          });
        }
      };

      var stream = response.body || {}; // we'll return object with on() fn even for browsers not supporting Streams API
      stream.on = function (event, callback) {
        if (!listeners[event]) listeners[event] = [];
        listeners[event].push(callback);
        if (event === "data" || event === "end" || event === "error") startConsumingStream();
      };
      if (!stream[Symbol.asyncIterator]) {
        stream[Symbol.asyncIterator] = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var allData, reader, _yield$_awaitAsyncGen, done, value;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                if (!(typeof ReadableStream === "undefined" || !(stream instanceof ReadableStream))) {
                  _context4.next = 9;
                  break;
                }
                _context4.t0 = Uint8Array;
                _context4.next = 4;
                return _awaitAsyncGenerator(response.arrayBuffer());
              case 4:
                _context4.t1 = _context4.sent;
                allData = new _context4.t0(_context4.t1);
                _context4.next = 8;
                return allData;
              case 8:
                return _context4.abrupt("return");
              case 9:
                reader = stream.getReader();
                _context4.prev = 10;
              case 11:
                if (false) {}
                _context4.next = 14;
                return _awaitAsyncGenerator(reader.read());
              case 14:
                _yield$_awaitAsyncGen = _context4.sent;
                done = _yield$_awaitAsyncGen.done;
                value = _yield$_awaitAsyncGen.value;
                if (!done) {
                  _context4.next = 19;
                  break;
                }
                return _context4.abrupt("break", 23);
              case 19:
                _context4.next = 21;
                return value;
              case 21:
                _context4.next = 11;
                break;
              case 23:
                _context4.prev = 23;
                reader.releaseLock();
                return _context4.finish(23);
              case 26:
              case "end":
                return _context4.stop();
            }
          }, _callee4, null, [[10,, 23, 26]]);
        }));
      }
      var startedConsumingStream = false;
      var startConsumingStream = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                if (!startedConsumingStream) {
                  _context5.next = 2;
                  break;
                }
                return _context5.abrupt("return");
              case 2:
                startedConsumingStream = true;
                _context5.prev = 3;
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context5.prev = 6;
                _iterator = _asyncIterator(stream);
              case 8:
                _context5.next = 10;
                return _iterator.next();
              case 10:
                if (!(_iteratorAbruptCompletion = !(_step = _context5.sent).done)) {
                  _context5.next = 16;
                  break;
                }
                chunk = _step.value;
                emitEvent("data", chunk);
              case 13:
                _iteratorAbruptCompletion = false;
                _context5.next = 8;
                break;
              case 16:
                _context5.next = 22;
                break;
              case 18:
                _context5.prev = 18;
                _context5.t0 = _context5["catch"](6);
                _didIteratorError = true;
                _iteratorError = _context5.t0;
              case 22:
                _context5.prev = 22;
                _context5.prev = 23;
                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                  _context5.next = 27;
                  break;
                }
                _context5.next = 27;
                return _iterator.return();
              case 27:
                _context5.prev = 27;
                if (!_didIteratorError) {
                  _context5.next = 30;
                  break;
                }
                throw _iteratorError;
              case 30:
                return _context5.finish(27);
              case 31:
                return _context5.finish(22);
              case 32:
                emitEvent("end");
                _context5.next = 39;
                break;
              case 35:
                _context5.prev = 35;
                _context5.t1 = _context5["catch"](3);
                if (!listeners["error"]) _this._logger.error(_context5.t1);
                emitEvent("error", _context5.t1);
              case 39:
              case "end":
                return _context5.stop();
            }
          }, _callee5, null, [[3, 35], [6, 18, 22, 32], [23,, 27, 31]]);
        }));
        return function startConsumingStream() {
          return _ref3.apply(this, arguments);
        };
      }();
      return stream;
    }
  }, {
    key: "_sanitizeHeaders",
    value: function _sanitizeHeaders(headers) {
      if (headers.authorization) {
        headers.authorization = TokenSanitizer.processHeader(headers.authorization);
      }
      return headers;
    }
  }, {
    key: "_sanitizeQueryParameters",
    value: function _sanitizeQueryParameters(url) {
      return TokenSanitizer.processUri(url);
    }
  }, {
    key: "_sanitizeBody",
    value: function _sanitizeBody(body) {
      if (typeof body === "string" && body.includes(ACCESS_TOKEN_PARAM)) {
        var parsedBody;
        try {
          parsedBody = Json.parse(body);
        } catch (e) {
          return body;
        }
        if (parsedBody[ACCESS_TOKEN_PARAM]) {
          parsedBody[ACCESS_TOKEN_PARAM] = TokenSanitizer.processToken(parsedBody[ACCESS_TOKEN_PARAM]);
        }
        body = Json.stringify(parsedBody);
      }
      return body;
    }
  }]);
  return HttpClient;
}();
module.exports = HttpClient;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/application-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var RemoteError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/remote-error.js");
var ApplicationError = /*#__PURE__*/function (_RemoteError) {
  _inherits(ApplicationError, _RemoteError);
  var _super = _createSuper(ApplicationError);
  function ApplicationError() {
    var _this;
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, ApplicationError);
    _this = _super.call(this, message, response);
    if (!_this.status) {
      _this.status = 400;
    }
    return _this;
  }
  return _createClass(ApplicationError);
}(RemoteError);
module.exports = ApplicationError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/invalid-options-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var InvalidOptions = /*#__PURE__*/function (_BaseError) {
  _inherits(InvalidOptions, _BaseError);
  var _super = _createSuper(InvalidOptions);
  function InvalidOptions(message, cause) {
    var _this;
    _classCallCheck(this, InvalidOptions);
    _this = _super.call(this, message || "Invalid parameters", cause);
    _this.code = `uu-app-core-appclient/InvalidParameters`;
    return _this;
  }
  return _createClass(InvalidOptions);
}(BaseError);
module.exports = InvalidOptions;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/remote-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _possibleConstructorReturn = (__webpack_require__("../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError,
  Json = _require.Json;
var RemoteError = /*#__PURE__*/function (_BaseError) {
  _inherits(RemoteError, _BaseError);
  var _super = _createSuper(RemoteError);
  function RemoteError() {
    var _this;
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, RemoteError);
    var errorInitialized = false;
    if (typeof message === "string") {
      _this = _super.call(this, message);
      _this.paramMap = {};
      _this.dtoOut = {};
      errorInitialized = true;
    } else if (message.uuAppErrorMap) {
      var keys = Object.keys(message.uuAppErrorMap);
      if (keys.length > 0) {
        var _iterator = _createForOfIteratorHelper(keys),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            var error = message.uuAppErrorMap[key];
            if (error.type === "error") {
              _this = _super.call(this, error.message);
              _this.code = key;
              if (error.id) {
                _this.id = error.id;
              }
              _this.paramMap = error.paramMap;
              _this.dtoOut = message;
              if (error.cause && error.cause.uuAppErrorMap) {
                _this.cause = new RemoteError(error.cause);
              }
              errorInitialized = true;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    if (!errorInitialized) {
      _this = _super.call(this, Json.stringify(message));
      _this.paramMap = {};
      _this.dtoOut = {};
    }
    if (response) {
      _this.response = response;
      _this.status = response.status;
    }
    return _possibleConstructorReturn(_this);
  }
  return _createClass(RemoteError);
}(BaseError);
module.exports = RemoteError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/system-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var RemoteError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/remote-error.js");
var SystemError = /*#__PURE__*/function (_RemoteError) {
  _inherits(SystemError, _RemoteError);
  var _super = _createSuper(SystemError);
  function SystemError() {
    var _this;
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, SystemError);
    _this = _super.call(this, message, response);
    if (!_this.status) {
      _this.status = 500;
    }
    return _this;
  }
  return _createClass(SystemError);
}(RemoteError);
module.exports = SystemError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  get AppClient() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/client.js");
  },
  get RemoteError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/remote-error.js");
  },
  get ApplicationError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/application-error.js");
  },
  get SystemError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/system-error.js");
  },
  get InvalidOptionsError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/invalid-options-error.js");
  },
  get PerflogHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/perflog-handler.js");
  },
  get RemoteErrorHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/remote-error-handler.js");
  },
  get SessionHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/session-handler.js");
  },
  get TransformParametersHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/transform-parameters-handler.browser.js");
  },
  get UriHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/uri-handler.js");
  },
  get CsrfTokenHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/csrf-token-handler.browser.js");
  },
  get RetryHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler.browser.js");
  }
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/csrf-token-handler.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
var BASE_ELEMENT = WINDOW.document.querySelector("base");
var APP_BASE_URI = WINDOW.location.protocol + "//" + WINDOW.location.host + (BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "" || "/");
var CANONICAL_APP_BASE_URI = (new RegExp("uu.app.cbu=([^;]+)").exec(WINDOW.document.cookie) || [])[1];
var CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");
var CSRF_HEADER = "x-csrf-token";

/**
 * Interceptor to inject csrf token to request headers.
 */
var CsrfTokenHandler = /*#__PURE__*/function () {
  function CsrfTokenHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, CsrfTokenHandler);
    this._next = next;
    this._options = options || {};
    this._appBaseUri = APP_BASE_URI.replace(/\/$/, "");
    this._canonicalAppBaseUri = CANONICAL_APP_BASE_URI && CANONICAL_APP_BASE_URI.replace(/\/$/, "");
  }
  _createClass(CsrfTokenHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var options,
          csrfToken,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
              if (csrfToken && (request.uri.startsWith(this._appBaseUri) || request.uri.startsWith(this._canonicalAppBaseUri))) {
                request.headers[CSRF_HEADER] = csrfToken;
              }
              return _context.abrupt("return", this._next.invoke(request, options));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }]);
  return CsrfTokenHandler;
}();
module.exports = CsrfTokenHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/perflog-handler.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-perflog/src/index.browser.js"),
  Perflog = _require.Perflog;
var _require2 = __webpack_require__("../node_modules/uu_appg01_core-authentication/src/index.js"),
  TokenSanitizer = _require2.TokenSanitizer;

/**
 * Interceptor for performance logging.
 */
var PerfLogHandler = /*#__PURE__*/function () {
  function PerfLogHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, PerfLogHandler);
    this._next = next;
  }
  _createClass(PerfLogHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _this = this;
        var options,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                Perflog.measureSection("UU_APP_CLIENT_REQUEST", /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(section) {
                    var uri;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          request.headers["x-request-id"] = section.getId().toString();
                          uri = TokenSanitizer.processUri(request.uri.toString());
                          section.setAttribute("uri", uri);
                          _context.prev = 3;
                          _context.t0 = resolve;
                          _context.next = 7;
                          return _this._next.invoke(request, options);
                        case 7:
                          _context.t1 = _context.sent;
                          (0, _context.t0)(_context.t1);
                          _context.next = 14;
                          break;
                        case 11:
                          _context.prev = 11;
                          _context.t2 = _context["catch"](3);
                          reject(_context.t2);
                        case 14:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee, null, [[3, 11]]);
                  }));
                  return function (_x2) {
                    return _ref.apply(this, arguments);
                  };
                }());
              }));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }]);
  return PerfLogHandler;
}();
module.exports = PerfLogHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/remote-error-handler.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var ApplicationError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/application-error.js");
var SystemError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/system-error.js");
var _require = __webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js"),
  LoggerFactory = _require.LoggerFactory;

/**
 * Interceptor for extracting error information from response.
 */
var RemoteErrorHandler = /*#__PURE__*/function () {
  function RemoteErrorHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, RemoteErrorHandler);
    this._next = next;
    this._logger = LoggerFactory.get("UuApp.AppClient.Interceptor.RemoteErrorHandler");
  }
  _createClass(RemoteErrorHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var options,
          response,
          errorData,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              _context.next = 3;
              return this._next.invoke(request, options);
            case 3:
              response = _context.sent;
              if (response.status < 400) {
                this._logger.info(`Request ${request.uri} ended with status code: ${response.status}`);
              }
              if (!(response.status >= 400)) {
                _context.next = 14;
                break;
              }
              errorData = response.data || {};
              if (!(response.status < 500)) {
                _context.next = 12;
                break;
              }
              this._logger.warn(`Request ${request.uri} ended with status code: ${response.status}${this._addUuAppErrorMap(response)}`);
              throw new ApplicationError(errorData, response);
            case 12:
              this._logger.error(`Request ${request.uri} failed with status code: ${response.status}${this._addUuAppErrorMap(response)}`);
              throw new SystemError(errorData, response);
            case 14:
              return _context.abrupt("return", response);
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_addUuAppErrorMap",
    value: function _addUuAppErrorMap(response) {
      if (!response.data.uuAppErrorMap) {
        return "";
      }
      var errorCode = Object.keys(response.data.uuAppErrorMap)[0];
      var foundError = response.data.uuAppErrorMap[errorCode];
      var optionalMessage = `, uuAppErrorMap code: ${errorCode}, message: ${foundError.message}`;
      if (foundError.paramMap) {
        optionalMessage += `, paramMap: ${JSON.stringify(foundError.paramMap)}`;
      }
      return optionalMessage;
    }
  }]);
  return RemoteErrorHandler;
}();
module.exports = RemoteErrorHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler-core.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _slicedToArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/slicedToArray.js")["default"]);
var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Helpers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js");
var InvalidParameters = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/invalid-options-error.js");
var _require = __webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js"),
  LoggerFactory = _require.LoggerFactory;
var _require2 = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  Json = _require2.Json;

/**
 * Core Interceptor for retry policy  working. Should be extended by retry and retry browser interceptor to avoid code duplication
 */
var RetryHandlerCore = /*#__PURE__*/function () {
  function RetryHandlerCore(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, RetryHandlerCore);
    this._next = next;
    this._validateOptions(options);
    this._options = options.retryPolicy;
    this._attempt = 0;
    this._originalRequestId = null;
    this._logger = LoggerFactory.get("UuApp.AppClient.Interceptor.RetryHandler");
  }
  _createClass(RetryHandlerCore, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var options,
          response,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              _context.prev = 1;
              _context.next = 4;
              return this._next.invoke(request, options);
            case 4:
              response = _context.sent;
              _context.next = 14;
              break;
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              if (!(_context.t0.cause && _context.t0.cause.code === "ENOTFOUND")) {
                _context.next = 13;
                break;
              }
              _context.next = 12;
              return this._processRetryPolicyForClientErrors(request, options, _context.t0);
            case 12:
              return _context.abrupt("return", _context.sent);
            case 13:
              throw _context.t0;
            case 14:
              if (options != null) {
                this._options = Helpers.mergeOptions(this._options, options.retryPolicy);
              }
              this._originalRequestId = request.headers["x-request-id"];
              if (this._shouldRetry(request, response, this._options)) {
                _context.next = 18;
                break;
              }
              return _context.abrupt("return", response);
            case 18:
              if (!(request.headers["content-type"] && (request.headers["content-type"].startsWith("multipart/form-data") || request.headers["content-type"].startsWith("application/octet-stream")) && this._containStream(request.body))) {
                _context.next = 21;
                break;
              }
              this._logger.debug(`Request failed and wont be repeated as it contains binary stream. requestId=${this._originalRequestId}`);
              return _context.abrupt("return", response);
            case 21:
              _context.next = 23;
              return this._processRetryPolicy(request, response, options);
            case 23:
              response = _context.sent;
              return _context.abrupt("return", response);
            case 25:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 7]]);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_processRetryPolicy",
    value: function () {
      var _processRetryPolicy2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, response, options) {
        var retryAfter, retryAfterHeader, sleepTime;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              retryAfter = false;
              this._attempt++;
              if (this._shouldRetry(request, response, this._options)) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", response);
            case 4:
              if (response.status === 503) {
                retryAfterHeader = this._parseHeaders(response.headers())["retry-after"];
                if (retryAfterHeader) {
                  retryAfter = this._getRetryAfterFromHeader(retryAfterHeader);
                }
              }
              if (!(retryAfter && retryAfter > this._options.maxTimeInterval)) {
                _context2.next = 8;
                break;
              }
              this._logger.debug(`Request wont be repeated. Response retry-after header is after max time interval. requestId=${this._originalRequestId}, retryAfter=${retryAfter}, maxTimeInterval=${this._options.maxTimeInterval}`);
              return _context2.abrupt("return", response);
            case 8:
              request.headers["x-request-id"] = `${this._originalRequestId}-${this._attempt.toString().padStart(3, "0")}`;
              if (!retryAfter) {
                sleepTime = this._getRandomIntInclusive(0, Math.min(this._options.maxTimeInterval, this._options.baseTimeInterval * Math.pow(2, this._attempt)));
              }
              this._logger.error(`Request failed. Retry conditions valid, retrying the request in ${sleepTime}ms. originalRequestId=${this._originalRequestId}, originalResponseStatus=${response.status}, requestUri=${request.uri.toString()}, originalResponseData=${Json.stringify(response.data)}, attempt=${this._attempt}, retryPolicy=${Json.stringify(this._options)}`);
              _context2.next = 13;
              return this._timeout(sleepTime);
            case 13:
              _context2.next = 15;
              return this._next.invoke(request, options);
            case 15:
              response = _context2.sent;
              _context2.next = 18;
              return this._processRetryPolicy(request, response, options);
            case 18:
              return _context2.abrupt("return", _context2.sent);
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _processRetryPolicy(_x2, _x3, _x4) {
        return _processRetryPolicy2.apply(this, arguments);
      }
      return _processRetryPolicy;
    }()
  }, {
    key: "_processRetryPolicyForClientErrors",
    value: function () {
      var _processRetryPolicyForClientErrors2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request, options, exception) {
        var sleepTime, response;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              this._attempt++;
              if (!(options == null || options.maxAttempts < 1 || this._attempt > this._options.maxAttempts)) {
                _context3.next = 3;
                break;
              }
              throw exception;
            case 3:
              sleepTime = this._getRandomIntInclusive(0, Math.min(this._options.maxTimeInterval, this._options.baseTimeInterval * Math.pow(2, this._attempt)));
              this._logger.error(`Request failed. Retry conditions valid, retrying the request in ${sleepTime}ms. originalRequestId=${this._originalRequestId}, attempt=${this._attempt}, retryPolicy=${Json.stringify(this._options)}`);
              _context3.next = 7;
              return this._timeout(sleepTime);
            case 7:
              _context3.prev = 7;
              _context3.next = 10;
              return this._next.invoke(request, options);
            case 10:
              response = _context3.sent;
              return _context3.abrupt("return", response);
            case 14:
              _context3.prev = 14;
              _context3.t0 = _context3["catch"](7);
              _context3.next = 18;
              return this._processRetryPolicyForClientErrors(request, options, _context3.t0);
            case 18:
              return _context3.abrupt("return", _context3.sent);
            case 19:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[7, 14]]);
      }));
      function _processRetryPolicyForClientErrors(_x5, _x6, _x7) {
        return _processRetryPolicyForClientErrors2.apply(this, arguments);
      }
      return _processRetryPolicyForClientErrors;
    }()
  }, {
    key: "_timeout",
    value: function () {
      var _timeout2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ms) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", new Promise(function (resolve) {
                return setTimeout(resolve, ms);
              }));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function _timeout(_x8) {
        return _timeout2.apply(this, arguments);
      }
      return _timeout;
    }()
  }, {
    key: "_parseHeaders",
    value: function _parseHeaders(rawHeaders) {
      var parsedHeaders = {};
      rawHeaders.split("\n").forEach(function (header) {
        var _header$split = header.split(/\s*:\s/),
          _header$split2 = _slicedToArray(_header$split, 2),
          key = _header$split2[0],
          value = _header$split2[1];
        parsedHeaders[key] = value;
      });
      return parsedHeaders;
    }
  }, {
    key: "_getRetryAfterFromHeader",
    value: function _getRetryAfterFromHeader(retryAfter) {
      if (!retryAfter) {
        return false;
      }
      if (!isNaN(retryAfter)) {
        return parseInt(retryAfter) * 1000;
      }
      var retryDateTimestamp = Date.parse(retryAfter);
      if (isNaN(retryDateTimestamp)) {
        return false;
      }
      var diff = retryDateTimestamp - Date.now();
      if (diff <= 0) {
        return false;
      }
      return diff;
    }
  }, {
    key: "_getRandomIntInclusive",
    value: function _getRandomIntInclusive(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
  }, {
    key: "_shouldRetry",
    value: function _shouldRetry(request, response, options) {
      // Check maxAttempts
      if (options.maxAttempts < 1) {
        return false;
      }
      if (this._attempt > this._options.maxAttempts) {
        this._logger.debug(`Request wont be repeated. Max attempts exceeded. requestId=${this._originalRequestId}, requestAttempt=${this._attempt}, maxAttempts=${this._options.maxAttempts}`);
        return false;
      }

      // Check http methods
      if (!this._checkHttpMethod(this._options.retryCondition.httpMethods, request.method)) {
        this._logger.debug(`Request wont be repeated. Http method condition invalid. requestId=${this._originalRequestId}, requestHttpMethod=${request.method}, retryHttpMethods=${this._options.retryCondition.httpMethods}`);
        return false;
      }

      // Check httpStatuses
      if (!this._options.retryCondition.httpStatusCodes || !this._checkStatusCode(this._options.retryCondition.httpStatusCodes, response.status.toString())) {
        this._logger.debug(`Request wont be repeated. Http status condition invalid. requestId=${this._originalRequestId}, responseHttpStatus=${response.status.toString()}, retryHttpStatus=${this._options.retryCondition.httpStatusCodes}`);
        return false;
      }
      return true;
    }
  }, {
    key: "_checkHttpMethod",
    value: function _checkHttpMethod() {
      var requiredHttpMethods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var method = arguments.length > 1 ? arguments[1] : undefined;
      if (requiredHttpMethods.length < 1) {
        return false;
      }
      var normalizedMethod = method.toUpperCase();
      if (requiredHttpMethods.includes(normalizedMethod)) {
        return true;
      }
      return false;
    }
  }, {
    key: "_checkStatusCode",
    value: function _checkStatusCode() {
      var requiredStatuses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var status = arguments.length > 1 ? arguments[1] : undefined;
      var checkStatusRegex = new RegExp("[0-9]([0-9]|x){2}");
      var replacerRegex = new RegExp("x", "g");
      if (requiredStatuses.length < 1) {
        return false;
      }
      if (!status) {
        return false;
      }
      if (typeof status !== "string" || !status.match(checkStatusRegex)) {
        return false;
      }
      var _iterator = _createForOfIteratorHelper(requiredStatuses),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var requiredStatus = _step.value;
          var compareRegex = new RegExp(requiredStatus.replace(replacerRegex, "[0-9]"));
          if (status.match(compareRegex)) {
            return true;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return false;
    }

    /* According to requirements body should be checked to avoid retry with streams inside body.
    * There are use-cases when body is stream by itself so we cannot retry it:
     * 1) Sending stream data with application/octet-stream header
    * 2) Sending FormData (or another data that will be converted to FormData by content transformers)
    *
    * In the second case if body is FormData we should check if it contains data that have streams, but in current
    * implementation it is not possible as after failure request data is not accessible. Also FormData have not entries method
    * to access data and the only way to do this is to use "_streams" private parameter that is not safety;
    *
    * As FormData is stream itself all requests with FormData body will not retry.
    * TODO The check might be improved in further implementation by rebuilding FormData one more time if it does not contain stream inside.
    */
  }, {
    key: "_containStream",
    value: function _containStream() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (this._isStream(body)) {
        return true;
      }
      return false;
    }
  }, {
    key: "_isStream",
    value: function _isStream(value) {
      // overridden by subclasses
      return false;
    }
  }, {
    key: "_validateOptions",
    value: function _validateOptions(options) {
      if (!options) {
        throw new InvalidParameters("Options are required in RetryHandler");
      }
      if (typeof options !== "object") {
        throw new InvalidParameters("Options must be object");
      }
      if (!options.retryPolicy) {
        throw new InvalidParameters("Options.retryPolicy is required");
      }
      if (typeof options.retryPolicy !== "object") {
        throw new InvalidParameters("Options.retryPolicy must be object");
      }
      if (!options.retryPolicy.maxTimeInterval) {
        throw new InvalidParameters("Options.retryPolicy.maxTimeInterval is required");
      }
      if (typeof options.retryPolicy.maxTimeInterval !== "number" || options.retryPolicy.maxTimeInterval < 0) {
        throw new InvalidParameters("Options.retryPolicy.maxTimeInterval must be positive integer");
      }
      if (!options.retryPolicy.baseTimeInterval) {
        throw new InvalidParameters("Options.retryPolicy.baseTimeInterval is required");
      }
      if (typeof options.retryPolicy.baseTimeInterval !== "number" || options.retryPolicy.baseTimeInterval < 0) {
        throw new InvalidParameters("Options.retryPolicy.baseTimeInterval must be positive integer");
      }
      if (options.retryPolicy.maxAttempts == null) {
        throw new InvalidParameters("Options.retryPolicy.maxAttempts is required");
      }
      if (typeof options.retryPolicy.maxAttempts !== "number" || options.retryPolicy.maxAttempts < 0) {
        throw new InvalidParameters("Options.retryPolicy.maxAttempts must be positive integer");
      }
      if (!options.retryPolicy.retryCondition) {
        throw new InvalidParameters("Options.retryPolicy.retryCondition is required");
      }
      if (typeof options.retryPolicy.retryCondition !== "object") {
        throw new InvalidParameters("Options.retryPolicy.retryCondition must be object");
      }
      if (!options.retryPolicy.retryCondition.httpMethods) {
        throw new InvalidParameters("Options.retryPolicy.retryCondition.httpMethods is required");
      }
      if (!Array.isArray(options.retryPolicy.retryCondition.httpMethods)) {
        throw new InvalidParameters("Options.retryPolicy.retryCondition.httpMethods must be array");
      }
      options.retryPolicy.retryCondition.httpMethods.forEach(function (method) {
        var availableMethods = ["GET", "POST", "HEAD", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"];
        if (!availableMethods.includes(method)) {
          throw new InvalidParameters(`Incorect httpMethod - ${method} in retryCondition.httpMethods list. Should be one of ${Json.stringify(availableMethods)}`);
        }
      });
      if (!options.retryPolicy.retryCondition.httpStatusCodes) {
        throw new InvalidParameters("Options.retryPolicy.retryCondition.httpStatusCodes is required");
      }
      if (!Array.isArray(options.retryPolicy.retryCondition.httpStatusCodes)) {
        throw new InvalidParameters("Options.retryPolicy.retryCondition.httpStatusCodes must be array");
      }
      options.retryPolicy.retryCondition.httpStatusCodes.forEach(function (method) {
        var pattern = "[0-9]([0-9]|x){2}";
        var checkStatusRegex = new RegExp(pattern);
        if (typeof method !== "string") {
          throw new InvalidParameters("HttpStatusCode in retryCondition.httpStatusCodes list must be string");
        }
        if (!method.match(checkStatusRegex)) {
          throw new InvalidParameters(`HttpStatusCode in retryCondition.httpStatusCodes must meet regex pattern ${pattern}`);
        }
      });
      return true;
    }
  }]);
  return RetryHandlerCore;
}();
module.exports = RetryHandlerCore;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _slicedToArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/slicedToArray.js")["default"]);
var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var RetryHandlerCore = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler-core.js");

/**
 * Interceptor for retry policy working.
 */
var RetryHandler = /*#__PURE__*/function (_RetryHandlerCore) {
  _inherits(RetryHandler, _RetryHandlerCore);
  var _super = _createSuper(RetryHandler);
  function RetryHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, RetryHandler);
    return _super.call(this, next, options);
  }
  _createClass(RetryHandler, [{
    key: "_containStream",
    value: function _containStream() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (body instanceof FormData) {
        return this._isStreamInFormData(body);
      }
      return !!this._isStream(body);
    }
  }, {
    key: "_isStreamInFormData",
    value: function _isStreamInFormData(formData) {
      if (formData == null || !(formData instanceof FormData)) {
        return false;
      }
      var entries = formData.entries();
      if (typeof entries[Symbol.iterator] !== "function") {
        return false;
      }
      var _iterator = _createForOfIteratorHelper(entries),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var data = _step.value;
          var _data = _slicedToArray(data, 2),
            value = _data[1];
          if (value instanceof Blob) {
            return true;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return false;
    }
  }, {
    key: "_isStream",
    value: function _isStream(value) {
      return value instanceof Blob;
    }
  }]);
  return RetryHandler;
}(RetryHandlerCore);
module.exports = RetryHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/session-handler.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/**
 * Interceptor for Client which authenticates command calls by using token from session object.
 *
 * Interceptor is skipped if there's request header "authorization" set for the command call, even
 * if the header value is null.
 */
var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var SessionHandler = /*#__PURE__*/function () {
  function SessionHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, SessionHandler);
    this._next = next;
    this._options = options || {};
  }
  _createClass(SessionHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var options,
          hasCustomAuthn,
          opts,
          session,
          scope,
          callToken,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              hasCustomAuthn = "authorization" in request.headers;
              if (!hasCustomAuthn) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", this._next.invoke(request, options));
            case 4:
              opts = Object.assign(this._options, options);
              session = opts.session;
              if (!session) {
                _context.next = 19;
                break;
              }
              scope = null;
              if (!(typeof session.getCallTokenScope === "function")) {
                _context.next = 14;
                break;
              }
              _context.next = 11;
              return session.getCallTokenScope(request.uri, opts);
            case 11:
              scope = _context.sent;
              _context.next = 15;
              break;
            case 14:
              scope = request.uri.toString().split("?")[0];
            case 15:
              _context.next = 17;
              return session.getCallToken(scope, opts);
            case 17:
              callToken = _context.sent;
              if (callToken) {
                request.headers["authorization"] = callToken;
              }
            case 19:
              return _context.abrupt("return", this._next.invoke(request, options));
            case 20:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }]);
  return SessionHandler;
}();
module.exports = SessionHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/transform-parameters-handler.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var ContentTransformers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers.js");
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  Config = _require.Config,
  OptsReader = _require.OptsReader,
  BaseError = _require.BaseError,
  Json = _require.Json;

/**
 * Interceptor for transforming request parameters / response entity according to the Content Type.
 * Recognized options:
 *
 * - transformParameters {boolean} - whether to transform (serialize by Content-Type) request body
 * - transformResponse {boolean} - whether to transform (deserialize by Content-Type) response body
 * - wrapQuery {boolean} - whether to wrap request body with { dto: ... }
 */
var TransformParametersHandler = /*#__PURE__*/function () {
  function TransformParametersHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, TransformParametersHandler);
    this._next = next;
    this._options = options;
  }
  _createClass(TransformParametersHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var options,
          opts,
          paramsInBody,
          contentTransformers,
          contentType,
          isMultipartPreferred,
          contentHandler,
          response,
          respContentDisposition,
          respContentType,
          _contentHandler,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              opts = new OptsReader(options, this._options, Config); // add default Content-Type & Accept headers
              paramsInBody = request.method.match(/^(put|post)$/i);
              contentTransformers = ContentTransformers.contentTransformers || {};
              contentType = paramsInBody ? request.headers["content-type"] : null;
              if (!("content-type" in request.headers)) {
                if (paramsInBody) {
                  isMultipartPreferred = request.body != null && (request.body instanceof FormData || request.body instanceof Blob || typeof request.body == "object" && Object.keys(request.body).some(function (it) {
                    return request.body[it] instanceof Blob;
                  }));
                  contentType = isMultipartPreferred ? "multipart/form-data" : "application/json; charset=utf-8";
                  request.headers["content-type"] = contentType;
                } else {
                  contentType = "application/x-www-form-urlencoded";
                }
              }
              if (!("accept" in request.headers)) request.headers["accept"] = "application/json";

              // wrap request data into "dto" parameter if requested to do so
              if (opts.getBoolean("transformParameters") !== false && !paramsInBody && request.body != null && opts.getBoolean("wrapQuery") && contentType === "application/x-www-form-urlencoded") {
                request.body = {
                  dto: Json.stringify(request.body)
                };
              }

              // transform request data
              if (!(opts.getBoolean("transformParameters") !== false && request.body != null)) {
                _context.next = 17;
                break;
              }
              contentHandler = contentTransformers[this._getMimeMainType(contentType)];
              _context.prev = 10;
              if (contentHandler) request.body = contentHandler.serialize(request.body);
              _context.next = 17;
              break;
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](10);
              throw new BaseError("Error while serializing data.", _context.t0);
            case 17:
              _context.next = 19;
              return this._next.invoke(request, options);
            case 19:
              response = _context.sent;
              respContentDisposition = response.headers("content-disposition");
              if (!(opts.getBoolean("transformResponse") !== false && !respContentDisposition)) {
                _context.next = 31;
                break;
              }
              respContentType = response.headers("content-type");
              _contentHandler = contentTransformers[this._getMimeMainType(respContentType)];
              _context.prev = 24;
              if (response.status === 204) response.data = null;else if (_contentHandler) response.data = _contentHandler.deserialize(response.data);
              _context.next = 31;
              break;
            case 28:
              _context.prev = 28;
              _context.t1 = _context["catch"](24);
              throw new BaseError("Error while deserializing response data.", _context.t1);
            case 31:
              return _context.abrupt("return", response);
            case 32:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[10, 14], [24, 28]]);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }, {
    key: "_getMimeMainType",
    value: function _getMimeMainType(mimeType) {
      return (mimeType || "").replace(/[+;].*/, "").trim();
    }
  }]);
  return TransformParametersHandler;
}();
module.exports = TransformParametersHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/uri-handler.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  Config = _require.Config,
  OptsReader = _require.OptsReader;

/**
 * Interceptor for finalizing uuUri URL in case it's incomplete (missing gateway).
 */
var UriHandler = /*#__PURE__*/function () {
  function UriHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, UriHandler);
    this._next = next;
    this._options = options;
  }
  _createClass(UriHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var options,
          uri,
          ucUri,
          opts,
          baseUri,
          gatewayUri,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              uri = "";
              ucUri = (request.uri || "").toString();
              if (!ucUri.match(/^https?:/i)) {
                opts = new OptsReader(options, this._options);
                baseUri = opts.getString("baseUri");
                if (!baseUri || !baseUri.match(/^https?:/i)) {
                  opts = new OptsReader(options, this._options, Config);
                  gatewayUri = opts.getString("gatewayUri", "https://uuappg01.plus4u.net");
                  uri += `${gatewayUri.replace(/\/$/, "")}/`;
                }
                if (baseUri) {
                  uri += `${baseUri.replace(/^\/|\/$/g, "")}/`;
                }
                uri += ucUri.replace(/^\//, "");
              } else {
                uri += ucUri;
              }
              request.uri = uri;
              return _context.abrupt("return", this._next.invoke(request, options));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }
      return invoke;
    }()
  }]);
  return UriHandler;
}();
module.exports = UriHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/application-identity.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/**
 * The identity of an application.
 * @deprecated Use ClientIdentity
 */
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var ApplicationIdentity = /*#__PURE__*/function () {
  /**
   * Creates new instance of application identity.
   * @param {String} uuIdentity Unique identifier of the client application
   * @param {Object} data Additional identity data.
   * @param {String} data.name Name of the application
   * @param {String} data.code Code of the application
   * @private
   */
  function ApplicationIdentity(uuIdentity) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, ApplicationIdentity);
    if (typeof data === "string") {
      this._code = uuIdentity;
      this._name = data;
    } else if (data) {
      this._uuIdentity = uuIdentity;
      this._code = data.code;
      this._name = data.name;
    }
  }

  /**
   * Returns unique identifier of the client application.
   * @returns {String|null} Unique identifier of the client application
   */
  _createClass(ApplicationIdentity, [{
    key: "getUuIdentity",
    value: function getUuIdentity() {
      return this._uuIdentity;
    }

    /**
     * Returns unique identifier of the application.
     * @returns {String} String representation of the unique identifier
     */
  }, {
    key: "getCode",
    value: function getCode() {
      return this._code;
    }

    /**
     * Returns name of the application.
     * @returns {String|null} Name of the application
     */
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }]);
  return ApplicationIdentity;
}();
module.exports = ApplicationIdentity;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/authentication-service.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError,
  Config = _require.Config;
var DEFAULT_PROVIDER_PARAM = "uu_app_default_authn_provider";

/**
 * Component encapsulating authentication process.
 */
var AuthenticationService = /*#__PURE__*/function () {
  function AuthenticationService() {
    _classCallCheck(this, AuthenticationService);
  }
  _createClass(AuthenticationService, null, [{
    key: "DEFAULT_PROVIDER_PARAM",
    get:
    /**
     * @returns {string} Name of configuration parameter for accessing default realization of authentication service.
     */
    function get() {
      return DEFAULT_PROVIDER_PARAM;
    }

    /**
     * Authenticates user.
     * @param {*} credentials User credentials to be verified
     * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
     * @param {Object|null} opts Authentication options.
     * @returns {Promise<Session>} User session for passed user credentials.
     * @throws {InvalidCredentials} In case credentials are not valid.
     * @throws {AuthenticationError} In case authentication fails.
     */
  }, {
    key: "authenticate",
    value: function () {
      var _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(credentials) {
        var scope,
          opts,
          realization,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              scope = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              realization = AuthenticationService.get();
              _context.next = 5;
              return realization.authenticate(credentials, scope, opts);
            case 5:
              return _context.abrupt("return", _context.sent);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function authenticate(_x) {
        return _authenticate.apply(this, arguments);
      }
      return authenticate;
    }()
    /**
     * Authenticates system identity.
     * Awid system identity is used if called within awid context, otherwise asid system identity is used.
     * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
     * @param {Object|null} opts Authentication options.
     * @returns {Promise<Session>} System identity session for asid or awid resolved from the request context.
     * @throws {InvalidCredentials} In case credentials are not valid.
     * @throws {AuthenticationError} In case authentication fails.
     */
  }, {
    key: "authenticateSystemIdentity",
    value: function () {
      var _authenticateSystemIdentity = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var scope,
          opts,
          realization,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              scope = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
              opts = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              realization = AuthenticationService.get();
              _context2.next = 5;
              return realization.authenticateSystemIdentity(scope, opts);
            case 5:
              return _context2.abrupt("return", _context2.sent);
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function authenticateSystemIdentity() {
        return _authenticateSystemIdentity.apply(this, arguments);
      }
      return authenticateSystemIdentity;
    }()
    /**
     * Returns particular realization of authentication service.
     * @param {String} realizationName Name of required authentication service realization
     * @returns {*} Object responding to "authenticate" method
     * @throws {BaseError} In case realization with given name does not exist
     */
  }, {
    key: "get",
    value: function get() {
      var realizationName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var name = realizationName || Config.get(DEFAULT_PROVIDER_PARAM);
      if (!name) {
        throw new BaseError(`Unable to get default authentication provider. Configuration parameter ${DEFAULT_PROVIDER_PARAM} is not set.`);
      }
      var realization = AuthenticationService._realizations[name];
      if (realization) {
        return realization;
      } else {
        throw new BaseError(`There is no authentication provider with name "${name}".`);
      }
    }

    /**
     * Registers custom realization of authentication service.
     * @param {String} realizationName Custom authentication service realization name
     * @param {*} realization Object responding to "authenticate" method
     * @private
     */
  }, {
    key: "_register",
    value: function _register(realizationName, realization) {
      AuthenticationService._realizations[realizationName] = realization;
    }
  }]);
  return AuthenticationService;
}();
AuthenticationService._realizations = {};
module.exports = AuthenticationService;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/client-identity.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/**
 * The identity of a client application.
 */
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var ClientIdentity = /*#__PURE__*/function () {
  /**
   * Creates new instance of client application identity.
   * @param {String} uuIdentity Unique identifier of the client application
   * @param {Object} data Additional identity data.
   * @param {String} data.uri Registered URI of client application
   * @param {String} data.product Client application product
   * @param {String} data.vendor Client application vendor
   * @param {String} data.app Client application name
   * @param {String} data.subApp Client application subapp
   * @param {String} data.asid Client application asid
   * @param {String} data.awid Client application awid
   * @param {String} data.type Type of the client identity
   * @param {String} data.authenticationLevelOfAssurance String representation of the means of client identity authentication
   * @param {UuAppKey} data.uuAppKey uuAppKey representing the system identity. Set only if the identity type is system identity.
   *
   * @private
   */
  function ClientIdentity(uuIdentity) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, ClientIdentity);
    this._uuIdentity = uuIdentity;
    if (data) {
      this._uri = data.uri;
      this._product = data.product;
      this._vendor = data.vendor;
      this._app = data.app;
      this._subApp = data.subApp;
      this._asid = data.asid;
      this._awid = data.awid;
      this._type = data.type;
      this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance;
      this._uuAppKey = data.uuAppKey;
    }
  }

  /**
   * Returns unique identifier of the client application.
   * @returns {String|null} Unique identifier of the client application
   */
  _createClass(ClientIdentity, [{
    key: "getUuIdentity",
    value: function getUuIdentity() {
      return this._uuIdentity;
    }

    /**
     * Returns registered URI of client application.
     * @returns {String|null} Registered URI of client application
     */
  }, {
    key: "getUri",
    value: function getUri() {
      return this._uri;
    }

    /**
     * Returns client application product.
     * @returns {String|null} Client application product
     */
  }, {
    key: "getProduct",
    value: function getProduct() {
      return this._product;
    }

    /**
     * Returns client application vendor.
     * @returns {String|null} Client application vendor
     */
  }, {
    key: "getVendor",
    value: function getVendor() {
      return this._vendor;
    }

    /**
     * Returns client application name.
     * @returns {String|null} Client application name
     */
  }, {
    key: "getApp",
    value: function getApp() {
      return this._app;
    }

    /**
     * Returns client application subapp.
     * @returns {String|null} Client application subapp
     */
  }, {
    key: "getSubApp",
    value: function getSubApp() {
      return this._subApp;
    }

    /**
     * Returns client application asid.
     * @returns {String|null} Client application asid
     */
  }, {
    key: "getAsid",
    value: function getAsid() {
      return this._asid;
    }

    /**
     * Returns client application awid.
     * @returns {String|null} Client application awid
     */
  }, {
    key: "getAwid",
    value: function getAwid() {
      return this._awid;
    }

    /**
     * Returns type of the client identity.
     * @returns {String|null} Type of the client identity
     */
  }, {
    key: "getType",
    value: function getType() {
      return this._type;
    }

    /**
     * Returns the means of authentication (type of credentials) of client identity.
     * @returns {String} String representation of the means of authentication
     */
  }, {
    key: "getAuthenticationLevelOfAssurance",
    value: function getAuthenticationLevelOfAssurance() {
      return this._authenticationLevelOfAssurance;
    }

    /**
     * Returns uuAppKey representation of system identity.
     * @returns {UuAppKey} uuAppKey representation of the system identity
     */
  }, {
    key: "getUuAppKey",
    value: function getUuAppKey() {
      return this._uuAppKey;
    }
  }]);
  return ClientIdentity;
}();
module.exports = ClientIdentity;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;

/**
 * Base error of all authentication errors.
 */
var AuthenticationError = /*#__PURE__*/function (_BaseError) {
  _inherits(AuthenticationError, _BaseError);
  var _super = _createSuper(AuthenticationError);
  function AuthenticationError() {
    _classCallCheck(this, AuthenticationError);
    return _super.apply(this, arguments);
  }
  return _createClass(AuthenticationError);
}(BaseError);
module.exports = AuthenticationError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/errors/invalid-credentials.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var AuthenticationError = __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js");

/**
 * Error raised by AuthenticationService in case provided
 * credentials are not valid.
 */
var InvalidCredentials = /*#__PURE__*/function (_AuthenticationError) {
  _inherits(InvalidCredentials, _AuthenticationError);
  var _super = _createSuper(InvalidCredentials);
  function InvalidCredentials() {
    _classCallCheck(this, InvalidCredentials);
    return _super.apply(this, arguments);
  }
  return _createClass(InvalidCredentials);
}(AuthenticationError);
module.exports = InvalidCredentials;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/errors/untrusted-credentials.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var AuthenticationError = __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js");

/**
 * Error raised in case session does not meet required criteria
 * (e.g. login too old or authentication level of assurance not met )
 */
var UntrustedCredentials = /*#__PURE__*/function (_AuthenticationError) {
  _inherits(UntrustedCredentials, _AuthenticationError);
  var _super = _createSuper(UntrustedCredentials);
  /**
   * Creates new instance of error.
   * @param {Session} session Instance of session not matching requried criteria
   * @param {string} message Error message
   * @param {Error} cause Error cause
   */
  function UntrustedCredentials(session, message) {
    var _this;
    var cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    _classCallCheck(this, UntrustedCredentials);
    if (typeof session === "string") {
      cause = message;
      message = session;
      session = null;
    }
    _this = _super.call(this, message, cause);
    _this._session = session;
    return _this;
  }

  /**
   * Returns instance of untrusted session.
   * @returns {Session} Instance of untrusted session
   */
  _createClass(UntrustedCredentials, [{
    key: "getSession",
    value: function getSession() {
      return this._session;
    }
  }]);
  return UntrustedCredentials;
}(AuthenticationError);
module.exports = UntrustedCredentials;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/errors/uu-app-key-errors.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var ERROR_PREFIX = "uu-app-key/";
var InvalidAppKey = /*#__PURE__*/function (_BaseError) {
  "use strict";

  _inherits(InvalidAppKey, _BaseError);
  var _super = _createSuper(InvalidAppKey);
  function InvalidAppKey(invalidKey) {
    var _this;
    _classCallCheck(this, InvalidAppKey);
    _this = _super.call(this, `The AppKey (${invalidKey}) is not valid.`, null);
    _this.code = `${ERROR_PREFIX}invalidAppKey`;
    return _this;
  }
  return _createClass(InvalidAppKey);
}(BaseError);
var InconsistentAppKey = /*#__PURE__*/function (_BaseError2) {
  "use strict";

  _inherits(InconsistentAppKey, _BaseError2);
  var _super2 = _createSuper(InconsistentAppKey);
  function InconsistentAppKey(partName, partValue) {
    var _this2;
    _classCallCheck(this, InconsistentAppKey);
    _this2 = _super2.call(this, `The AppKey is not valid. The ${partName} part (${partValue}) is not valid. Null value was expected because some AppKey part before was null.`, null);
    _this2.code = `${ERROR_PREFIX}inconsistentAppKey`;
    return _this2;
  }
  return _createClass(InconsistentAppKey);
}(BaseError);
var InvalidAppKeyPart = /*#__PURE__*/function (_BaseError3) {
  "use strict";

  _inherits(InvalidAppKeyPart, _BaseError3);
  var _super3 = _createSuper(InvalidAppKeyPart);
  function InvalidAppKeyPart(partName, partValue) {
    var _this3;
    _classCallCheck(this, InvalidAppKeyPart);
    _this3 = _super3.call(this, `The AppKey is not valid. The ${partName} part (${partValue}) is not valid.`, null);
    _this3.code = `${ERROR_PREFIX}invalidAppKeyPart`;
    return _this3;
  }
  return _createClass(InvalidAppKeyPart);
}(BaseError);
module.exports = {
  InvalidAppKey,
  InconsistentAppKey,
  InvalidAppKeyPart
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/identity.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/**
 * The identity of a user.
 */
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Identity = /*#__PURE__*/function () {
  /**
   * Creates new instance of user identity.
   * @param {String} uuIdentity Unique identifier of the user
   * @param {Object} data Additional identity data.
   * @param {String} data.name Name of the identity
   * @param {String} data.type Type of the identity
   * @param {number} data.levelOfAssurance Numeric representation of identity verification level
   * @param {String} data.authenticationLevelOfAssurance String representation of the means of identity authentication
   * @param {UuAppKey} data.uuAppKey uuAppKey representing the system identity. Set only if the identity type is system identity.
   * @private
   */
  function Identity(uuIdentity, data) {
    _classCallCheck(this, Identity);
    this._uuIdentity = uuIdentity;
    if (typeof data === "string") {
      this._name = data;
    } else if (data) {
      this._name = data.name;
      this._type = data.type;
      this._accountType = data.accountType;
      this._levelOfAssurance = data.levelOfAssurance;
      this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance;
      this._uuAppKey = data.uuAppKey;
    }
  }

  /**
   * Returns a unique identifier of the user.
   * @returns {String} String representation of the unique identifier of the user
   */
  _createClass(Identity, [{
    key: "getUuIdentity",
    value: function getUuIdentity() {
      return this._uuIdentity;
    }

    /**
     * Returns the name of the user.
     * @returns {String|null} User's name
     */
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }

    /**
     * Type of the identity.
     * @returns {String|null} Type of the identity
     */
  }, {
    key: "getType",
    value: function getType() {
      return this._type;
    }

    /**
     * Type of the identity account.
     * @returns {String|null} Type of identityAccount
     */
  }, {
    key: "getAccountType",
    value: function getAccountType() {
      return this._accountType;
    }

    /**
     * Numeric representation of identity verification level.
     * @returns {number|null} Numeric representation of identity verification level
     */
  }, {
    key: "getLevelOfAssurance",
    value: function getLevelOfAssurance() {
      return this._levelOfAssurance;
    }

    /**
     * Returns the means of authentication (type of credentials) of the identity.
     * @returns {String} String representation of the means of authentication
     */
  }, {
    key: "getAuthenticationLevelOfAssurance",
    value: function getAuthenticationLevelOfAssurance() {
      return this._authenticationLevelOfAssurance;
    }

    /**
     * Returns uuAppKey representation of system identity.
     * @returns {UuAppKey|null} uuAppKey representation of the system identity. null if type of identity is not system identity.
     */
  }, {
    key: "getUuAppKey",
    value: function getUuAppKey() {
      return this._uuAppKey;
    }

    // TODO Only for backward compatibility, drop for "1.0.0" release
    /**
     * Only for backward compatibility.
     * @private
     */
  }, {
    key: "getUUIdentity",
    value: function getUUIdentity() {
      return this.getUuIdentity();
    }
  }]);
  return Identity;
}();
module.exports = Identity;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  get AuthenticationService() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/authentication-service.js");
  },
  get Session() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/session.js");
  },
  get Identity() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/identity.js");
  },
  get ClientIdentity() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/client-identity.js");
  },
  get ApplicationIdentity() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/application-identity.js");
  },
  get UuAppKey() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/uu-app-key.js");
  },
  get TokenSanitizer() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/token-sanitizer.js");
  },
  get AuthenticationError() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js");
  },
  get InvalidCredentials() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/invalid-credentials.js");
  },
  get UntrustedCredentials() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/untrusted-credentials.js");
  },
  get uuAppKeyErrors() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/uu-app-key-errors.js");
  }
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/session.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var UntrustedCredentials = __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/untrusted-credentials.js");

/**
 * Object providing result of authentication process. It holds information about the user's identity, the information
 * about the application and also attributes related to authentication process itself.
 */
var Session = /*#__PURE__*/function () {
  /**
   * Creates new instance of session.
   * @param {Object} data Authentication data.
   * @param {String} data.id Unique session instance ID.
   * @param {String} data.authenticationId Unique ID of authentication process (in whose scope was this session instance created).
   * @param {Date} data.authenticationTime Time of authentication process invocation (in whose scope was this session instance created).
   * @param {number} data.authenticationLevelOfAssurance Numeric representation of the means of authentication
   * @param {Identity} data.identity User identity
   * @param {ApplicationIdentity} data.applicationIdentity Application identity (deprecated, use clientIdentity)
   * @param {ClientIdentity} data.clientIdentity Client Application identity
   * @param {Object} data.attributes Implementation specific session attributes
   * @private
   */
  function Session() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Session);
    this._id = data.id || null;
    this._authenticationId = data.authenticationId || null;
    this._authenticationTime = data.authenticationTime || new Date();
    this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance ? parseInt(data.authenticationLevelOfAssurance) : 0;
    this._identity = data.identity;
    this._actorIdentity = data.actorIdentity;
    this._clientIdentity = data.clientIdentity;
    this._applicationIdentity = data.applicationIdentity;
    this._attributes = data.attributes || {};
    this._authenticated = !!(this._authenticationLevelOfAssurance && (this._identity || this._applicationIdentity || this._clientIdentity));
  }

  /**
   * Returns unique session instance ID.
   * @returns {String|null} Session ID.
   */
  _createClass(Session, [{
    key: "getId",
    value: function getId() {
      return this._id;
    }

    /**
     * Returns unique ID of authentication process (in whose scope was this session instance created).
     * @returns {String|null} Unique ID of global session
     */
  }, {
    key: "getAuthenticationId",
    value: function getAuthenticationId() {
      return this._authenticationId;
    }

    /**
     * Returns the time of authentication process invocation (in whose scope was this session instance created).
     * @returns {Date|null} Time of authentication
     */
  }, {
    key: "getAuthenticationTime",
    value: function getAuthenticationTime() {
      return this._authenticationTime;
    }

    /**
     * Returns the means of authentication (type of credentials) for current user.
     * @returns {number} Numeric representation of the means of authentication
     */
  }, {
    key: "getAuthenticationLevelOfAssurance",
    value: function getAuthenticationLevelOfAssurance() {
      return this._authenticationLevelOfAssurance;
    }

    /**
     * Returns user identity.
     * @returns {Identity} User identity
     */
  }, {
    key: "getIdentity",
    value: function getIdentity() {
      return this._identity;
    }

    /**
     * Returns actor user identity.
     * @returns {Identity} Actor user identity
     */
  }, {
    key: "getActorIdentity",
    value: function getActorIdentity() {
      return this._actorIdentity;
    }

    /**
     * Returns client application identity.
     * @returns {ClientIdentity|null} Client application identity
     */
  }, {
    key: "getClientIdentity",
    value: function getClientIdentity() {
      return this._clientIdentity;
    }

    /**
     * Returns application identity.
     * @returns {ApplicationIdentity|null} Application identity
     * @deprecated Use getClientIdentity.
     */
  }, {
    key: "getApplicationIdentity",
    value: function getApplicationIdentity() {
      return this._applicationIdentity;
    }

    /**
     * Returns true if the user is not anonymous.
     * @returns {boolean} True if user is not anonymous
     */
  }, {
    key: "isAuthenticated",
    value: function isAuthenticated() {
      return !!this._authenticated;
    }

    /**
     * Returns call token scope based on URI of invoked command. This value may be then used for obtaining of
     * actual call token provided by method getCallToken.
     * @param {String|URI} uri URI of command to be invoked (for which to obtain call token scope).
     * @param {Object} opts Call token options.
     * @param {String|null} otps.scopeMode Scope mode (one of [useCase, allUseCases, none]).
     * @returns {Promise<String>} Call token scope
     */
  }, {
    key: "getCallTokenScope",
    value: function () {
      var _getCallTokenScope = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uri) {
        var opts,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              return _context.abrupt("return", uri ? uri.toString().split("?")[0] : uri);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function getCallTokenScope(_x) {
        return _getCallTokenScope.apply(this, arguments);
      }
      return getCallTokenScope;
    }()
    /**
     * Returns token to be used by client to call functionality provided by other application server.
     * @param {String|URI} scope Scope (single value or array) representing functionality to be invoked with token.
     * @param {Object} opts Call token options.
     * @param {boolean|null} otps.useTokenExchange Flag if call should use new token (derived from existing) or directly reuse existing one.
     * @param {boolean|null} opts.excludeAuthenticationType Flag if call token should be returned without authentication type prefix.
     * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
     * @returns {Promise<String>} Call token
     */
  }, {
    key: "getCallToken",
    value: function () {
      var _getCallToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(scope) {
        var opts,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              opts = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              throw new Error("Method not implemented.");
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getCallToken(_x2) {
        return _getCallToken.apply(this, arguments);
      }
      return getCallToken;
    }()
    /**
     * Allows to switch to another user (switch is allowed only in case there is existing actor-impersonation association
     * between current user and user to switch to).
     * @param {String} uuIdentity Identification of user to switch to.
     * @param {String|URI|null} scope Scope representing functionality to be invoked within new session.
     * @param {Object|null} opts User switch options.
     * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
     * @returns {Promise<Session>} User session.
     */
  }, {
    key: "actAs",
    value: function () {
      var _actAs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(uuIdentity) {
        var scope,
          opts,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              scope = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              throw new Error("Method not implemented.");
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function actAs(_x3) {
        return _actAs.apply(this, arguments);
      }
      return actAs;
    }()
    /**
     * Checks if processed authentication conforms to required constraints.
     * @param {Object} constraints Session constraint object
     * @param {number|null} constraints.maxAuthenticationAge Maximum age of authentication in seconds
     * @param {number|null} constraints.minAuthenticationLevelOfAssurance Minimum required level of assurance
     * @throws {UntrustedCredentials} In case processed authentication does not conform to required constraints.
     */
  }, {
    key: "assertTrustiness",
    value: function assertTrustiness() {
      var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var mla = constraints.minAuthenticationLevelOfAssurance;
      if (mla != undefined && mla != null && mla > this.getAuthenticationLevelOfAssurance()) {
        throw new UntrustedCredentials(this, "Minimum login level of assurance not met.");
      }
      var maxAge = constraints.maxAuthenticationAge;
      if (maxAge != undefined && maxAge != null) {
        var epochAuthTime = this.getAuthenticationTime().getTime() / 1000;
        var epochCurTime = Date.now / 1000;
        if (epochAuthTime + maxAge < epochCurTime) {
          throw new UntrustedCredentials(this, "User re-authentication required.");
        }
      }
    }

    /**
     * Returns custom session attribute (actual attributes are dependant on particular session instance based on
     * technology used for authentication process)
     * @param {String} name Name of session attribute
     * @returns {*} Attribute value
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this._attributes[name];
    }

    /**
     * Performs the log out of the user.
     */
  }, {
    key: "close",
    value: function close() {
      this._authenticated = false;
    }

    /**
     * Serializes user and client data. Does not contain ids so that result can
     * be used for comparison between multiple instances of session.
     * @returns {String}
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        identity: this._identity,
        clientIdentity: this._clientIdentity,
        applicationIdentity: this._applicationIdentity
      };
    }
  }]);
  return Session;
}();
module.exports = Session;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/token-sanitizer.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var AUTH_HEADER_REGEX = /^([Bb]asic|[Bb]earer)[ ](.+)$/;
var QUERY_PARAM_REGEX = /[?&](access_token|id_token)=([^&]+)/;
var JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
var TokenSanitizer = /*#__PURE__*/function () {
  function TokenSanitizer() {
    _classCallCheck(this, TokenSanitizer);
  }
  _createClass(TokenSanitizer, null, [{
    key: "processToken",
    value: function processToken(token) {
      if (!token) {
        return token;
      } else if (token.match(JWT_TOKEN_REGEX)) {
        return `...${token.split(".")[1]}...`;
      } else {
        var partLength = Math.ceil(token.length / 5);
        return `${token.substring(0, partLength)}...${token.substring(token.length - partLength)}`;
      }
    }
  }, {
    key: "processHeader",
    value: function processHeader(header) {
      var match;
      if (!header || !(match = header.match(AUTH_HEADER_REGEX))) {
        return header;
      }
      var type = match[1];
      var token = match[2];
      return `${type} ${this.processToken(token)}`;
    }
  }, {
    key: "processUri",
    value: function processUri(uri) {
      var match;
      if (!uri || !(match = uri.match(QUERY_PARAM_REGEX))) {
        return uri;
      }
      var param = match[1];
      var token = match[2];
      return uri.replace(`${param}=${token}`, `${param}=${this.processToken(token)}`);
    }
  }]);
  return TokenSanitizer;
}();
module.exports = TokenSanitizer;

/***/ }),

/***/ "../node_modules/uu_appg01_core-authentication/src/uu-app-key.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _slicedToArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/slicedToArray.js")["default"]);
var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Errors = __webpack_require__("../node_modules/uu_appg01_core-authentication/src/errors/uu-app-key-errors.js");
var APP_KEY_URN_PREFIX = "urn:uuappkey:";
var IDENTIFIER = "[a-zA-Z0-9_]";
var VENDOR = `(${IDENTIFIER}{1,32})`;
var APP = `(${IDENTIFIER}{1,32})`;
var SUB_APP = `(${IDENTIFIER}{1,32})`;
var ASID = `(${IDENTIFIER}{1,32})`;
var AWID = `(${IDENTIFIER}{1,32})`;
var APP_KEY_REGEXP = new RegExp(`^(?:${APP_KEY_URN_PREFIX})?${VENDOR}(?:\\-(?:${APP}(?:\\-(?:${SUB_APP}(?:\\/(?:${ASID}(?:\\-(?:${AWID})?)?)?)?)?)?)?)?$`);

/**
 * Class is used for designing relations. Holds information about product, asid and awid.
 * The value is entered from the left (right-side parts can be left empty).
 *
 * <pre>Format: {vendor}-{app}-{subApp}/{asid}-{awid}
 *
 * Valid values:
 * {vendor}-{app}-{subApp}/{awid}
 * {vendor}-{app}-{subApp}
 * {vendor}-{app}
 * {vendor}</pre>
 */
var UuAppKey = /*#__PURE__*/function () {
  /**
   * New instance of UuAppKey should be created using {@link UuAppKey.parse} or {@link UuAppKey.valueOf}.
   * @private
   */
  function UuAppKey(vendor) {
    var app = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var subApp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var asid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var awid = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    _classCallCheck(this, UuAppKey);
    this._vendor = vendor;
    this._product = vendor;
    this._app = app;
    if (app) {
      this._product += `-${app}`;
    }
    this._subApp = subApp;
    if (subApp) {
      this._product += `-${subApp}`;
    }
    this._asid = asid;
    this._awid = awid;
    Object.freeze(this);
  }

  /**
   * Parses a string value to instance.
   *
   * @param {string} value value to be parsed
   * @return {UuAppKey} instance
   */
  _createClass(UuAppKey, [{
    key: "getProduct",
    value:
    /**
     * Getter for composed product property.
     *
     * @return {string} product
     */
    function getProduct() {
      return this._product;
    }

    /**
     * Getter for property vendor.
     *
     * @return {string} vendor
     */
  }, {
    key: "getVendor",
    value: function getVendor() {
      return this._vendor;
    }

    /**
     * Getter for property app.
     *
     * @return {string} app
     */
  }, {
    key: "getApp",
    value: function getApp() {
      return this._app;
    }

    /**
     * Getter for property subApp.
     *
     * @return {string} subApp
     */
  }, {
    key: "getSubApp",
    value: function getSubApp() {
      return this._subApp;
    }

    /**
     * Getter for property asid.
     *
     * @return {string} asid
     */
  }, {
    key: "getAsid",
    value: function getAsid() {
      return this._asid;
    }

    /**
     * Getter for property awid.
     *
     * @return {string} awid
     */
  }, {
    key: "getAwid",
    value: function getAwid() {
      return this._awid;
    }

    /**
     * Creates string representation of the appKey.
     *
     * @return {string} UuAppKey string value
     */
  }, {
    key: "toString",
    value: function toString() {
      var parts = this._asid ? [["/", this._asid], ["-", this._awid]] : [["/", this._awid]];
      var result = this._product;
      for (var _i = 0, _parts = parts; _i < _parts.length; _i++) {
        var partPair = _parts[_i];
        if (partPair[1]) {
          result += partPair.join("");
        } else {
          break;
        }
      }
      return result;
    }

    /**
     * Returns regular expression (based on attributes of UuAppKey instance).
     *
     * @return {string} regular expression
     */
  }, {
    key: "getRegExp",
    value: function getRegExp() {
      var parts = [["\\-", this._app], ["\\-", this._subApp]];
      parts = parts.concat(this._asid || !this._awid ? [["\\/", this._asid], ["\\-", this._awid]] : [["\\/(.+\\-)?", this._awid]]);
      var result = this._vendor;
      var _iterator = _createForOfIteratorHelper(parts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var partPair = _step.value;
          if (partPair[1]) {
            result += partPair.join("");
          } else {
            result += partPair[0] + ".*";
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return result;
    }

    /**
     * Indicates whether some other object is equal to this one.
     *
     * @param {UuAppKey} UuAppKey UuAppKey with which to compare
     * @return {boolean} true if equal
     */
  }, {
    key: "equals",
    value: function equals(appKey) {
      if (appKey == this) {
        return true;
      }
      if (!appKey || !(appKey instanceof UuAppKey)) {
        return false;
      }
      return this.getVendor() == appKey.getVendor() && this.getApp() == appKey.getApp() && this.getSubApp() == appKey.getSubApp() && this.getAwid() == appKey.getAwid() && this.getAsid() == appKey.getAsid();
    }

    /**
     * Compares parts of UuAppKey instance with set value against parts of UuAppKey argument.
     * This method doesn't ensure symmetric comparison (e.g. if a==b then b==a) as it compares only non-null parts of the UuAppKey instance it is called on.
     *
     * @param {UuAppKey} appKey UuAppKey with which to compare
     * @return {boolean} true if this non null appKey parts are the same as parts of the appKey argument
     */
  }, {
    key: "compareNonNullParts",
    value: function compareNonNullParts(appKey) {
      if (appKey == this) {
        return true;
      }
      if (!appKey || !(appKey instanceof UuAppKey)) {
        return false;
      }
      return this.getVendor() == appKey.getVendor() && (!this.getApp() || this.getApp() == appKey.getApp()) && (!this.getSubApp() || this.getSubApp() == appKey.getSubApp()) && (!this.getAwid() || this.getAwid() == appKey.getAwid()) && (!this.getAsid() || this.getAsid() == appKey.getAsid());
    }
  }], [{
    key: "parse",
    value: function parse(value) {
      if (value instanceof UuAppKey) {
        return value;
      }
      var result = (value || "").match(APP_KEY_REGEXP);
      if (!result) {
        throw new Errors.InvalidAppKey(value);
      }
      var asid, awid;
      if (result[5]) {
        asid = result[4];
        awid = result[5];
      } else {
        awid = result[4];
        asid = null;
      }
      return new UuAppKey(result[1], result[2], result[3], asid, awid);
    }

    /**
     * Creates instance.
     *
     * @param {string} vendor vendor
     * @param {string} app app
     * @param {string} supApp sub application
     * @param {string} asid asid
     * @param {string} awid awid
     * @return {UuAppKey} instance
     */
  }, {
    key: "valueOf",
    value: function valueOf(vendor, app, supApp, asid, awid) {
      // check consistency
      // vendor is mandatory
      if (!(vendor || "").match(`^${VENDOR}$`)) {
        throw new Errors.InvalidAppKeyPart("vendor", vendor);
      }
      // other parts are optional, but they has to be entered from the left
      var partialAppKey = false;
      [[APP, app, "app"], [SUB_APP, supApp, "subApp"], [AWID, awid, "awid"], [ASID, asid, "asid"]].forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 3),
          regexp = _ref2[0],
          partValue = _ref2[1],
          partName = _ref2[2];
        if (!partValue) {
          partialAppKey = true;
        } else {
          if (partialAppKey) {
            throw new Errors.InconsistentAppKey(partName, partValue);
          }
          if (!partValue.match(`^${regexp}$`)) {
            throw new Errors.InvalidAppKeyPart(partName, partValue);
          }
        }
      });
      var appKey = new UuAppKey(vendor, app, supApp, asid, awid);
      return appKey;
    }
  }]);
  return UuAppKey;
}();
module.exports = UuAppKey;

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/index.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Logger = __webpack_require__("../node_modules/uu_appg01_core-logging/src/logger.js");
var LoggerFactory = __webpack_require__("../node_modules/uu_appg01_core-logging/src/logger-factory.js");
var LogLevel = __webpack_require__("../node_modules/uu_appg01_core-logging/src/log-level.js");
var MessageFormatter = __webpack_require__("../node_modules/uu_appg01_core-logging/src/message-formatter.js");
var StdoutOutputter = __webpack_require__("../node_modules/uu_appg01_core-logging/src/stdout-outputter.browser.js");
var LoggerMDC = __webpack_require__("../node_modules/uu_appg01_core-logging/src/logger_mdc/logger-mdc.js");
module.exports = {
  Logger,
  LoggerFactory,
  LogLevel,
  MessageFormatter,
  StdoutOutputter,
  LoggerMDC
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/log-level.js":
/***/ (function(module) {

"use strict";


var LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4,
  UNKNOWN: 5,
  OFF: 6
};
module.exports = LogLevel;

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/logger-factory.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Logger = __webpack_require__("../node_modules/uu_appg01_core-logging/src/logger.js");
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError,
  Config = _require.Config;
var loggers = {};

/**
 * @class UuApp.Logging.LoggerFactory
 * @classdesc
 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
 */

/**
 * Returns an instance of the logger with given name. Settings of the logger are
 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
 *
 * Successive calls with the same logger name return the same logger instance.
 *
 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
 *   the component that uses the logger, e.g. "My.Namespace.Component".
 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
 *   in successive calls it's ignored.
 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
 * @method UuApp.Logging.LoggerFactory.get
 */
var LoggerFactory = /*#__PURE__*/function () {
  function LoggerFactory() {
    _classCallCheck(this, LoggerFactory);
  }
  _createClass(LoggerFactory, null, [{
    key: "get",
    value: function get(name) {
      var hierarchical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (typeof name != "string") {
        throw new BaseError("LoggerFactory.get() must be called with a string argument (logger name).");
      }
      var cname = name.toLowerCase();
      if (loggers[cname]) {
        return loggers[cname].logger;
      } else {
        var logger = new Logger(name);
        LoggerFactory.configure(logger, hierarchical);
        loggers[cname] = {
          logger: logger,
          hierarchical: hierarchical
        };
        return logger;
      }
    }
  }, {
    key: "configure",
    value: function configure(logger, hierarchical) {
      var cname = logger.getName().toString().toLowerCase();
      var logSeverityLabels = Config.get(cname + ".log_severity_labels", hierarchical !== false);
      var logMessageFormat = Config.get(cname + ".log_message_format", hierarchical !== false);
      var logErrorFormat = Config.get(cname + ".log_error_format", hierarchical !== false);
      var logCauseFormat = Config.get(cname + ".log_cause_format", hierarchical !== false);
      var logLevel = Config.get(cname + ".log_level", hierarchical !== false);
      logger.setSeverityLabels(logSeverityLabels);
      logger.setMessageFormat(logMessageFormat);
      logger.setErrorFormat(logErrorFormat);
      logger.setCauseFormat(logCauseFormat);
      logger.setLevel(logLevel);
    }
  }, {
    key: "configureAll",
    value: function configureAll() {
      Object.keys(loggers).map(function (name) {
        var reg = loggers[name];
        LoggerFactory.configure(reg.logger, reg.hirearchical);
      });
    }
  }]);
  return LoggerFactory;
}();
module.exports = LoggerFactory;

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/logger.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var LogLevel = __webpack_require__("../node_modules/uu_appg01_core-logging/src/log-level.js");
var StdoutOutputter = __webpack_require__("../node_modules/uu_appg01_core-logging/src/stdout-outputter.browser.js");
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;

/**
 * @class UuApp.Logging.Logger
 * @classdesc
 * Component for logging. Each logged message has a severity level and each logger can be
 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
 *
 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
 * are typically removed from production code), statements using Logger-s are intended to be
 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
 * configuration.
 *
 * **Configuration**
 *
 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
 * Supported environment options:
 *
 *     {
 *       "log_level": "ERROR",
 *       "My.Namespace.log_level": "WARN"
 *     }
 *
 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
 *
 * **Typical usage**
 *
 *     // get logger instance and log a message
 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
 *
 *     // if logging requires lengthy computation, it can be made conditional so that it
 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
 *     if (logger.isDebugLoggable()) {
 *       var computedValue = ...; // some lengthy computation
 *       logger.debug("Value computed to", computedValue);
 *     }
 *
 */
var Logger = /*#__PURE__*/function () {
  function Logger(name) {
    var outputter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, Logger);
    this._name = name;
    this._level = LogLevel.WARN;
    this._outputter = outputter || new StdoutOutputter();
  }
  _createClass(Logger, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }

    /**
     * Sets severity level of this Logger to given value. Messages with lower (less important)
     * severity will be ignored when attempted to be logged via this logger. Order of importance:
     * DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN < OFF.
     *
     * **It's strongly advised not to configure loggers directly using this method** because
     * if such code gets deployed to production, it'll effectively override settings from
     * environment and therefore could prevent logging of necessary information.
     * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
     *
     * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
     *   is given, default is used (LEVEL_WARN).
     * @method UuApp.Logging.Logger#setLevel
     */
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      if (typeof level === "number") {
        this._level = level;
      } else if (typeof level === "string") {
        var lvl = LogLevel[level.toUpperCase()] !== undefined ? LogLevel[level.toUpperCase()] : Number(level);
        if (lvl !== undefined && !isNaN(lvl)) {
          this._level = lvl;
        }
      } else if (!level) {
        this._level = LogLevel.WARN;
      } else {
        throw new BaseError(`Invalid logger level "${level}"`);
      }
      return this;
    }

    /**
     * @return {number} Level of this logger.
     * @method UuApp.Logging.Logger#getLevel
     */
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._level;
    }
  }, {
    key: "setSeverityLabels",
    value: function setSeverityLabels(severityLabels) {
      this._outputter.setSeverityLabels(severityLabels);
      return this;
    }
  }, {
    key: "getSeverityLabels",
    value: function getSeverityLabels() {
      return this._outputter.getSeverityLabels();
    }
  }, {
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      this._outputter.setMessageFormat(messageFormat);
      return this;
    }
  }, {
    key: "getMessageFormat",
    value: function getMessageFormat() {
      return this._outputter.getMessageFormat();
    }
  }, {
    key: "setErrorFormat",
    value: function setErrorFormat(errorFormat) {
      this._outputter.setErrorFormat(errorFormat);
      return this;
    }
  }, {
    key: "getErrorFormat",
    value: function getErrorFormat() {
      return this._outputter.getErrorFormat();
    }
  }, {
    key: "setCauseFormat",
    value: function setCauseFormat(causeFormat) {
      this._outputter.setCauseFormat(causeFormat);
      return this;
    }
  }, {
    key: "getCauseFormat",
    value: function getCauseFormat() {
      return this._outputter.getCauseFormat();
    }
  }, {
    key: "setOutputter",
    value: function setOutputter(outputter) {
      this._outputter = outputter;
      return this;
    }
  }, {
    key: "getOutputter",
    value: function getOutputter() {
      return this._outputter;
    }

    /**
     * @return {boolean} Whether this logger logs message with severity level "DEBUG".
     * @method UuApp.Logging.Logger#isDebugLoggable
     */
  }, {
    key: "isDebugLoggable",
    value: function isDebugLoggable() {
      return this._level <= LogLevel.DEBUG;
    }

    /**
     * Logs message with severity level "DEBUG".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#debug
     */
  }, {
    key: "debug",
    value: function debug(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this._add(LogLevel.DEBUG, message, error);
    }

    /**
     * @return {boolean} Whether this logger logs message with severity level "INFO".
     * @method UuApp.Logging.Logger#isInfoLoggable
     */
  }, {
    key: "isInfoLoggable",
    value: function isInfoLoggable() {
      return this._level <= LogLevel.INFO;
    }

    /**
     * Logs message with severity level "INFO".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#info
     */
  }, {
    key: "info",
    value: function info(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this._add(LogLevel.INFO, message, error);
    }

    /**
     * @return {boolean} Whether this logger logs message with severity level "WARN".
     * @method UuApp.Logging.Logger#isWarnLoggable
     */
  }, {
    key: "isWarnLoggable",
    value: function isWarnLoggable() {
      return this._level <= LogLevel.WARN;
    }

    /**
     * Logs message with severity level "WARN".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#warn
     */
  }, {
    key: "warn",
    value: function warn(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this._add(LogLevel.WARN, message, error);
    }

    /**
     * @return {boolean} Whether this logger logs message with severity level "ERROR".
     * @method UuApp.Logging.Logger#isErrorLoggable
     */
  }, {
    key: "isErrorLoggable",
    value: function isErrorLoggable() {
      return this._level <= LogLevel.ERROR;
    }

    /**
     * Logs message with severity level "ERROR".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#error
     */
  }, {
    key: "error",
    value: function error(message) {
      var _error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this._add(LogLevel.ERROR, message, _error);
    }

    /**
     * @return {boolean} Whether this logger logs message with severity level "FATAL".
     * @method UuApp.Logging.Logger#isFatalLoggable
     */
  }, {
    key: "isFatalLoggable",
    value: function isFatalLoggable() {
      return this._level <= LogLevel.FATAL;
    }

    /**
     * Logs message with severity level "FATAL".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#error
     */
  }, {
    key: "fatal",
    value: function fatal(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this._add(LogLevel.FATAL, message, error);
    }

    /**
     * Logs message with "UNKNOWN" severity.
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#error
     */
  }, {
    key: "log",
    value: function log(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this._add(LogLevel.UNKNOWN, message, error);
    }

    // ======================== Private methods ================================
  }, {
    key: "_add",
    value: function _add(level, message, error) {
      if (this._level <= level) {
        this._write(new Date(), level, message, error);
      }
    }
  }, {
    key: "_write",
    value: function () {
      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(datetime, level, message, error) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this._outputter.write(datetime, this._name, level, message, error);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _write(_x, _x2, _x3, _x4) {
        return _write2.apply(this, arguments);
      }
      return _write;
    }()
  }]);
  return Logger;
}();
module.exports = Logger;

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/logger_mdc/get-set.browser.js":
/***/ (function(module) {

/**
 * LoggerMDC implementation of get and set
 * for Browser environment.
 */
module.exports = {
  setFactory(ContextStore, CTX_STORE_NAME, MDC_KEY) {
    return function set(key, value) {
      var store = ContextStore.get(CTX_STORE_NAME);
      if (!store) {
        ContextStore.create(CTX_STORE_NAME, noop);
        store = ContextStore.get(CTX_STORE_NAME);
      }
      var mdc = store.get(MDC_KEY);
      if (!mdc) {
        mdc = {};
        store.set(MDC_KEY, mdc);
      }
      mdc[key] = value;
    };
  },
  getFactory(ContextStore, CTX_STORE_NAME, MDC_KEY) {
    return function get(key) {
      var store = ContextStore.get(CTX_STORE_NAME);
      if (!store) {
        ContextStore.create(CTX_STORE_NAME, noop);
        store = ContextStore.get(CTX_STORE_NAME);
      }
      var mdc = store.get(MDC_KEY);
      if (mdc) {
        return mdc[key];
      }
    };
  }
};
function noop() {}

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/logger_mdc/logger-mdc.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  ContextStore = _require.ContextStore,
  Json = _require.Json;

// environment specific implementations
var _require2 = __webpack_require__("../node_modules/uu_appg01_core-logging/src/logger_mdc/get-set.browser.js"),
  getFactory = _require2.getFactory,
  setFactory = _require2.setFactory;
var CTX_STORE_NAME = "uuapp.logging";
var MDC_KEY = "mdc";

/**
 * Mapped diagnostic context.
 */
var LoggerMDC = /*#__PURE__*/function () {
  function LoggerMDC() {
    _classCallCheck(this, LoggerMDC);
  }
  _createClass(LoggerMDC, null, [{
    key: "create",
    value:
    /**
     * Initializes MDC
     * @param emitters Context emitters.
     * @param fn Function within which should be MDC available
     * @returns {*} Return value of invoked function.
     */
    function create() {
      var emitters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var fn = arguments.length > 1 ? arguments[1] : undefined;
      if (typeof emitters === "function") {
        fn = emitters;
        emitters = null;
      }
      return ContextStore.create(CTX_STORE_NAME, function () {
        var ctxStore = ContextStore.get(CTX_STORE_NAME);
        if (emitters) {
          emitters.forEach(function (e) {
            return ctxStore.bindEmitter(e);
          });
        }
        return fn();
      });
    }

    /**
     * Stores context attribute.
     * @param key Context attribute name.
     * @param value Context attribute value.
     */
  }, {
    key: "set",
    value: function set(key, value) {
      // implementation available in get-set.js
      // due to environment differences
    }

    /**
     * Reads value of context attribute.
     * @param key Context attribute name.
     * @returns {*} Context attribute value.
     */
  }, {
    key: "get",
    value: function get(key) {
      // implementation available in get-set.js
      // due to environment differences
    }

    /**
     * Clears MDC in current context.
     */
  }, {
    key: "clear",
    value: function clear() {
      var store = ContextStore.get(CTX_STORE_NAME);
      if (store) {
        store.set(MDC_KEY, {});
      }
    }

    /**
     * Serializes current state of MDC to JSON.
     * @returns {string} Serialized MDC
     */
  }, {
    key: "toJson",
    value: function toJson() {
      var store = ContextStore.get(CTX_STORE_NAME);
      if (store) {
        var mdc = store.get(MDC_KEY);
        if (mdc) {
          return Json.stringify(mdc);
        }
      }
      return "{}";
    }
  }]);
  return LoggerMDC;
}(); // remapping environment specific methods
LoggerMDC.set = setFactory(ContextStore, CTX_STORE_NAME, MDC_KEY);
LoggerMDC.get = getFactory(ContextStore, CTX_STORE_NAME, MDC_KEY);
module.exports = LoggerMDC;

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/message-formatter.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _slicedToArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/slicedToArray.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var LogLevel = __webpack_require__("../node_modules/uu_appg01_core-logging/src/log-level.js");
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError,
  Json = _require.Json;
var LoggerMDC = __webpack_require__("../node_modules/uu_appg01_core-logging/src/logger_mdc/logger-mdc.js");

// Regexp to match formatting tags.
// @private
var FORMAT_TAGS = /(%(?:{([^}]*)})?([a-zA-Z%]))/g;

// Default set of severity labels (matching standard ruby
//    {http://ruby-doc.org/stdlib/libdoc/logger/rdoc/Logger/Severity.html
// Logger::Severity} with addition of level +OFF+).
var DEFAULT_SEVERITY_LABELS = "DEBUG INFO WARN ERROR FATAL ANY OFF";

//  Format of message to be used. Following tags are supported:
// * <b>%%</b> - Escaped percent tag.
// * <b>%C</b> - Full {UuApp::Logging::LoggerMdc logger MDC} in JSON format.
// * <b>%d</b> - Date and time in format matching {#datetime_format}.
// * <b>%e</b> - Error formatted using {#error_format} or empty string if there is no error.
// * <b>%m</b> - Actual log message provided by application.
// * <b>%n</b> - Logger name.
// * <b>%p</b> - System process ID.
// * <b>%s</b> - Logging event severity.
// * <b>%t</b> - ID of thread where message was captured.
// * <b>%T</b> - Name of thread where message was captured.
// * <b>%{ KEY }C</b> - Custom attribute from logger {UuApp::Logging::LoggerMdc logger MDC} with name KEY.
//      Time values are printed in format matching {#datetime_format}.
// * <b>%{ FMT }d</b> - Date and time in format matching FMT.
// * <b>%{ FMT }m</b> - Log message provided by application with additional escaping based on FMT value. There are
//      two escaping variants. First is keyword +JSON+ resulting in message with escaped quotes and line separators.
//      In case of any other value, this value will be used to replace new line separators (CR(LF)).
//  * <b>%{ NUM }s</b> - Logging event severity with NUM representing total length of severity with padding.*/

// Default message format (see {#message_format} for tag description).
var DEFAULT_MESSAGE_FORMAT = "[%d] %{5}s %n: %m%e";

// Format of error. In case there is instance of error to be logged (given as explicit logger parameter or implicit
// error reference available inside rescue block), error message is injected into message replacing +%e+ tag. That
// means error format should start with some separator (e.g. new line) to be able to distinguish text of log message
// from printed error. Following tags are supported:
// * <b>%%</b> - Escaped percent tag.
// * <b>%b</b> - Invocation stack (backtrace), lines are joined with new line.
// * <b>%c</b> - Error class name.
// * <b>%C</b> - Error cause formatted using {#cause_format} or {#error_format}, or empty string if there is no cause.
// * <b>%i</b> - Unique error ID.
// * <b>%I</b> - Error code.
// * <b>%m</b> - Actual error message.
// * <b>%t</b> - Timestamp of error instantiation in format matching {#datetime_format}.
// * <b>%{ FMT }b</b> - Invocation stack (backtrace) with additional escaping based on FMT value. There are two escaping variants.
//   First is keyword +JSON+ resulting in message with escaped characters. New line (\n) will be used as backtrace line separator.
//   In case of any other value, this value will be used to replace new line separators (CR(LF)).
// * <b>%{ PFX }C</b> - Error cause with prefix PFX to be used before printing error cause).
// * <b>%{ FMT }m</b> - Error message with additional escaping based on FMT value. There are two escaping variants.
//   First is keyword +JSON+ resulting in message with escaped quotes and line separators. In case of any other value,
//   this value will be used to replace new line separators (CR(LF)).
// * <b>%{ FMT }t</b> - Timestamp of error instantiation in format matching FMT.

// # Default message format (see {#error_format} for tag description).
var DEFAULT_ERROR_FORMAT = "\n  %i [%t] %c: %m\n    %{\n    }b%{\n  Caused by:}C";

//# Default log messages separator.
//# @private
var ENTRY_SEPARATOR = "\n";
var MessageFormatter = /*#__PURE__*/function () {
  function MessageFormatter() {
    var messageFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var errorFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var severityLabels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    _classCallCheck(this, MessageFormatter);
    this.setSeverityLabels(severityLabels || DEFAULT_SEVERITY_LABELS);
    this.setMessageFormat(messageFormat || DEFAULT_MESSAGE_FORMAT);
    this.setErrorFormat(errorFormat || DEFAULT_ERROR_FORMAT);
  }
  _createClass(MessageFormatter, [{
    key: "setSeverityLabels",
    value: function setSeverityLabels(severityLabels) {
      if (severityLabels) {
        this._severityLabels = severityLabels.split(" ");
      }
    }
  }, {
    key: "getSeverityLabels",
    value: function getSeverityLabels() {
      return this._severityLabels.join(" ");
    }
  }, {
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      if (messageFormat) {
        this._messageFormat = messageFormat;
        var formatterSrc = `(function (datetime, name, severity, message, error) {
        return ${this._transformFormat(messageFormat, this._processMessageFormatTag)};
      }).bind(this);`;
        this._messageFormatter = eval(formatterSrc);
      }
    }
  }, {
    key: "getMessageFormat",
    value: function getMessageFormat() {
      return this._messageFormat;
    }
  }, {
    key: "setErrorFormat",
    value: function setErrorFormat(errorFormat) {
      if (errorFormat) {
        this._errorFormat = errorFormat;
        var formatterSrc = `(function (error) {
        return ${this._transformFormat(errorFormat, this._processErrorFormatTag)};
      }).bind(this);`;
        this._errorFormatter = eval(formatterSrc);
      }
    }
  }, {
    key: "getErrorFormat",
    value: function getErrorFormat() {
      return this._errorFormat;
    }
  }, {
    key: "setCauseFormat",
    value: function setCauseFormat(causeFormat) {
      if (causeFormat) {
        this._causeFormat = causeFormat;
        var formatterSrc = `(function (error) {
        return ${this._transformFormat(causeFormat, this._processErrorFormatTag)};
      }).bind(this);`;
        this._causeFormatter = eval(formatterSrc);
      } else {
        this._causeFormat = null;
        this._causeFormatter = null;
      }
    }
  }, {
    key: "getCauseFormat",
    value: function getCauseFormat() {
      return this._causeFormat;
    }
  }, {
    key: "formatMessage",
    value: function formatMessage(datetime, name, severity, message) {
      var error = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      if (!datetime) {
        datetime = new Date();
      }
      if (!name) {
        name = "";
      }
      if (severity == null) {
        severity = LogLevel.UNKNOWN;
      }
      if (!message) {
        message = "";
      }
      return this._messageFormatter(datetime, name, severity, message, error);
    }

    // ======================== Private methods ================================
  }, {
    key: "_formatError",
    value: function _formatError(error) {
      return this._errorFormatter(error);
    }
  }, {
    key: "_formatCause",
    value: function _formatCause(error) {
      return (this._causeFormatter || this._errorFormatter)(error);
    }
  }, {
    key: "_processStack",
    value: function _processStack(error) {
      var result = [];
      var stack = error.stack;
      if (typeof stack === "string") {
        result = stack.split("\n");
      } else if (stack instanceof Array) {
        result = stack;
      } else if (stack) {
        result = stack.toString().split("\n");
      }
      return result;
    }
  }, {
    key: "_processMessageFormatTag",
    value: function _processMessageFormatTag(tag, opts) {
      var result;
      switch (tag) {
        case "C":
          if (opts) {
            result = `LoggerMDC.get("${opts}")`;
          } else {
            result = "LoggerMDC.toJson()";
          }
          break;
        case "d":
          // TODO Format date
          result = "datetime.toISOString()";
          break;
        case "e":
          result = 'error ? this._formatError(error): ""';
          break;
        case "m":
          switch (opts) {
            case null:
            case undefined:
              result = "message";
              break;
            case "JSON":
              result = 'message ? Json.stringify(message).slice(1,-1) : ""';
              break;
            default:
              result = `message ? message.replace(/\\r\\n|\\r|\\n/g, "${opts}"): ""`;
          }
          break;
        case "n":
          result = "name";
          break;
        case "p":
          // TODO Process ID
          result = '"-"';
          break;
        case "s":
          if (opts) {
            result = `(Array(${opts} + 1).join(" ") + (this._severityLabels[severity] || "ANY")).slice(-${opts})`;
          } else {
            result = 'this._severityLabels[severity] || "ANY"';
          }
          break;
        case "t":
          // TODO Thread ID
          result = '"-"';
          break;
        case "T":
          // TODO Thread name
          result = '"-"';
          break;
      }
      return result;
    }
  }, {
    key: "_processErrorFormatTag",
    value: function _processErrorFormatTag(tag, opts) {
      var result;
      switch (tag) {
        case "b":
          {
            switch (opts) {
              case null:
              case undefined:
                result = `this._processStack(error).join("${ENTRY_SEPARATOR}")`;
                break;
              case "JSON":
                result = `Json.stringify(this._processStack(error).join("${ENTRY_SEPARATOR}")).slice(1, -1)`;
                break;
              default:
                result = `this._processStack(error).join("${opts}")`;
            }
            break;
          }
        case "c":
          result = 'error.name || "Error"';
          break;
        case "C":
          result = `error.cause ? ("${opts || ""}" + this._formatCause(error.cause)) : ""`;
          break;
        case "i":
          result = 'error.id ? error.id : ""';
          break;
        case "I":
          result = 'error.code ? error.code : ""';
          break;
        case "m":
          {
            var errorMessage = 'error.message ? (error.message + ((error.paramMap && Object.keys(error.paramMap).length > 0) ? " (paramMap: " + Json.stringify(error.paramMap) + ")" : "")) : (typeof error === "string" ? error : "")';
            switch (opts) {
              case null:
              case undefined:
                result = errorMessage;
                break;
              case "JSON":
                result = `Json.stringify(${errorMessage}).slice(1,-1)`;
                break;
              default:
                result = `(${errorMessage}).replace(/\\r\\n|\\r|\\n/g, "${opts}")`;
            }
            break;
          }
        case "t":
          result = 'error.timestamp ? error.timestamp.toISOString() : "-"';
          break;
      }
      return result;
    }
  }, {
    key: "_transformFormat",
    value: function _transformFormat(format, callback) {
      var _this = this;
      var tags = [];
      format.replace(FORMAT_TAGS, function () {
        tags.push(Array.prototype.slice.call(arguments, 1, -2));
      });
      var result = `("${format.replace(/"/gm, '\\"')}")`;
      tags.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 3),
          full_tag = _ref2[0],
          opts = _ref2[1],
          tag = _ref2[2];
        var replacement;
        if (tag === "%" && !opts) {
          replacement = "%";
        } else {
          replacement = callback(tag, opts);
        }
        if (replacement === null || replacement === undefined) {
          throw new BaseError(`unsupported format tag "${full_tag}" for ${_this.constructor.name}`);
        }
        replacement = `" + (${replacement}) + "`;
        result = result.replace(full_tag, replacement);
      });
      return result.replace(/\n/gm, "\\n").replace();
    }
  }]);
  return MessageFormatter;
}();
module.exports = MessageFormatter;

/***/ }),

/***/ "../node_modules/uu_appg01_core-logging/src/stdout-outputter.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _objectSpread = (__webpack_require__("../node_modules/@babel/runtime/helpers/objectSpread2.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var LogLevel = __webpack_require__("../node_modules/uu_appg01_core-logging/src/log-level.js");
var MessageFormatter = __webpack_require__("../node_modules/uu_appg01_core-logging/src/message-formatter.js");
var BrowserStdoutOutputter = /*#__PURE__*/function () {
  function BrowserStdoutOutputter() {
    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, BrowserStdoutOutputter);
    this._formatter = formatter || new MessageFormatter();
  }
  _createClass(BrowserStdoutOutputter, [{
    key: "setFormatter",
    value: function setFormatter(formatter) {
      this._formatter = formatter;
      return this;
    }
  }, {
    key: "getFormatter",
    value: function getFormatter() {
      return this._formatter;
    }
  }, {
    key: "setSeverityLabels",
    value: function setSeverityLabels(severityLabels) {
      this._formatter.setSeverityLabels(severityLabels);
      return this;
    }
  }, {
    key: "getSeverityLabels",
    value: function getSeverityLabels() {
      return this._formatter.getSeverityLabels();
    }
  }, {
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      this._formatter.setMessageFormat(messageFormat);
      return this;
    }
  }, {
    key: "getMessageFormat",
    value: function getMessageFormat() {
      return this._formatter.getMessageFormat();
    }
  }, {
    key: "setErrorFormat",
    value: function setErrorFormat(errorFormat) {
      this._formatter.setErrorFormat(errorFormat);
      return this;
    }
  }, {
    key: "getErrorFormat",
    value: function getErrorFormat() {
      return this._formatter.getErrorFormat();
    }
  }, {
    key: "setCauseFormat",
    value: function setCauseFormat(causeFormat) {
      this._formatter.setCauseFormat(causeFormat);
      return this;
    }
  }, {
    key: "getCauseFormat",
    value: function getCauseFormat() {
      return this._formatter.getCauseFormat();
    }
  }, {
    key: "write",
    value: function () {
      var _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(datetime, name, level, message, error) {
        var _console, _console2, _console3, _console4, _console5;
        var formattedMessage, output;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // use native browser functionality to display error info
              // error is not formatted by formatter, but passed to console directly
              formattedMessage = this._formatter.formatMessage(datetime, name, level, message);
              output = [formattedMessage];
              if (error != null && typeof error === "object") {
                output.push(error, "\n", _objectSpread({}, error));
              } else if (error != null) {
                output.push(error);
              }
              _context.t0 = level;
              _context.next = _context.t0 === LogLevel.FATAL ? 6 : _context.t0 === LogLevel.ERROR ? 6 : _context.t0 === LogLevel.WARN ? 8 : _context.t0 === LogLevel.INFO ? 10 : _context.t0 === LogLevel.UNKNOWN ? 10 : _context.t0 === LogLevel.DEBUG ? 12 : 14;
              break;
            case 6:
              (_console = console).error.apply(_console, output);
              return _context.abrupt("break", 15);
            case 8:
              (_console2 = console).warn.apply(_console2, output);
              return _context.abrupt("break", 15);
            case 10:
              (_console3 = console).info.apply(_console3, output);
              return _context.abrupt("break", 15);
            case 12:
              (_console4 = console).debug.apply(_console4, output);
              return _context.abrupt("break", 15);
            case 14:
              (_console5 = console).log.apply(_console5, output);
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function write(_x, _x2, _x3, _x4, _x5) {
        return _write.apply(this, arguments);
      }
      return write;
    }()
  }]);
  return BrowserStdoutOutputter;
}();
module.exports = BrowserStdoutOutputter;

/***/ }),

/***/ "../node_modules/uu_appg01_core-perflog/src/index.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  Perflog: __webpack_require__("../node_modules/uu_appg01_core-perflog/src/perflog.browser.js"),
  Section: __webpack_require__("../node_modules/uu_appg01_core-perflog/src/section.browser.js"),
  SectionId: __webpack_require__("../node_modules/uu_appg01_core-perflog/src/section-id.js"),
  Logger: __webpack_require__("../node_modules/uu_appg01_core-perflog/src/logger.js"),
  MessageFormatter: __webpack_require__("../node_modules/uu_appg01_core-perflog/src/message-formatter.js")
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-perflog/src/logger.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  Config = _require.Config;
var LoggerFactory = (__webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js").LoggerFactory);
var BaseLogger = (__webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js").Logger);
var LogLevel = (__webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js").LogLevel);
var StdoutOutputter = (__webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js").StdoutOutputter);
var MessageFormatter = __webpack_require__("../node_modules/uu_appg01_core-perflog/src/message-formatter.js");
var LOGGER_NAME = "UuApp.Perflog.Logger";

/**
 * Logger component internally used by Perflog for providing gathered performance
 * statistics data. Logger is transparently managed via LoggerFactory and
 * therefore supports external configuration via following configuration parameters:
 *
 * * <b>uuapp.perflog.logger.log_level</b><br>
 *   Defines log level. Level can be defined either via name, or its numeric representation. Defaults to +INFO+.
 *
 * * <b>uuapp.perflog.logger.log_message_format</b><br>
 *   Allows to define custom message format. See {UuApp::Perflog::MessageFormatter#message_format} for details.
 */
var Logger = /*#__PURE__*/function () {
  function Logger() {
    _classCallCheck(this, Logger);
  }
  _createClass(Logger, null, [{
    key: "setMessageFormat",
    value:
    /**
     * Overrides default message format.
     * @param messageFormat Format string.
     */
    function setMessageFormat(messageFormat) {
      Logger._getLogger().setMessageFormat(messageFormat);
    }

    /**
     * Logging severity threshold. Possible values are:
     # * OFF - Logger is disabled.
     # * INFO - Logger logs data of first level measured sections only.
     # * DEBUG - Logger logs data of all measured sections.
     * @param level Log level.
     */
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      Logger._getLogger().setLevel(level);
    }

    /**
     * Checks if performance log is enabled (log level is set to anything other than "OFF").
     * @returns {boolean} True if log is enabled, else false.
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return Logger._getLogger().getLevel() < LogLevel.OFF;
    }

    /**
     * Checks verbosity of performance log. If log is in verbose mode (log
     * level is set to "DEBUG") it prints data of all measured sections. Else
     * it logs only first level sections.
     * @returns {boolean} True if perfomance log is in verbose mode, else false.
     */
  }, {
    key: "isVerbose",
    value: function isVerbose() {
      return Logger._getLogger().getLevel() < LogLevel.INFO;
    }

    /**
     * Transforms given section to log message and prints it.
     * @param section Section to be logged.
     */
  }, {
    key: "log",
    value: function log(section) {
      if (!section) {
        return;
      }
      Logger._getLogger().log(section);
    }
  }, {
    key: "_getLogger",
    value: function _getLogger() {
      if (!this._logger) {
        var formatter = new MessageFormatter();
        var outputter = new StdoutOutputter(formatter);
        var logger = new BaseLogger(LOGGER_NAME, outputter);
        if (!Config.get(`${LOGGER_NAME.toLowerCase()}.log_level`, false)) {
          Config.set(`${LOGGER_NAME.toLowerCase()}.log_level`, "OFF");
        }
        LoggerFactory.configure(logger, false);
        this._logger = logger;
      }
      return this._logger;
    }
  }]);
  return Logger;
}();
module.exports = Logger;

/***/ }),

/***/ "../node_modules/uu_appg01_core-perflog/src/message-formatter.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _get = (__webpack_require__("../node_modules/@babel/runtime/helpers/get.js")["default"]);
var _getPrototypeOf = (__webpack_require__("../node_modules/@babel/runtime/helpers/getPrototypeOf.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var BaseMessageFormatter = (__webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js").MessageFormatter);
var DEFAULT_MESSAGE_FORMAT = '[%d] PRFLG {"id":"%i","name":"%n","attributes":%a,"checkpoints":%c,"start":"%t","duration":"%D"}';

/**
 * Default log message formatter used by Perflog logger.
 */
var MessageFormatter = /*#__PURE__*/function (_BaseMessageFormatter) {
  _inherits(MessageFormatter, _BaseMessageFormatter);
  var _super = _createSuper(MessageFormatter);
  function MessageFormatter() {
    _classCallCheck(this, MessageFormatter);
    return _super.call(this, DEFAULT_MESSAGE_FORMAT, null, null);
  }

  /**
   * Sets format of performance log message. Following tags are supported:
   * * <b>%%</b> - Escaped percent tag.
   * * <b>%a</b> - Section attributes in JSON format.
   * * <b>%c</b> - Section checkpoints in JSON format.
   * * <b>%C</b> - Full logger MDC in JSON format.
   * * <b>%d</b> - Date and time.
   * * <b>%D</b> - Section duration in nanos.
   * * <b>%f</b> - Section finish date and time.
   * * <b>%i</b> - Section ID.
   * * <b>%n</b> - Section name.
   * * <b>%t</b> - Section start date and time.
   * * <b>%{ KEY }a</b> - Section attribute with name KEY.
   * * <b>%{ KEY }c</b> - Duration of particular checkpoint with name KEY.
   * * <b>%{ KEY }C</b> - Custom attribute from logger MDC with name KEY.
   * * <b>%{ FMT }d</b> - Date and time in format matching FMT.
   * * <b>%{ FMT }f</b> - Section finish date and time in format matching FMT.
   * * <b>%{ ELM }i</b> - Section ID part, ELM = trace|parent|child|level.
   * * <b>%{ FMT }t</b> - Section start date and time in format matching FMT.
   * @param messageFormat Message format.
   */
  _createClass(MessageFormatter, [{
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      _get(_getPrototypeOf(MessageFormatter.prototype), "setMessageFormat", this).call(this, messageFormat);
    }
  }, {
    key: "_processMessageFormatTag",
    value: function _processMessageFormatTag(tag, opts) {
      var result;
      switch (tag) {
        case "a":
          if (opts) {
            // TODO Format date if needed
            result = `message.getAttribute("${opts}")`;
          } else {
            result = "Json.stringify(message.getAttributes())";
          }
          break;
        case "c":
          if (opts) {
            result = `message.getCheckpoint("${opts}")`;
          } else {
            result = "Json.stringify(message.getCheckpoints())";
          }
          break;
        case "C":
          if (opts) {
            // TODO Format date if needed
            result = `LoggerMDC.get("${opts}")`;
          } else {
            result = "LoggerMDC.toJson()";
          }
          break;
        case "d":
          // TODO Format date
          result = "datetime.toISOString()";
          break;
        case "D":
          result = "message.getDuration()";
          break;
        case "f":
          // TODO Format date
          result = "message.getFinish() ? message.getFinish().toISOString() : null";
          break;
        case "i":
          switch (opts) {
            case /trace/i:
              result = "message.getId().getTraceId()";
              break;
            case /parent/i:
              result = "message.getId().getParentId()";
              break;
            case /child/i:
              result = "message.getId().getId()";
              break;
            case /level/i:
              result = "message.getLevel()";
              break;
            default:
              result = "message.getId().toString()";
          }
          break;
        case "I":
          // TODO Thread ID
          result = '"-"';
          break;
        case "n":
          result = "message.getName()";
          break;
        case "t":
          // TODO Format date
          result = "message.getStart().toISOString()";
          break;
      }
      return result;
    }
  }]);
  return MessageFormatter;
}(BaseMessageFormatter);
module.exports = MessageFormatter;

/***/ }),

/***/ "../node_modules/uu_appg01_core-perflog/src/perflog.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  ContextStore = _require.ContextStore,
  Config = _require.Config;
var Section = __webpack_require__("../node_modules/uu_appg01_core-perflog/src/section.browser.js");
var SectionId = __webpack_require__("../node_modules/uu_appg01_core-perflog/src/section-id.js");
var Logger = __webpack_require__("../node_modules/uu_appg01_core-perflog/src/logger.js");
var localStorageAvailable;
try {
  var check = localStorage;
  localStorageAvailable = !!check;
} catch (e) {
  localStorageAvailable = false;
}
var CTX_STORE_NAME = "uuapp.perflog";
var SECTION_FILTER_PARAM = "uuapp.perflog.section_filter";
var TRACE_ID_PRARAM = "uu_app_client_trace_id";
var traceId = localStorageAvailable && localStorage.getItem(TRACE_ID_PRARAM);
if (!traceId) {
  traceId = ("00000000" + Math.floor(Math.random() * 4294967295).toString(16)).slice(-8);
  localStorageAvailable && localStorage.setItem(TRACE_ID_PRARAM, traceId);
}
var Perflog = /*#__PURE__*/function () {
  function Perflog() {
    _classCallCheck(this, Perflog);
  }
  _createClass(Perflog, null, [{
    key: "initialize",
    value:
    // In browser, section nesting is not supported

    function initialize() {
      var parentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var fn = arguments.length > 1 ? arguments[1] : undefined;
      if (typeof parentId === "function") {
        fn = parentId;
        parentId = null;
      }
      return ContextStore.create(CTX_STORE_NAME, function () {
        var ctxStore = ContextStore.get(CTX_STORE_NAME);
        if (parentId) {
          parentId = SectionId.create(parentId);
        } else {
          parentId = parentId = SectionId.create(traceId, traceId);
        }
        ctxStore.set("parentId", parentId);
        return fn();
      });
    }
  }, {
    key: "measureSection",
    value: function measureSection() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var fn = arguments.length > 2 ? arguments[2] : undefined;
      if (typeof name === "function") {
        fn = name;
        name = null;
        attributes = {};
      }
      if (typeof name === "object") {
        fn = attributes;
        attributes = name;
        name = null;
      }
      if (typeof attributes === "function") {
        fn = attributes;
        attributes = {};
      }
      var sectionWrapper = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var ctxStore, parentId, isTraceable, sectionId, section, result;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                ctxStore = ContextStore.get(CTX_STORE_NAME);
                parentId = ctxStore.get("parentId"); // Section is logged in case verbose logging is enabled or
                // if section matches filter regular expression.
                isTraceable = Perflog._isTraceable(name); // In browser all sections have level 0 (they are not nested).
                sectionId = isTraceable ? new SectionId(parentId.getTraceId(), parentId.getId(), -1) : parentId;
                section = new Section(sectionId, name, attributes, isTraceable);
                _context.prev = 5;
                _context.next = 8;
                return fn(section);
              case 8:
                result = _context.sent;
                section.close();
                return _context.abrupt("return", result);
              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                section.close();
                throw _context.t0;
              case 17:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[5, 13]]);
        }));
        return function sectionWrapper() {
          return _ref.apply(this, arguments);
        };
      }();
      var ctxStore = ContextStore.get(CTX_STORE_NAME);
      if (ctxStore) {
        return ctxStore.fork(sectionWrapper);
      } else {
        return Perflog.initialize(sectionWrapper);
      }
    }
  }, {
    key: "setSectionFilter",
    value: function setSectionFilter(filter) {
      Config.set(SECTION_FILTER_PARAM, filter || ".*");
    }
  }, {
    key: "_isTraceable",
    value: function _isTraceable(name) {
      if (Logger.isVerbose()) {
        return true;
      } else {
        var secFilter = Config.get(SECTION_FILTER_PARAM);
        if (secFilter) {
          return new RegExp(secFilter).test(name);
        } else {
          return false;
        }
      }
    }
  }]);
  return Perflog;
}();
module.exports = Perflog;

/***/ }),

/***/ "../node_modules/uu_appg01_core-perflog/src/section-id.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// TODO Generate trace ID based on fingerprint
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var TRACE_ID_PREFIX = ("0000" + Math.floor(Math.random() * 65535).toString(16)).slice(-4);

/**
 * Object representation of Perflog mesured section ID.
 */
var SectionId = /*#__PURE__*/function () {
  /**
   * Creates new section ID instance.
   * @param traceId Trace ID.
   * @param parentId Parent section ID.
   * @param childId Child section ID.
   * @param level Nesting level. In case childId
   *   is given, level is considered as "child level". In case
   *   childId is not set, level is considered as "parent
   *   level" and thus will be increased in new section ID.
   */
  function SectionId(traceId, parentId) {
    var childId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    _classCallCheck(this, SectionId);
    if (typeof childId === "number") {
      level = childId;
      childId = null;
    }
    this._traceId = traceId || TRACE_ID_PREFIX + ("0000" + Math.floor(Math.random() * 65535).toString(16)).slice(-4);
    this._parentId = parentId || this._traceId;
    this._id = childId || ("00000000" + Math.floor(Math.random() * 4294967295).toString(16)).slice(-8);
    if (typeof level === "number") {
      this._level = childId ? level : level + 1;
    } else {
      this._level = 0;
    }
    this._qualifiedId = `${this._traceId}-${this._parentId}-${this._id}-${("0000" + this._level.toString()).slice(-4)}`;
  }

  /**
   * Trace ID shared by all sections within request scope (spanned
   * across clients and servers). For root section this ID is same
   * as parent ID.
   * @returns {*|string} Trace ID.
   */
  _createClass(SectionId, [{
    key: "getTraceId",
    value: function getTraceId() {
      return this._traceId;
    }

    /**
     * ID of parent section. For root section this ID is same as
     * trace ID.
     * @returns {*|string} Parent ID.
     */
  }, {
    key: "getParentId",
    value: function getParentId() {
      return this._parentId;
    }

    /**
     * ID of current section. This ID will be used as parent ID for
     * all nested sections.
     * @returns {*|string} Child/section ID.
     */
  }, {
    key: "getId",
    value: function getId() {
      return this._id;
    }

    /**
     * Section nesting level. For root section level is 0.
     * @returns {*|number} Nesting level.
     */
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._level;
    }

    /**
     * Returns formatted qualified section ID.
     * @returns {string} Formatted qualified section ID.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this._qualifiedId;
    }
  }], [{
    key: "create",
    value:
    /**
     * Creates new section ID from qualified section ID.
     * @param qualifiedId Qualified section ID.
     * @returns {SectionId} Section ID.
     */
    function create(qualifiedId) {
      var match;
      if (!qualifiedId) {
        return new SectionId(null, null);
      } else if (match = /^([^-]+)-([^-]+)-([^-]+)-([^-]+)$/.exec(qualifiedId.toString())) {
        return new SectionId(match[1], match[2], match[3], Number(match[4] || 0));
      } else {
        var traceId = qualifiedId.toString().replace(/-/g, "");
        return new SectionId(traceId, traceId);
      }
    }
  }]);
  return SectionId;
}();
module.exports = SectionId;

/***/ }),

/***/ "../node_modules/uu_appg01_core-perflog/src/section.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Logger = __webpack_require__("../node_modules/uu_appg01_core-perflog/src/logger.js");

/**
 * Object provided by {UuApp::Perflog} representing
 * measured section.
 */
var Section = /*#__PURE__*/function () {
  /**
   * Creates new instance of section.
   * @param id Section ID.
   * @param name Section name.
   * @param attributes Section attributes.
   * @param traceable Flag if section is traceable
   *   and thus should be visible in performance log.
   */
  function Section(id, name, attributes, traceable) {
    _classCallCheck(this, Section);
    this._id = id;
    this._name = name || "";
    this._attributes = attributes || {};
    this._traceable = traceable;
    this._checkpoints = {};
    this._start = new Date();
    this._startRaw = window.performance.now();
  }

  /**
   * Section ID.
   * @returns {*} Section ID.
   */
  _createClass(Section, [{
    key: "getId",
    value: function getId() {
      return this._id;
    }

    /**
     * User defined section name.
     * @returns {*} User defined section name.
     */
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }

    /**
     * Sets user defined section attribute.
     * @param name Attribute name.
     * @param value Attribute value.
     */
  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      this.getAttributes()[name] = value;
    }

    /**
     * User defined section attributes.
     * @returns {*|{}} User defined section attributes.
     */
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this._attributes;
    }

    /**
     * Returns user defined section attribute.
     * @param name Attribute name.
     * @returns {*} Attribute value.
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.getAttributes()[name];
    }

    /**
     * Sets section checkpoint (important milestone of section processing
     * which is not important enough to create nested measured section).
     * Name of checkpoint must be unique in scope of section.
     * @param name Checkpoint name.
     */
  }, {
    key: "setCheckpoint",
    value: function setCheckpoint(name) {
      this._checkpoints[name] = Math.round((window.performance.now() - this._startRaw) * 1000000);
    }

    /**
     * Set of currently processed checkpoints. Returned as
     * object where key is checkpont name, value is duration
     * (in nanoseconds) elapsed from section start.
     * @returns {{}|*} Processed checkpoints.
     */
  }, {
    key: "getCheckpoints",
    value: function getCheckpoints() {
      return this._checkpoints;
    }

    /**
     * Returns duration of particular checkpoint (in nanoseconds).
     * @param name Checkpoint name
     * @returns {number|*} Checkpoint duration.
     */
  }, {
    key: "getCheckpoint",
    value: function getCheckpoint(name) {
      return this.getCheckpoints()[name];
    }

    /**
     * Section start time.
     * @returns {Date} Section start time.
     */
  }, {
    key: "getStart",
    value: function getStart() {
      return this._start;
    }

    /**
     * Section finish time. Returns null until section is closed.
     * @returns {Date} Section finish time.
     */
  }, {
    key: "getFinish",
    value: function getFinish() {
      return this._finish;
    }

    /**
     * Section duration (in nanoseconds). Returns null until
     * section is closed.
     * @returns {number|*} Section duration.
     */
  }, {
    key: "getDuration",
    value: function getDuration() {
      return this._duration;
    }

    /**
     * Closes section and publishes section data via Perflog logger
     * (based on Perflog logger verbosity configuration).
     */
  }, {
    key: "close",
    value: function close() {
      if (this._finish) {
        return;
      }
      this._finish = new Date();
      this._duration = Math.round((window.performance.now() - this._startRaw) * 1000000);
      if (this._traceable) {
        Logger.log(this);
      }
    }
  }]);
  return Section;
}();
module.exports = Section;

/***/ }),

/***/ "../node_modules/uu_appg01_core-uri/src/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Uri = __webpack_require__("../node_modules/uu_appg01_core-uri/src/uri.js");
var UriBuilder = __webpack_require__("../node_modules/uu_appg01_core-uri/src/uri-builder.js");
var InvalidUriPartError = __webpack_require__("../node_modules/uu_appg01_core-uri/src/invalid-uri-part-error.js");
module.exports = {
  Uri,
  UriBuilder,
  InvalidUriPartError
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-uri/src/invalid-uri-part-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var InvalidUriPartError = /*#__PURE__*/function (_BaseError) {
  "use strict";

  _inherits(InvalidUriPartError, _BaseError);
  var _super = _createSuper(InvalidUriPartError);
  function InvalidUriPartError(partName, value, expected) {
    var _this;
    _classCallCheck(this, InvalidUriPartError);
    var message = "";
    if (typeof expected !== "string") {
      expected = expected === String ? "string" : expected;
      message = `Value "${value}" of URI part [${partName}] must be ${expected} but its typeof is ${typeof value}.`;
    } else {
      message = `Value "${value}" of URI part [${partName}] does not match regular expression /${expected.replace(/\//g, "\\/")}/.`;
    }
    _this = _super.call(this, message || "Unexpected error occurred during operation execution.", null);
    _this.code = "uu-app-uri/InvalidUriPartError";
    return _this;
  }
  return _createClass(InvalidUriPartError);
}(BaseError);
module.exports = InvalidUriPartError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-uri/src/uri-builder.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var Uri = __webpack_require__("../node_modules/uu_appg01_core-uri/src/uri.js");
var UriParser = __webpack_require__("../node_modules/uu_appg01_core-uri/src/uri-parser.js");

/**
 * Creates an instance of UriBuilder.
 *
 * @class UuApp.Uri.UriBuilder
 * @classdesc
 * Class for building uuUri. Typical usage:
 *
 *     // starting from current location
 *     let uriBuilder = UriBuilder.parse(location.protocol + "//" + location.host + location.pathname);
 *     let uri1 = uriBuilder.setUseCase("/sys/init").setParameters({ p1: "v1" }).toUri();
 *     console.log(uri1.toString()); // <gateway>/<product>/<workspace>/sys/init?p1=v1
 *
 *     // starting anew, using gateway from main HTML page location
 *     let gateway = location.origin || (location.protocol + "//" + location.host);
 *     let uri2 = UriBuilder.set({
 *       gateway: gateway,
 *       product: "uu-demoapp-main",
 *       workspace: "tid123-awid456",
 *       parameters: { p1: "v1", p2: "v2" }
 *     }).toUri(); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p1=v1&p2=v2
 *
 *     // parameters example
 *     let uriBuilder = UriBuilder.parse(uri2);
 *     let uri3 = uriBuilder.deleteParameter("p1").mergeParameters({ p3: "v3" }).toUri();
 *     console.log(uri3.toString()); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p2=v2&p3=v3
 *
 * @see {@link UuApp.Uri.UriBuilder.parse UriBuilder.parse}
 * @see {@link UuApp.Uri.UriBuilder.set UriBuilder.set}
 * @see {@link UuApp.Uri.UriBuilder#toUri UriBuilder#toUri}
 */
var UriBuilder = /*#__PURE__*/function () {
  "use strict";

  function UriBuilder() {
    _classCallCheck(this, UriBuilder);
    this._parameters = {};
  }

  /**
   * Sets query parameter with given name to given value.
   *
   * @param {string} name The parameter name.
   * @param {string} value The parameter value.
   * @return This UriBuilder instance for chaining operations.
   * @method UuApp.Uri.UriBuilder#setParameter
   */
  _createClass(UriBuilder, [{
    key: "setParameter",
    value: function setParameter(name, value) {
      UriParser.validateParameterName(name);
      UriParser.validateParameterValue(value);
      if (this._parameters.hasOwnProperty(name)) {
        if (Array.isArray(this._parameters[name])) {
          this._parameters[name].push(value);
        } else {
          this._parameters[name] = [this._parameters[name], value];
        }
      } else {
        this._parameters[name] = value;
      }
      return this;
    }

    /**
     * Removes query parameter with given name.
     *
     * @param {string} name The parameter name.
     * @return This UriBuilder instance for chaining operations.
     * @method UuApp.Uri.UriBuilder#deleteParameter
     */
  }, {
    key: "deleteParameter",
    value: function deleteParameter(name) {
      UriParser.validateParameterName(name);
      delete this._parameters[name];
      return this;
    }

    /**
     * Removes all query parameters.
     *
     * @return This UriBuilder instance for chaining operations.
     * @method UuApp.Uri.UriBuilder#clearParameters
     */
  }, {
    key: "clearParameters",
    value: function clearParameters() {
      this._parameters = {};
      return this;
    }

    /**
     * Parses URI string (or Uri instance) and resets all fields of this UriBuilder
     * to parsed values.
     *
     * @param {(string|UuApp.Uri.Uri)} uriObj URI to parse.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#parse
     */
  }, {
    key: "parse",
    value: function parse(uriObj) {
      var uri = typeof uriObj === "string" ? UriParser.parse(uriObj, this).toUri() : uriObj;
      this.setGateway(uri.getGateway());
      this.setProduct(uri.getProduct());
      this.setWorkspace(uri.getWorkspace());
      this.setUseCase(uri.getUseCase());
      this.setParameters(uri.getParameters());
      return this;
    }

    /**
     * Equivalent to <code>new UriBuilder().parse(uri)</code>.
     *
     * @param {(string|UuApp.Uri.Uri)} uri URI to parse.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.parse
     * @see UuApp.Uri.UriBuilder#parse
     */
  }, {
    key: "format",
    value: function format() {
      return UriBuilder.format(this.toUri());
    }
  }, {
    key: "toString",
    value: function toString() {
      return UriBuilder.format(this.toUri());
    }

    /**
     * Returns Uri instance from current values of this UriBuilder.
     *
     * @return {UuApp.Uri.Uri} Uri instance from current values of this UriBuilder.
     * @method UuApp.Uri.UriBuilder#toUri
     */
  }, {
    key: "toUri",
    value: function toUri() {
      var missing = [];
      if (this.getScheme() == null && (this.getHostname() != null || this.getPort() != null)) missing.push("scheme");
      if (this.getHostname() == null && (this.getScheme() != null || this.getPort() != null)) missing.push("hostname");
      if (this.getVendor() == null && (this.getSubApp() != null || this.getSpp() != null)) missing.push("vendor");
      if (this.getApp() == null) missing.push("app");
      if (this.getSubApp() == null && this.getSpp() != null) missing.push("subApp");
      if (this.getAwid() == null) missing.push("awid");
      if (missing.length) throw new BaseError("Missing Uri parts: " + missing.join(", "));
      return new Uri(this.getScheme(), this.getHostname(), this.getPort(), this.getVendor(), this.getApp(), this.getSubApp(), this.getSpp(), this.getTid(), this.getAwid(), this.getUseCase(), this.getParameters());
    }

    /**
     * Replaces current path with specified absolute path (or adds a relative path to the current path) for this UriBuilder.
     * Works exactly the same way as {@link UuApp.Uri.Uri#join Uri#join} but returns UriBuilder instead of Uri.
     *
     * @param {...string} path Absolute or relative paths to replace / add.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#join
     * @see UuApp.Uri.Uri#join
     * @example
     *  // replace path with an absolute path
     *  let srcUri = "https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1";
     *  let uriBuilder = UriBuilder.parse(srcUri);
     *  uriBuilder.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
     *
     *  // add relative paths
     *  let uriBuilder = UriBuilder.parse(srcUri);
     *  uriBuilder.join("./sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init
     *  let uriBuilder = UriBuilder.parse(srcUri);
     *  uriBuilder.join("+/sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init
     */
  }, {
    key: "join",
    value: function join( /* ... */
    ) {
      var uri = this.toUri();
      return this.parse(uri.join.apply(uri, arguments));
    }

    /**
     * Sets fields of this UriBuilder to given values.
     *
     * @param {...Object} fieldMap Object(s) containing fields to set to this UriBuilder. If more objects are given,
     *   fields in latter ones override fields in former ones.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#set
     * @example
     *   // replace spp, awid & remove useCase
     *   let resUri = UriBuilder.parse(someUri).set({
     *     spp: "async",
     *     awid: "12345",
     *     useCase: null
     *   }).toUri();
     *
     *   // multiple settings
     *   let defaults = { gateway: "...", product: "uu-demoapp-main", tid: "0", awid: "0" };
     *   let resUri = UriBuilder.set(defaults, {
     *     tid: "12f34", // overrides the one from "defaults" variable
     *     useCase: "/getData"
     *   }).toUri();
     */
  }, {
    key: "set",
    value: function set( /* ... */
    ) {
      for (var i = 0; i < arguments.length; ++i) {
        var hash = arguments[i];
        if (!hash) continue;
        if (typeof hash !== "object") continue;
        for (var k in hash) {
          this["set" + k.replace(/^./, function (m) {
            return m.toUpperCase();
          })](hash[k]);
        } // this[k] = hash[k];
      }

      return this;
    }

    /**
     * Equivalent to <code>new UriBuilder().set(...)</code>.
     *
     * @param {...Object} fieldMap Object(s) containing fields to set to the UriBuilder. If more objects are given,
     *   fields in latter ones override fields in former ones.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.set
     * @see UuApp.Uri.UriBuilder#set
     */
  }, {
    key: "mergeParameters",
    value:
    /**
     * Merges (replaces / adds) provided parameters into the ones already present
     * in this UriBuilder.
     *
     * @param {Object} map Map with parameters to merge.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#mergeParameters
     */
    function mergeParameters(value) {
      if (value) for (var k in value) this.setParameter(k, value[k]);
      return this;
    }

    //---------------------------------------------
  }, {
    key: "getScheme",
    value: function getScheme() {
      return this._scheme;
    }
  }, {
    key: "scheme",
    get: function get() {
      return this.getScheme();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("scheme");
    }
  }, {
    key: "getHostname",
    value: function getHostname() {
      return this._hostname;
    }
  }, {
    key: "hostname",
    get: function get() {
      return this.getHostname();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("hostname");
    }
  }, {
    key: "getVendor",
    value: function getVendor() {
      return this._vendor;
    }
  }, {
    key: "vendor",
    get: function get() {
      return this.getVendor();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("vendor");
    }
  }, {
    key: "getApp",
    value: function getApp() {
      return this._app;
    }
  }, {
    key: "app",
    get: function get() {
      return this.getApp();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("app");
    }
  }, {
    key: "getSubApp",
    value: function getSubApp() {
      return this._subApp;
    }
  }, {
    key: "subApp",
    get: function get() {
      return this.getSubApp();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("subApp");
    }
  }, {
    key: "getSpp",
    value: function getSpp() {
      return this._spp;
    }
  }, {
    key: "spp",
    get: function get() {
      return this.getSpp();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("spp");
    }
  }, {
    key: "getTid",
    value: function getTid() {
      return this._tid;
    }
  }, {
    key: "tid",
    get: function get() {
      return this.getTid();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("tid");
    }
  }, {
    key: "getAwid",
    value: function getAwid() {
      return this._awid;
    }
  }, {
    key: "awid",
    get: function get() {
      return this.getAwid();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("awid");
    }

    /**
     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
     * Note that each access returns new copy of the map (to prevent modification of the map without
     * validating the values / keys).
     *
     *     // GOOD
     *     uriBuilder.setParameter("myParam", "value");
     *
     * @name UuApp.Uri.UriBuilder#parameters
     */
  }, {
    key: "getParameters",
    value: function getParameters() {
      return Object.assign({}, this._parameters);
    }
  }, {
    key: "parameters",
    get: function get() {
      return this.getParameters();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("parameters");
    }

    /**
     * Equivalent to <code>new UriBuilder().setScheme(value)</code>.
     *
     * @param {string} value Scheme to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setScheme
     * @see UuApp.Uri.UriBuilder#setScheme
     */
  }, {
    key: "setScheme",
    value: function setScheme(value) {
      // "instance" method
      if (value != null) UriParser.validateScheme(value);
      this._scheme = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for scheme.
     *
     * @param {string} value Scheme to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setScheme
     */
  }, {
    key: "setHostname",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setHostname(value)</code>.
     *
     * @param {string} value Hostname to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setHostname
     * @see UuApp.Uri.UriBuilder#setHostname
     */
    function setHostname(value) {
      // "instance" method
      if (value != null) UriParser.validateHostname(value);
      this._hostname = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for hostname.
     *
     * @param {string} value Hostname to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setHostname
     */
  }, {
    key: "setVendor",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setVendor(value)</code>.
     *
     * @param {string} value Vendor to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setVendor
     * @see UuApp.Uri.UriBuilder#setVendor
     */
    function setVendor(value) {
      // "instance" method
      if (value != null) UriParser.validateVendor(value);
      this._vendor = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for vendor.
     *
     * @param {string} value Vendor to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setVendor
     */
  }, {
    key: "setApp",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setApp(value)</code>.
     *
     * @param {string} value Application to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setApp
     * @see UuApp.Uri.UriBuilder#setApp
     */
    function setApp(value) {
      // "instance" method
      if (value != null) UriParser.validateApp(value);
      this._app = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for application.
     *
     * @param {string} value Application to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setApp
     */
  }, {
    key: "setSubApp",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setSubApp(value)</code>.
     *
     * @param {string} value Sub-application to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setSubApp
     * @see UuApp.Uri.UriBuilder#setSubApp
     */
    function setSubApp(value) {
      // "instance" method
      if (value != null) UriParser.validateSubApp(value);
      this._subApp = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for sub-application.
     *
     * @param {string} value Sub-application to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setSubApp
     */
  }, {
    key: "setSpp",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setSpp(value)</code>.
     *
     * @param {string} value SPP to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setSpp
     * @see UuApp.Uri.UriBuilder#setSpp
     */
    function setSpp(value) {
      // "instance" method
      if (value != null) UriParser.validateSpp(value);
      this._spp = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for SPP.
     *
     * @param {string} value SPP to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setSpp
     */
  }, {
    key: "setTid",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setTid(value)</code>.
     *
     * @param {string} value Tenant ID to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setTid
     * @see UuApp.Uri.UriBuilder#setTid
     */
    function setTid(value) {
      // "instance" method
      if (value != null) UriParser.validateTid(value);
      this._tid = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for tenant ID.
     *
     * @param {string} value Tenant ID to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setTid
     */
  }, {
    key: "setAwid",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setAwid(value)</code>.
     *
     * @param {string} value awid to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setAwid
     * @see UuApp.Uri.UriBuilder#setAwid
     */
    function setAwid(value) {
      // "instance" method
      if (value != null) UriParser.validateAwid(value);
      this._awid = value != null ? value : null;
      return this;
    }

    /**
     * Chainable setter for awid.
     *
     * @param {string} value awid to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setAwid
     */
  }, {
    key: "setParameters",
    value:
    /**
     * Equivalent to <code>new UriBuilder().setParameters(value)</code>.
     *
     * @param {string} value Parameters to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setParameters
     * @see UuApp.Uri.UriBuilder#setParameters
     */
    function setParameters(value) {
      // "instance" method
      this._parameters = {};
      if (value) for (var k in value) this.setParameter(k, value[k]);
      return this;
    }

    /**
     * Chainable setter for parameters (replaces all parameters).
     *
     * @param {string} value Parameters to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setParameters
     */
  }, {
    key: "getPort",
    value: function getPort() {
      return this._port != null ? Number(this._port) : this._port;
    }
  }, {
    key: "port",
    get: function get() {
      return this.getPort();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("port");
    }

    /**
     * Equivalent to <code>new UriBuilder().setPort(value)</code>.
     *
     * @param {(string|number)} value Port to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setPort
     * @see UuApp.Uri.UriBuilder#setPort
     */
  }, {
    key: "setPort",
    value: function setPort(value) {
      if (value != null) UriParser.validatePort(value);
      this._port = value != null ? value : null;
      return this;
    }
  }, {
    key: "getGateway",
    value: function getGateway() {
      return UriBuilder.formatGateway(this._scheme, this._hostname, this._port);
    }
  }, {
    key: "gateway",
    get: function get() {
      return this.getGateway();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("gateway");
    }

    /**
     * Equivalent to <code>new UriBuilder().setGateway(value)</code>.
     *
     * @param {string} value Gateway to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setGateway
     * @see UuApp.Uri.UriBuilder#setGateway
     */
  }, {
    key: "setGateway",
    value: function setGateway(value) {
      var obj = value != null ? UriParser.parseGateway(value) : null;
      this._scheme = obj && obj.scheme || null;
      this._hostname = obj && obj.hostname || null;
      this._port = obj && obj.port != null ? obj.port : null;
      return this;
    }
  }, {
    key: "getProduct",
    value: function getProduct() {
      return UriBuilder.formatProduct(this._vendor, this._app, this._subApp, this._spp);
    }
  }, {
    key: "product",
    get: function get() {
      return this.getProduct();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("product");
    }

    /**
     * Equivalent to <code>new UriBuilder().setProduct(value)</code>.
     *
     * @param {string} value Product to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setProduct
     * @see UuApp.Uri.UriBuilder#setProduct
     */
  }, {
    key: "setProduct",
    value: function setProduct(value) {
      var obj = value ? UriParser.parseProduct(value) : {};
      this._vendor = obj.vendor || null;
      this._app = obj.app || null;
      this._subApp = obj.subApp || null;
      this._spp = obj.spp || null;
      return this;
    }
  }, {
    key: "getWorkspace",
    value: function getWorkspace() {
      return UriBuilder.formatWorkspace(this._tid, this._awid);
    }
  }, {
    key: "workspace",
    get: function get() {
      return this.getWorkspace();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("workspace");
    }

    /**
     * Chainable setter for workspace ID.
     *
     * @param {string} value Workspace ID to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setWorkspace
     */
  }, {
    key: "setWorkspace",
    value: function setWorkspace(value) {
      var obj = value ? UriParser.parseWorkspace(value) : {};
      this._tid = obj.tid || null;
      this._awid = obj.awid || null;
      return this;
    }
  }, {
    key: "getUseCase",
    value: function getUseCase() {
      return this._useCase;
    }
  }, {
    key: "useCase",
    get: function get() {
      return this.getUseCase();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet("useCase");
    }

    /**
     * Equivalent to <code>new UriBuilder().setUseCase(value)</code>.
     *
     * @param {string} value Use case to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setUseCase
     * @see UuApp.Uri.UriBuilder#setUseCase
     */
  }, {
    key: "setUseCase",
    value: function setUseCase(value) {
      if (value != null) {
        value = value.replace(/(^\/+|\/+$)/g, "");
        if (value) {
          UriParser.validateUseCase(encodeURIComponent(value));
        } else {
          value = null;
        }
      }
      this._useCase = value;
      return this;
    }
  }, {
    key: "throwOnSet",
    value: function throwOnSet(attr) {
      throw new BaseError(`
Setting of "${attr}" and other properties via property access 
is prohibited with UriBuilder to prevent typos. 
Use get${attr[0].toUpperCase()}${attr.substr(1)}() and 
set${attr[0].toUpperCase()}${attr.substr(1)}(value) instead.
`);
    }
  }], [{
    key: "parse",
    value: function parse(uri) {
      return new UriBuilder().parse(uri);
    }
  }, {
    key: "format",
    value: function format(uri) {
      return UriParser.format(uri);
    }
  }, {
    key: "formatGateway",
    value: function formatGateway(scheme, hostname, port) {
      return UriParser.formatGateway(scheme, hostname, port);
    }
  }, {
    key: "formatProduct",
    value: function formatProduct(vendor, app, subApp, spp) {
      return UriParser.formatProduct(vendor, app, subApp, spp);
    }
  }, {
    key: "formatWorkspace",
    value: function formatWorkspace(tid, awid) {
      return UriParser.formatWorkspace(tid, awid);
    }
  }, {
    key: "formatParameters",
    value: function formatParameters(params) {
      return UriParser.formatParameters(params);
    }
  }, {
    key: "set",
    value: function set( /* ... */
    ) {
      var builder = new UriBuilder();
      return builder.set.apply(builder, arguments);
    }

    /**
     * Equivalent to <code>new UriBuilder().setParameter(name, value)</code>.
     *
     * @param {string} name The parameter name.
     * @param {string} value The parameter value.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setParameter
     * @see UuApp.Uri.UriBuilder#setParameter
     */
  }, {
    key: "setParameter",
    value: function setParameter(name, value) {
      return new UriBuilder().setParameter(name, value);
    }
  }, {
    key: "setScheme",
    value: function setScheme(value) {
      // "static" method
      return new UriBuilder().setScheme(value);
    }
  }, {
    key: "setHostname",
    value: function setHostname(value) {
      // "static" method
      return new UriBuilder().setHostname(value);
    }

    /**
     * Chainable setter for port.
     *
     * @param {string} value Port to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setPort
     */
  }, {
    key: "setPort",
    value: function setPort(value) {
      // "static" method
      return new UriBuilder().setPort(value);
    }

    /**
     * Chainable setter for gateway.
     *
     * @param {string} value Gateway to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setGateway
     */
  }, {
    key: "setGateway",
    value: function setGateway(value) {
      // "static" method
      return new UriBuilder().setGateway(value);
    }
  }, {
    key: "setVendor",
    value: function setVendor(value) {
      // "static" method
      return new UriBuilder().setVendor(value);
    }
  }, {
    key: "setApp",
    value: function setApp(value) {
      // "static" method
      return new UriBuilder().setApp(value);
    }
  }, {
    key: "setSubApp",
    value: function setSubApp(value) {
      // "static" method
      return new UriBuilder().setSubApp(value);
    }
  }, {
    key: "setSpp",
    value: function setSpp(value) {
      // "static" method
      return new UriBuilder().setSpp(value);
    }

    /**
     * Chainable setter for product.
     *
     * @param {string} value Product to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setProduct
     */
  }, {
    key: "setProduct",
    value: function setProduct(value) {
      // "static" method
      return new UriBuilder().setProduct(value);
    }
  }, {
    key: "setTid",
    value: function setTid(value) {
      // "static" method
      return new UriBuilder().setTid(value);
    }
  }, {
    key: "setAwid",
    value: function setAwid(value) {
      // "static" method
      return new UriBuilder().setAwid(value);
    }

    /**
     * Equivalent to <code>new UriBuilder().setWorkspace(value)</code>.
     *
     * @param {string} value Workspace to set.
     * @return New UriBuilder instance.
     * @method UuApp.Uri.UriBuilder.setWorkspace
     * @see UuApp.Uri.UriBuilder#setWorkspace
     */
  }, {
    key: "setWorkspace",
    value: function setWorkspace(value) {
      // "static" method
      return new UriBuilder().setWorkspace(value);
    }

    /**
     * Chainable setter for use case.
     *
     * @param {string} value Use case to set.
     * @return This UriBuilder instance.
     * @method UuApp.Uri.UriBuilder#setUseCase
     */
  }, {
    key: "setUseCase",
    value: function setUseCase(value) {
      // "static" method
      return new UriBuilder().setUseCase(value);
    }
  }, {
    key: "setParameters",
    value: function setParameters(value) {
      // "static" method
      return new UriBuilder().setParameters(value);
    }
  }]);
  return UriBuilder;
}();
Uri.prototype.Builder = UriBuilder;
module.exports = UriBuilder;

/***/ }),

/***/ "../node_modules/uu_appg01_core-uri/src/uri-parser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var InvalidUriPartError = __webpack_require__("../node_modules/uu_appg01_core-uri/src/invalid-uri-part-error.js");
var UNRESERVED = "[\\w\\.\\-~]";
var UNRESERVED_ENCODED = "[\\w\\.\\-~%]";
var IDENTIFIER = "[a-zA-Z0-9_]";
var SCHEME = `(${UNRESERVED}+)`;

// No reason to match IPv4 (invalid IP address is always
// matched as generic hostname - we cannot distinguish them)
// IPV4_PART = "(25[0-5]|2[0-5][0-9]|1[0-9][0-9]|[0-9][0-9]?)"
// IPV4 = "(#{IPV4_PART}(\\.#{IPV4_PART}){3})"

// Only rough validation
// see http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses

var IPV6_PART = "([0-9a-fA-F]{1,4})";
var IPV6 = `(\\[${IPV6_PART}(:(${IPV6_PART})?){1,7}\\])`;
var HOSTNAME = `(${IPV6}|${UNRESERVED}+)`;
var PORT = "(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[0-5][0-9]{4}|[1-9][0-9]{0,3})";
var GATEWAY = `(${SCHEME}://${HOSTNAME}(:${PORT})?)`;
var VENDOR = `(${IDENTIFIER}{1,32})`;
var APP = `(${IDENTIFIER}{1,32})`;
var SUB_APP = `(${IDENTIFIER}{1,32})`;
var SPP = `(${IDENTIFIER}{1,32})`;
var PRODUCT = `(?=[^/]{1,131}(?:/|$))((?:${VENDOR}\\-)?${APP}(?:\\-${SUB_APP}(?:\\-${SPP})?)?)`;
var TID = `(${IDENTIFIER}{1,32})`;
var AWID = `(${IDENTIFIER}{1,32})`;
var WORKSPACE = `(?=[^/\\?]{1,65}(?:/|\\?|$))((?:${TID}\\-)?${AWID})`;
var USE_CASE = `(${UNRESERVED_ENCODED}+(?:/${UNRESERVED_ENCODED}+)*)`;
var PARAMETER_NAME = `(?:${UNRESERVED_ENCODED}+)`;
var PARAMETER_NAME_DECODED = "(?:[\\w\\.\\-~\\[\\]]+)";
var PARAMETER_VALUE = "(?:[^=&#]*)";
var PARAMETER = `(?:(?:${PARAMETER_NAME}(?:=${PARAMETER_VALUE})?)?)`;
var PARAMETERS = `(${PARAMETER}(?:&${PARAMETER})*)`;
var URI_REGEXP = new RegExp(`^(?:${GATEWAY})?\\/${PRODUCT}\\/${WORKSPACE}(?:/${USE_CASE})?\\/?(?:\\?${PARAMETERS}?)?$`);
var SCHEME_REGEXP = new RegExp(`^${SCHEME}$`);
var HOSTNAME_REGEXP = new RegExp(`^${HOSTNAME}$`);
var PORT_REGEXP = new RegExp(`^${PORT}$`);
var GATEWAY_REGEXP = new RegExp(`^${GATEWAY}$`);
var VENDOR_REGEXP = new RegExp(`^${VENDOR}$`);
var APP_REGEXP = new RegExp(`^${APP}$`);
var SUB_APP_REGEXP = new RegExp(`^${SUB_APP}$`);
var SPP_REGEXP = new RegExp(`^${SPP}$`);
var PRODUCT_REGEXP = new RegExp(`^${PRODUCT}$`);
var TID_REGEXP = new RegExp(`^${TID}$`);
var AWID_REGEXP = new RegExp(`^${AWID}$`);
var WORKSPACE_REGEXP = new RegExp(`^${WORKSPACE}$`);
var USE_CASE_REGEXP = new RegExp(`^${USE_CASE}$`);
var PARAMETER_NAME_DECODED_REGEXP = new RegExp(`^${PARAMETER_NAME_DECODED}$`);
var UriParser = /*#__PURE__*/function () {
  "use strict";

  function UriParser() {
    _classCallCheck(this, UriParser);
  }
  _createClass(UriParser, [{
    key: "parse",
    value: function parse(str, UriBuilder) {
      if (!UriBuilder) throw new BaseError("UriBuilder must be provided.");
      var result = (str || "").match(URI_REGEXP);
      //      console.log(result);
      if (!result) throw new BaseError("Parse error - invalid uri: " + (str || ""));
      UriBuilder.setScheme(result[2]);
      UriBuilder.setHostname(result[3]);
      UriBuilder.setPort(result[10]);
      UriBuilder.setVendor(result[12]);
      UriBuilder.setApp(result[13]);
      UriBuilder.setSubApp(result[14]);
      UriBuilder.setSpp(result[15]);
      UriBuilder.setTid(result[17]);
      UriBuilder.setAwid(result[18]);
      UriBuilder.setUseCase(result[19] ? decodeURIComponent(result[19]) : null);
      var uriBuilder = UriBuilder;
      var params = result[20];
      if (params) {
        params.split("&").forEach(function (pair) {
          if (!pair) return;
          var eqlSignIdx = pair.indexOf("=");
          var k = eqlSignIdx !== -1 ? pair.substr(0, eqlSignIdx) : pair;
          var v = eqlSignIdx !== -1 ? pair.substr(eqlSignIdx + 1) : "";
          uriBuilder.setParameter(decodeURIComponent(k), decodeURIComponent(v));
        });
      }
      return uriBuilder;
    }
  }, {
    key: "format",
    value: function format(uri) {
      var parts = [];
      parts.push(`${uri.getGateway() || ""}/${uri.getProduct() || ""}/${uri.getWorkspace() || ""}`);
      var uc = uri.getUseCase();
      if (uc) {
        if (uc.charAt(0) !== "/") parts.push("/");
        parts.push(encodeURI(uc));
      }
      parts = [parts.join("").replace(/\/+$/, "")]; // remove all trailing slashes
      var params = uri.getParameters();
      var paramParts = this._createParamParts(params);
      parts = parts.concat(paramParts);
      return parts.join("");
    }
  }, {
    key: "parseGateway",
    value: function parseGateway(value) {
      if (typeof value !== "string") throw new InvalidUriPartError("gateway", value, GATEWAY_REGEXP);
      var result = value.match(GATEWAY_REGEXP);
      if (!result) throw new InvalidUriPartError("gateway", value, GATEWAY_REGEXP);
      //  console.log(result);
      //      ["http://example.com:123", "http://example.com:123", "http",
      //       "example.com", undefined, undefined,
      //       undefined, undefined, undefined,
      //       ":123", "123"]
      return {
        scheme: result[2],
        hostname: result[3],
        port: result[10]
      };
    }
  }, {
    key: "formatGateway",
    value: function formatGateway(scheme, hostname, port) {
      if (!scheme && !hostname && !port) return null;
      this.validateScheme(scheme);
      this.validateHostname(hostname);
      if (port != null) this.validatePort(port);
      return `${scheme}://${hostname}${port != null ? ":" + port : ""}`;
    }
  }, {
    key: "parseProduct",
    value: function parseProduct(value) {
      if (typeof value !== "string") throw new InvalidUriPartError("product", value, PRODUCT_REGEXP);
      var result = value.match(PRODUCT_REGEXP);
      if (!result) throw new InvalidUriPartError("product", value, PRODUCT_REGEXP);
      return {
        vendor: result[2],
        app: result[3],
        subApp: result[4],
        spp: result[5]
      };
    }
  }, {
    key: "formatProduct",
    value: function formatProduct(vendor, app, subApp, spp) {
      if (!vendor && !app && !subApp && !spp) return null;
      if (vendor) this.validateVendor(vendor);
      this.validateApp(app);
      if (subApp) this.validateSubApp(subApp);
      if (spp) this.validateSpp(spp);
      var result = [];
      if (vendor) result.push(vendor + "-");
      result.push(app);
      if (subApp) result.push("-" + subApp);
      if (spp) result.push("-" + spp);
      return result.join("");
    }
  }, {
    key: "parseWorkspace",
    value: function parseWorkspace(value) {
      if (typeof value !== "string") throw new InvalidUriPartError("workspace", value, WORKSPACE_REGEXP);
      var result = value.match(WORKSPACE_REGEXP);
      if (!result) throw new InvalidUriPartError("workspace", value, WORKSPACE_REGEXP);
      return {
        tid: result[2],
        awid: result[3]
      };
    }
  }, {
    key: "formatWorkspace",
    value: function formatWorkspace(tid, awid) {
      if (!tid && !awid) return null;
      if (tid) this.validateTid(tid);
      this.validateAwid(awid);
      var result = [];
      if (tid) result.push(tid + "-");
      result.push(awid);
      return result.join("");
    }
  }, {
    key: "formatParameters",
    value: function formatParameters(params) {
      var parts = this._createParamParts(params);
      return parts.join("");
    }
  }, {
    key: "_createParamParts",
    value: function _createParamParts(params) {
      var _this = this;
      var parts = [];
      var paramKeys = Object.keys(params);
      paramKeys.sort();
      var first = true;
      var _loop = function _loop() {
        var k = paramKeys[i];
        var value = params[k];
        if (Array.isArray(value)) {
          value.forEach(function (v) {
            _this._encodeParams(first, k, v, parts);
            first = false;
          });
        } else {
          _this._encodeParams(first, k, value, parts);
          first = false;
        }
      };
      for (var i = 0; i < paramKeys.length; i++) {
        _loop();
      }
      return parts;
    }
  }, {
    key: "_encodeParams",
    value: function _encodeParams(first, k, v, parts) {
      parts.push(first ? "?" : "&");
      parts.push(encodeURIComponent(k));
      if (v == null || v === "") return parts;
      parts.push("=");
      parts.push(encodeURIComponent(v));
      return parts;
    }
  }, {
    key: "validate",
    value: function validate(value, regExp, name) {
      if (typeof value !== "string") {
        throw new InvalidUriPartError(name, value, regExp);
      }
      if (typeof regExp === "string") {
        regExp = new RegExp("^" + regExp + "$");
      }
      if (!value.match(regExp)) {
        throw new InvalidUriPartError(name, value, regExp);
      }
    }
  }, {
    key: "validateScheme",
    value: function validateScheme(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SCHEME_REGEXP;
      this.validate(value, regExp, "scheme");
    }
  }, {
    key: "validateHostname",
    value: function validateHostname(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : HOSTNAME_REGEXP;
      this.validate(value, regExp, "hostname");
    }
  }, {
    key: "validatePort",
    value: function validatePort(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PORT_REGEXP;
      value = typeof value === "number" ? value + "" : value;
      this.validate(value, regExp, "port");
    }
  }, {
    key: "validateGateway",
    value: function validateGateway(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GATEWAY_REGEXP;
      this.validate(value, regExp, "gateway");
    }
  }, {
    key: "validateVendor",
    value: function validateVendor(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VENDOR_REGEXP;
      this.validate(value, regExp, "vendor");
    }
  }, {
    key: "validateApp",
    value: function validateApp(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : APP_REGEXP;
      this.validate(value, regExp, "app");
    }
  }, {
    key: "validateSubApp",
    value: function validateSubApp(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUB_APP_REGEXP;
      this.validate(value, regExp, "subApp");
    }
  }, {
    key: "validateSpp",
    value: function validateSpp(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SPP_REGEXP;
      this.validate(value, regExp, "spp");
    }
  }, {
    key: "validateProduct",
    value: function validateProduct(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PRODUCT_REGEXP;
      this.validate(value, regExp, "product");
    }
  }, {
    key: "validateTid",
    value: function validateTid(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TID_REGEXP;
      this.validate(value, regExp, "tid");
    }
  }, {
    key: "validateAwid",
    value: function validateAwid(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AWID_REGEXP;
      this.validate(value, regExp, "awid");
    }
  }, {
    key: "validateWorkspace",
    value: function validateWorkspace(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORKSPACE_REGEXP;
      this.validate(value, regExp, "workspace");
    }
  }, {
    key: "validateUseCase",
    value: function validateUseCase(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : USE_CASE_REGEXP;
      this.validate(value, regExp, "useCase");
    }
  }, {
    key: "validateParameterName",
    value: function validateParameterName(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PARAMETER_NAME_DECODED_REGEXP;
      this.validate(value, regExp, "parameterName");
    }
  }, {
    key: "validateParameterValue",
    value: function validateParameterValue(value) {
      var regExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (value != null && !(typeof value === "string" || Array.isArray(value))) throw new InvalidUriPartError("parameterValue", value, String);
      // for our generic uuUri following check is always true; will skip for optimization
      //      if (value != null && !encodeURIComponent(value).match(new RegExp("^" + PARAMETER_VALUE + "$"))) throw new InvalidUriPartError("parameterValue", value, PARAMETER_VALUE);
    }
  }]);
  return UriParser;
}();
module.exports = new UriParser();

/***/ }),

/***/ "../node_modules/uu_appg01_core-uri/src/uri.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _require = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js"),
  BaseError = _require.BaseError;
var EMPTY = {};

/**
 * @class UuApp.Uri.Uri
 * @classdesc
 * Immutable representation of uuUri. An instance of the Uri can be obtained either by
 * {@link UuApp.Uri.Uri.parse Uri.parse} or by using {@link UuApp.Uri.UriBuilder UriBuilder} class.
 * Note that minimal Uri consists of at least "app" and "tid".
 *
 * Examples of usage:
 *
 *     // uri from parsing current location
 *     let locationUri = Uri.parse(location.protocol + "//" + location.host + location.pathname); // "http://example.com/vendor-app/0-0/some/uc"
 *     let baseUri = locationUri.baseUri; // "http://example.com/vendor-app/0-0"
 *     let callUri = baseUri.join("+/getConfig"); // "http://example.com/vendor-app/0-0/getConfig"
 *
 *     // uri from parsing
 *     let uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app-subapp-spp/tid-awid/useCase?p1=v1");
 *     console.log(uri.gateway, uri.product, uri.workspace, uri.useCase);
 *     let params = uri.parameters; // always returns new copy of parameter map
 *     for (let k in params) console.log(k, "=", params[k]); // p1 = v1
 *
 *     // uri from UriBuilder
 *     let uri2 = UuApp.Uri.UriBuilder.parse(uri).setWorkspace("0-0").setUseCase("sys/init").toUri();
 *     console.log(uri2.toString()); // https://uuos9.plus4u.net/vendor-app-subapp-spp/0-0/sys/init?p1=v1
 *
 *     // uri from parsing (with ECMAScript6 template string, e.g. when using transpilers like Babel)
 *     // Note that query parameter values shouldn't be injected via template string as they might need
 *     // to be encoded first.
 *     let product = "vendor-app";
 *     let workspace = "tid-awid";
 *     let uri3 = UuApp.Uri.Uri.parse(`https://uuos9.plus4u.net/${product}/${workspace}`);
 *
 * @see UuApp.Uri.UriBuilder
 */
var Uri = /*#__PURE__*/function () {
  /**
   * New instance of URI should be created using {@link UuApp.Uri.Uri.parse}.
   * @private
   */
  function Uri(scheme, hostname, port, vendor, app, subApp, spp, tid, awid, useCase, parameters) {
    _classCallCheck(this, Uri);
    this._scheme = scheme;
    this._hostname = hostname;
    this._port = port;
    this._vendor = vendor;
    this._app = app;
    this._subApp = subApp;
    this._spp = spp;
    this._tid = tid;
    this._awid = awid;
    this._useCase = useCase;
    this._memory = {};
    this._useCase = useCase ? useCase.replace(/^\//, "") : useCase;
    if (this._port && typeof this._port !== "number") {
      this._port = parseInt(this._port + "", 10);
    }
    this._memory.gatewayValue = EMPTY;
    this._memory.productValue = EMPTY;
    this._memory.workspaceValue = EMPTY;
    this._memory.baseUriValue = undefined;
    this._memory.relativeUriValue = undefined;
    this._memory.strValue = undefined;
    this._paramsValue = Object.assign({}, parameters);
    Object.freeze(this);
  }

  /**
   * Returns string representation of URI.
   * @return {string}
   * @method UuApp.Uri.Uri#toString
   */
  _createClass(Uri, [{
    key: "toString",
    value: function toString() {
      if (this._memory.strValue !== undefined) {
        return this._memory.strValue;
      } else {
        this._memory.strValue = this.Builder.format(this);
        return this._memory.strValue;
      }
    }

    /**
     * @see {@link UuApp.Uri.Uri#toString} for further information.
     * Getter to ensure consistency with Node.js URL.
     * @private
     */
  }, {
    key: "href",
    get: function get() {
      return this.toString();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }

    /**
     * Returns URI containing only mandatory routing data
     * (including only {#gateway}, {#product} and {#workspace}).
     * @throws {BaseError} In case URI does not contain all required parts.
     * @returns {UuApp.Uri.Uri}
     * @method UuApp.Uri.Uri#getBaseUri
     */
  }, {
    key: "getBaseUri",
    value: function getBaseUri() {
      if (this._memory.baseUriValue !== undefined) {
        return this._memory.baseUriValue;
      }
      if (this.getGateway() == null || this.getProduct() == null || this.getWorkspace() == null) {
        throw new BaseError("Insufficient URI - at least one of gateway, product and workspace is not set. Uri: " + this.toString());
      }
      this._memory.baseUri = this.Builder.parse(this).set({
        useCase: null
      }).clearParameters().toUri();
      return this._memory.baseUri;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getBaseUri} for further information.
     * @private
     */
  }, {
    key: "baseUri",
    get: function get() {
      return this.getBaseUri();
    }

    /**
     * Returns URI without gateway part.
     * @returns {UuApp.Uri.Uri}
     * @method UuApp.Uri.Uri#getRelativeUri
     */
  }, {
    key: "getRelativeUri",
    value: function getRelativeUri() {
      if (this._memory.relativeUriValue !== undefined) {
        return this._memory.relativeUriValue;
      }
      this._memory.relativeUriValue = this.Builder.parse(this).set({
        gateway: null
      }).toUri();
      return this._memory.relativeUriValue;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getRelativeUri} for further information.
     * @private
     */
  }, {
    key: "relativeUri",
    get: function get() {
      return this.getRelativeUri();
    }

    /**
     * Returns Pathname (String representation of URI without gateway and parameters).
     * Getter to ensure consistency with Node.js URL.
     * @private
     * @returns {string}
     */
  }, {
    key: "pathname",
    get: function get() {
      return this.Builder.parse(this).set({
        gateway: null
      }).clearParameters().toString();
    }

    /**
     * Returns Gateway (formatted {#scheme}, {#hostname} and {#port})
     * @returns {string}
     * @method UuApp.Uri.Uri#getGateway
     */
  }, {
    key: "getGateway",
    value: function getGateway() {
      if (this._memory.gatewayValue !== EMPTY) {
        return this._memory.gatewayValue;
      } else {
        this._memory.gatewayValue = this.Builder.formatGateway(this._scheme, this._hostname, this._port);
        return this._memory.gatewayValue;
      }
    }

    /**
     * @see {@link UuApp.Uri.Uri#getGateway} for further information.
     * @private
     */
  }, {
    key: "gateway",
    get: function get() {
      return this.getGateway();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * @see {@link UuApp.Uri.Uri#getGateway} for further information.
     * Getter to ensure consistency with Node.js URL.
     * @private
     */
  }, {
    key: "origin",
    get: function get() {
      return this.getGateway();
    }

    /**
     * Returns Product (formatted {#vendor}, {#app}, {#sub_app} and {#spp})
     * @returns {string}
     * @method UuApp.Uri.Uri#getProduct
     */
  }, {
    key: "getProduct",
    value: function getProduct() {
      if (this._memory.productValue !== EMPTY) {
        return this._memory.productValue;
      } else {
        this._memory.productValue = this.Builder.formatProduct(this._vendor, this._app, this._subApp, this._spp);
        return this._memory.productValue;
      }
    }

    /**
     * @see {@link UuApp.Uri.Uri#getProduct} for further information.
     * @private
     */
  }, {
    key: "product",
    get: function get() {
      return this.getProduct();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Workspace (formatted {#tid} and {#awid})
     * @returns {string}
     * @method UuApp.Uri.Uri#getWorkspace
     */
  }, {
    key: "getWorkspace",
    value: function getWorkspace() {
      if (this._memory.workspaceValue !== EMPTY) {
        return this._memory.workspaceValue;
      } else {
        this._memory.workspaceValue = this.Builder.formatWorkspace(this._tid, this._awid);
        return this._memory.workspaceValue;
      }
    }

    /**
     * @see {@link UuApp.Uri.Uri#getWorkspace} for further information.
     * @private
     */
  }, {
    key: "workspace",
    get: function get() {
      return this.getWorkspace();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Scheme
     * @returns {string}
     * @method UuApp.Uri.Uri#getScheme
     */
  }, {
    key: "getScheme",
    value: function getScheme() {
      return this._scheme;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getScheme} for further information.
     * @private
     */
  }, {
    key: "scheme",
    get: function get() {
      return this.getScheme();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Scheme with colon (:) on the end.
     * Getter to ensure consistency with Node.js URL.
     * @private
     * @returns {string}
     */
  }, {
    key: "protocol",
    get: function get() {
      return this.getScheme() + ":";
    }

    /**
     * Returns Hostname
     * @returns {string}
     * @method UuApp.Uri.Uri#getHostname
     */
  }, {
    key: "getHostname",
    value: function getHostname() {
      return this._hostname;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getHostname} for further information.
     * @private
     */
  }, {
    key: "hostname",
    get: function get() {
      return this.getHostname();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Host (formatted {#hostname} and {#port})
     * Getter to ensure consistency with Node.js URL.
     * @private
     * @returns {string}
     */
  }, {
    key: "host",
    get: function get() {
      return this.getHostname() + ":" + this.getPort();
    }

    /**
     * Returns Port
     * @returns {number}
     * @method UuApp.Uri.Uri#getPort
     */
  }, {
    key: "getPort",
    value: function getPort() {
      if (this._port) {
        return this._port;
      }
      if (this._scheme) {
        return this._scheme.match(/^https$/) ? 443 : 80;
      }
      return null;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getPort} for further information.
     * @private
     */
  }, {
    key: "port",
    get: function get() {
      return this.getPort();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Vendor
     * @returns {string}
     * @method UuApp.Uri.Uri#getVendor
     */
  }, {
    key: "getVendor",
    value: function getVendor() {
      return this._vendor;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getVendor} for further information.
     * @private
     */
  }, {
    key: "vendor",
    get: function get() {
      return this.getVendor();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Application
     * @returns {string}
     * @method UuApp.Uri.Uri#getApp
     */
  }, {
    key: "getApp",
    value: function getApp() {
      return this._app;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getApp} for further information.
     * @private
     */
  }, {
    key: "app",
    get: function get() {
      return this.getApp();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Sub-application
     * @returns {string}
     * @method UuApp.Uri.Uri#getSubApp
     */
  }, {
    key: "getSubApp",
    value: function getSubApp() {
      return this._subApp;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getSubApp} for further information.
     * @private
     */
  }, {
    key: "subApp",
    get: function get() {
      return this.getSubApp();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns SPP
     * @returns {string}
     * @method UuApp.Uri.Uri#getSpp
     */
  }, {
    key: "getSpp",
    value: function getSpp() {
      return this._spp;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getSpp} for further information.
     * @private
     */
  }, {
    key: "spp",
    get: function get() {
      return this.getSpp();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Tenant ID
     * @returns {string}
     * @method UuApp.Uri.Uri#getTid
     */
  }, {
    key: "getTid",
    value: function getTid() {
      return this._tid;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getTid} for further information.
     * @private
     */
  }, {
    key: "tid",
    get: function get() {
      return this.getTid();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Application workspace ID
     * @returns {string}
     * @method UuApp.Uri.Uri#getAwid
     */
  }, {
    key: "getAwid",
    value: function getAwid() {
      return this._awid;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getAwid} for further information.
     * @private
     */
  }, {
    key: "awid",
    get: function get() {
      return this.getAwid();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Returns Use Case
     * @returns {string}
     * @method UuApp.Uri.Uri#getUseCase
     */
  }, {
    key: "getUseCase",
    value: function getUseCase() {
      return this._useCase;
    }

    /**
     * @see {@link UuApp.Uri.Uri#getUseCase} for further information.
     * @private
     */
  }, {
    key: "useCase",
    get: function get() {
      return this.getUseCase();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
     * Note that each access returns new copy of the map (to achieve immutability of the Uri class),
     * therefore usage should look like this:
     *
     *     // OPTIMAL (single read of "parameters" field on uri)
     *     let params = uri.parameters;
     *     for (let k in params) console.log(params[k]);
     *
     *     // SUB-OPTIMAL (multiple reads and therefore multiple copying of parameter map)
     *     // for (let k in uri.parameters) console.log(uri.parameters[k]);
     *
     * @method UuApp.Uri.Uri#getParameters
     */
  }, {
    key: "getParameters",
    value: function getParameters() {
      return Object.assign({}, this._paramsValue);
    }

    /**
     * @see {@link UuApp.Uri.Uri#getParameters} for further information.
     * @private
     */
  }, {
    key: "parameters",
    get: function get() {
      return this.getParameters();
    }

    /**
     * throws error to prevent from using setter
     * @param attr
     */,
    set: function set(attr) {
      this.throwOnSet(attr);
    }

    /**
     * @see {@link UuApp.Uri.Uri#getParameters} for further information.
     * Getter to ensure consistency with Node.js URL.
     * @private
     */
  }, {
    key: "searchParams",
    get: function get() {
      return this.getParameters();
    }

    /**
     * Returns string representation of all URI parameters
     * Getter to ensure consistency with Node.js URL.
     * @private
     * @returns {string}
     */
  }, {
    key: "search",
    get: function get() {
      return this.Builder.formatParameters(this.getParameters());
    }

    /**
     * Replaces current path with specified absolute path (or adds a relative path to the current path) returning new Uri.
     * Query parameters are preserved only on last path. Resolving relative path and usage of "./" and "../" works as in standard
     * URLs (see {@link https://tools.ietf.org/html/rfc2396#appendix-C RFC 2396, examples}).
     *
     * Additionally, it's possible to use "+/" at the beginning of paths - paths starting
     * with "+/" are joined as if current path (to which new path is being joined) denoted a "folder", i.e. current path
     * is appended with slash (unless it already ends with slash) and new path is appended afterwards (see examples).
     *
     * @param {...string} path Absolute or relative paths to replace / add.
     * @return New Uri whose path is the result of the join.
     * @method UuApp.Uri.Uri#join
     * @example
     *  // replace path with an absolute path (effectively removing also query parameters)
     *  let uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1?a=b");
     *  let uri2 = uri.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
     *
     *  // add relative paths
     *  let uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1");
     *  let uri2 = uri.join("sys/init?p=v");             // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init?p=v
     *  let uri3 = uri.join("+/sys/init?p=v");           // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?p=v
     *  let uri4 = uri.join("+/sys/?a=b", "init?c=d");   // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?c=d
     */
  }, {
    key: "join",
    value: function join( /* ... */
    ) {
      if (arguments.length <= 0) {
        return this;
      }
      var root = this.getGateway() || "";
      var path = this.toString().substr(root.length);
      for (var i = 0; i < arguments.length; ++i) {
        var pathPart = arguments[i];
        if (!pathPart) {
          continue;
        }
        path = path.replace(/[?#].*/, ""); // remove query part because we're going to add / replace path
        pathPart = pathPart.replace(/((^|\/)\.\.?)$/, "$1/"); // if new path part ends with two dots / one dot, treat it as a "folder", i.e. append "/"
        if (pathPart.charAt(0) === "/") {
          path = pathPart;
        } // new path part is absolute => replace whole path
        else if (pathPart.match(/^\+(\/|$)/)) {
          path = path.replace(/\/?$/, "/") + pathPart;
        } // new path part is relative with "+/" => append "/" and then new path
        else if (path.charAt(path.length - 1) === "/") {
          path += pathPart;
        } // new path part is relative and current path is a "folder" => append new path
        else {
          path = path.replace(/(^|\/)[^/]*$/, "$1") + pathPart;
        } // new path part is relative and current path is not a "folder" => replace last segment of current path
      }

      // normalize (modify segments to eliminate "../" and "./" from the path)
      var segments = [];
      path.split("/").forEach(function (part) {
        if (part === "..") {
          segments.pop();
        } else if (part !== "." && part !== "+") {
          segments.push(part);
        }
      });
      if (segments[0] !== "") {
        segments.unshift("");
      } // make sure that after "join" operation the path starts with "/"
      var resultPath = segments.join("/");
      return Uri.parse(root + resultPath);
    }
  }, {
    key: "throwOnSet",
    value: function throwOnSet(attr) {
      throw new BaseError("Cannot set " + attr + "on Uri because instances of Uri are immutable. Use UriBuilder instead.");
    }

    /**
     * Checks whether the other URI is equal to this one and returns true iff it is.
     *
     * @param {UuApp.Uri.Uri} uri Uri to check equality against.
     * @return True iff the specified uri is equal to this one.
     * @method UuApp.Uri.Uri#equals
     */
  }, {
    key: "equals",
    value: function equals(_Uri) {
      return this.toString() === (_Uri || "").toString();
    }

    /**
     * Get Uri Builder instance initialized with this Uri properties.
     *
     * @returns {UuApp.Uri.UriBuilder}
     * @method UuApp.Uri.Uri#getBuilder
     */
  }, {
    key: "getBuilder",
    value: function getBuilder() {
      return this.Builder.parse(this);
    }

    /**
     * @param {(string|UuApp.Uri.Uri)} uriStr The string to parse as URI. If an instance of Uri class is given, it's returned as-is.
     * @return {UuApp.Uri.Uri} Parsed URI.
     * @method UuApp.Uri.Uri.parse
     * @example
     *    let uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app/tid-awid/useCase?p1=v1");
     */
  }], [{
    key: "parse",
    value: function parse(uriStr) {
      if (uriStr instanceof Uri) {
        return uriStr;
      }
      return this.prototype.Builder.parse(uriStr).toUri();
    }
  }, {
    key: "createBuilder",
    value: function createBuilder() {
      return new this.prototype.Builder();
    }
  }]);
  return Uri;
}();
module.exports = Uri;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/base-error.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/**
 * Ancestor of all errors raised by UAF. Extends standard
 * JavaScript error by unique error id, timestamp and also
 * option to provide error cause.
 */
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _inherits = (__webpack_require__("../node_modules/@babel/runtime/helpers/inherits.js")["default"]);
var _createSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createSuper.js")["default"]);
var _wrapNativeSuper = (__webpack_require__("../node_modules/@babel/runtime/helpers/wrapNativeSuper.js")["default"]);
var BaseError = /*#__PURE__*/function (_Error) {
  _inherits(BaseError, _Error);
  var _super = _createSuper(BaseError);
  /**
   * Creates new instance of error
   * @param message Error message
   * @param cause Error cause
   */
  function BaseError(message) {
    var _this;
    var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, BaseError);
    if (message instanceof Error) {
      cause = message;
      message = null;
    }
    _this = _super.call(this, message ? message.toString() : "");
    _this._id = "00000000000000000000000000000000".replace(/0/g, function () {
      return (~~(Math.random() * 16)).toString(16);
    });
    _this._timestamp = new Date();
    _this._cause = cause;
    _this._name = _this.constructor.name;
    return _this;
  }

  /**
   * Returns unique error ID (helps with lookup of error in logs).
   * @returns {string} Unique error ID
   */
  _createClass(BaseError, [{
    key: "id",
    get: function get() {
      return this._id;
    }

    /**
     * Sets error id.
     * @param {string} id error ID
     */,
    set: function set(id) {
      this._id = id;
    }

    /**
     * Returns timestamp of error instantiation (may differ from error log time).
     * @returns {Date} Timestamp of error instantiation
     */
  }, {
    key: "timestamp",
    get: function get() {
      return this._timestamp;
    }

    /**
     * Returns error cause
     * @returns {Error|null} Error cause
     */
  }, {
    key: "cause",
    get: function get() {
      return this._cause;
    }

    /**
     * Sets error cause.
     * @param {Error|null} error Error cause
     */,
    set: function set(error) {
      this._cause = error;
    }

    /**
     * Returns error name
     * @return {string} Error name
     */
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }]);
  return BaseError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
module.exports = BaseError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/base64.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Buffer = __webpack_require__("../node_modules/uu_appg01_core-utils/src/buffer.compat.js");
var Base64 = /*#__PURE__*/function () {
  function Base64() {
    _classCallCheck(this, Base64);
  }
  _createClass(Base64, null, [{
    key: "encode",
    value: function encode(value) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
      return Buffer.from(value, encoding).toString('base64');
    }
  }, {
    key: "decode",
    value: function decode(value) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
      var rawData = Buffer.from(value, 'base64');
      if (encoding === "binary") {
        return rawData;
      } else {
        return rawData.toString(encoding);
      }
    }
  }, {
    key: "urlSafeEncode",
    value: function urlSafeEncode(value) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
      var noPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (typeof encoding === "boolean") {
        noPadding = encoding;
        encoding = "utf8";
      }
      var base64 = this.encode(value, encoding);
      base64 = base64.replace(/\+/g, '-').replace(/\//g, '_');
      if (noPadding) {
        base64 = base64.replace(/=/g, '');
      }
      return base64;
    }
  }, {
    key: "urlSafeDecode",
    value: function urlSafeDecode(value) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
      var base64 = value.replace(/-/g, '+').replace(/_/g, '/');
      return this.decode(base64, encoding);
    }
  }]);
  return Base64;
}();
module.exports = Base64;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/buffer.compat.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Workaround to add Buffer polyfill for Base64 komponent which nees it. We need to
// keep using Buffer for backward compatibility as it is returned from "decode" method.
// TODO Might be removed in next major version.
module.exports = typeof Buffer !== "undefined" ? Buffer : (__webpack_require__("../node_modules/buffer/index.js").Buffer);

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/config/config-chain.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var BaseError = __webpack_require__("../node_modules/uu_appg01_core-utils/src/base-error.js");
var ValueConverter = __webpack_require__("../node_modules/uu_appg01_core-utils/src/value-converter.js");
var Json = __webpack_require__("../node_modules/uu_appg01_core-utils/src/json.js");
var expression = /(?:^|[^\\])(\${([\w_.]+)(?::([^}]*))?}|#{([^}]+)})/;
var ConfigChain = /*#__PURE__*/function () {
  function ConfigChain(sources, profiles) {
    _classCallCheck(this, ConfigChain);
    this._sources = sources;
    this._profiles = profiles;
    this._custom = {};
  }
  _createClass(ConfigChain, [{
    key: "activeProfiles",
    value: function activeProfiles() {
      return Json.parse(Json.stringify(this._profiles));
    }
  }, {
    key: "get",
    value: function get(name) {
      var _this = this;
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var loopCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var result;
      var self = this;
      if (recursive) {
        var parts = name.split(".");
        var _loop = function _loop() {
            var name = parts.join(".");
            if (_this._custom[name] !== undefined) return {
              v: _this._custom[name]
            };
            _this._sources.forEach(function (source) {
              var value = source.get(name);
              if (value !== undefined && result === undefined) result = self._resolve(value, loopCheck);
            });
            if (result !== undefined) return {
              v: result
            };
            var length = parts.length;
            var idx = length === 1 ? 0 : length - 2;
            parts.splice(idx, 1);
          },
          _ret;
        while (parts.length > 0) {
          _ret = _loop();
          if (_ret) return _ret.v;
        }
      } else {
        if (this._custom[name] !== undefined) return this._custom[name];
        this._sources.forEach(function (source) {
          var value = source.get(name);
          if (value !== undefined && result === undefined) result = self._resolve(value, loopCheck);
        });
        if (result !== undefined) return result;
      }
      return result;
    }
  }, {
    key: "getString",
    value: function getString(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = this.get(name, recursive);
      return ValueConverter.toString(value);
    }
  }, {
    key: "getNumber",
    value: function getNumber(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = this.get(name, recursive);
      return ValueConverter.toNumber(value);
    }
  }, {
    key: "getBoolean",
    value: function getBoolean(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = this.get(name, recursive);
      return ValueConverter.toBoolean(value);
    }
  }, {
    key: "getTime",
    value: function getTime(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var value = this.get(name, recursive);
      return ValueConverter.toTime(value);
    }
  }, {
    key: "getClass",
    value: function getClass(name, sourcePath) {
      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var value = this.get(name, recursive);
      sourcePath = !sourcePath ? this._serverSourcePath() : sourcePath;
      return ValueConverter.toClass(value, sourcePath);
    }
  }, {
    key: "getArray",
    value: function getArray(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var sourcePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var value = this.get(name, recursive);
      sourcePath = !sourcePath ? this._serverSourcePath() : sourcePath;
      return ValueConverter.toArray(value, type, sourcePath);
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this._custom[name] = value;
    }
  }, {
    key: "delete",
    value: function _delete(name) {
      delete this._custom[name];
    }
  }, {
    key: "hasKey",
    value: function hasKey(name) {
      var _this2 = this;
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var hasKey = false;
      if (recursive) {
        var parts = name.split(".");
        var _loop2 = function _loop2() {
            var name = parts.join(".");
            if (_this2._custom[name] !== undefined) return {
              v: true
            };
            _this2._sources.forEach(function (source) {
              if (!hasKey && source.hasKey(name)) hasKey = true;
            });
            if (hasKey) {
              return {
                v: hasKey
              };
            }
            var length = parts.length;
            var idx = length === 1 ? 0 : length - 2;
            parts.splice(idx, 1);
          },
          _ret2;
        while (parts.length > 0) {
          _ret2 = _loop2();
          if (_ret2) return _ret2.v;
        }
      } else {
        if (this._custom[name] !== undefined) return true;
        this._sources.forEach(function (source) {
          if (source.hasKey(name)) {
            hasKey = true;
          }
        });
      }
      return hasKey;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var result = {};
      var resolver = this._resolve.bind(this);
      this._sources.reverse();
      this._sources.forEach(function (source) {
        var sourceJson = source.toJSON();
        var keys = Object.keys(sourceJson);
        keys.forEach(function (key) {
          result[key] = resolver(sourceJson[key]);
        });
      });
      this._sources.reverse();
      var keys = Object.keys(this._custom);
      var custom = this._custom;
      keys.forEach(function (key) {
        result[key] = resolver(custom[key]);
      });
      return result;
    }
  }, {
    key: "load",
    value: function load() {
      var failOnError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this._sources.reverse();
      this._sources.forEach(function (source) {
        source.load(failOnError);
      });
      this._sources.reverse();
    }
  }, {
    key: "_resolve",
    value: function _resolve(value) {
      var loopCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (!!value && value.constructor === Object) {
        var newObject = {};
        for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          newObject[key] = this._resolve(value[key]);
        }
        return newObject;
      }
      if (!(typeof value === "string") && !(value instanceof String)) return value;
      var matchResult = value.match(expression);
      if (!matchResult) {
        return value;
      } else {
        var _expression = matchResult[1];
        var _key = matchResult[2];
        var defolt = matchResult[3];
        var prog = matchResult[4];
        if (prog) {
          value = eval(prog);
          return this._resolve(value);
        } else {
          if (loopCheck.includes(_key)) throw new BaseError("endless configuration loop caused by [" + loopCheck + "]");
          loopCheck.push(_key);
          var resolved = this.get(_key, true, loopCheck);
          if (!resolved) resolved = defolt;
          value = value.replace(new RegExp(_expression.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&"), "g"), resolved);
          return this._resolve(value);
        }
      }
    }
  }, {
    key: "_serverSourcePath",
    value: function _serverSourcePath() {
      return this.get("server_root");
    }
  }]);
  return ConfigChain;
}();
module.exports = ConfigChain;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/config/config-source.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Json = __webpack_require__("../node_modules/uu_appg01_core-utils/src/json.js");
if (typeof window == "undefined") {
  var fs = __webpack_require__("?17bb");
}
var SRC_TTL = "_ttl";
var ConfigSource = /*#__PURE__*/function () {
  function ConfigSource(source) {
    var ttl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    _classCallCheck(this, ConfigSource);
    this._ttl = ttl;
    if (typeof source === "string" || source instanceof String) {
      var match = /^file:\/\/(.*)/i.exec(source);
      if (match !== null) {
        if (typeof window != "undefined") throw new TypeError("Unable to use " + source + " as configuration source in browser environment.");
        this._fileSrc = match[1];
      } else {
        match = /^env:\/\/([a-z_][a-z0-9_]*)/i.exec(source);
        if (match !== null) {
          this._senvSrc = match[1];
        } else {
          throw new TypeError("unable to use " + source + " as configuration source");
        }
      }
    } else if (source instanceof RegExp) {
      this._menvSrc = source;
    } else if (source && typeof source === "object") {
      this._data = source;
    } else {
      throw new TypeError("unable to use " + typeof source.constructor + " as configuration source");
    }
  }
  _createClass(ConfigSource, [{
    key: "load",
    value: function load() {
      var failOnError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var loadedSrc;
      try {
        if (this._fileSrc !== undefined && this._fileSrc) {
          loadedSrc = this._fileSrc;
          var data = fs.readFileSync(this._fileSrc, "utf8");
          this._data = this._parse(data);
        } else if (this._senvSrc !== undefined && this._senvSrc) {
          loadedSrc = this._senvSrc;
          var _data = ({"NAME":"uu_appg01_core","VERSION":"5.19.0","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})[this._senvSrc] || "";
          this._data = this._parse(_data);
        } else if (this._menvSrc !== undefined && this._menvSrc) {
          loadedSrc = this._menvSrc;
          var regex = this._menvSrc;
          var envKeys = Object.keys(({"NAME":"uu_appg01_core","VERSION":"5.19.0","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""}));
          var result = {};
          envKeys.forEach(function (key) {
            if (regex.test(key)) {
              result[key.toLowerCase()] = ({"NAME":"uu_appg01_core","VERSION":"5.19.0","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})[key];
            }
          });
          this._data = result;
        }
        if (this._data[SRC_TTL] != null) {
          this._ttl = Number(this._data[SRC_TTL]);
        }
        this._loaded = new Date();
      } catch (err) {
        var errMsg = `Loading of configuration from source [${loadedSrc}] failed: ${err.toString()}`;
        if (failOnError) {
          throw new Error(errMsg);
        } else {
          console.log(errMsg);
        }
      }
    }
  }, {
    key: "get",
    value: function get(name) {
      if (this._reload()) this.load();
      return this._data[name];
    }
  }, {
    key: "setTtl",
    value: function setTtl(ttl) {
      this._ttl = ttl;
    }
  }, {
    key: "hasKey",
    value: function hasKey(name) {
      if (this._reload()) this.load();
      return this._data[name] !== undefined;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var failOnError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (this._reload()) this.load(failOnError);
      return Json.parse(Json.stringify(this._data));
    }
  }, {
    key: "_parse",
    value: function _parse(sourceData) {
      if (/^[\r\n\t ]*{[\s\S]*}[\r\n\t ]*$/.test(sourceData)) {
        return Json.parse(sourceData);
      } else {
        var result = {};
        sourceData = sourceData.replace(/\r\n?/g, "\n");
        var splitData = sourceData.split("\n");
        splitData.forEach(function (line) {
          line = line.trim();
          if (/^[#!]/.test(line)) return;
          var splitLine = line.split(/[=:](.*)/, 2);
          var name = splitLine[0];
          var value = splitLine[1];
          if (name === null) return;
          name = name.trim();
          if (name.length === 0) return;
          if (value === undefined) {
            value = null;
          } else {
            value = value.trimLeft();
            try {
              value = Json.parse(value.trim());
            } catch (err) {
              // do nothing
            }
          }
          result[name] = value;
        });
        return result;
      }
    }
  }, {
    key: "_reload",
    value: function _reload() {
      if (!this._loaded) return true;
      if (this._ttl < 0) return false;
      var t = new Date();
      var reload = t.getTime() > this._loaded.getTime() + this._ttl * 1000;
      if (this._fileSrc && reload) {
        var stats = fs.statSync(this._fileSrc);
        if (stats.isFile()) {
          var mTime = new Date(stats["mtime"]);
          if (mTime.getTime() > this._loaded.getTime()) {
            return true;
          } else {
            this._loaded = t;
            return false;
          }
        } else {
          return false;
        }
      } else {
        return reload;
      }
    }
  }]);
  return ConfigSource;
}();
module.exports = ConfigSource;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/config/config.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _toConsumableArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/toConsumableArray.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var ConfigSource = __webpack_require__("../node_modules/uu_appg01_core-utils/src/config/config-source.js");
var ConfigChain = __webpack_require__("../node_modules/uu_appg01_core-utils/src/config/config-chain.js");
var Json = __webpack_require__("../node_modules/uu_appg01_core-utils/src/json.js");
if (typeof window == "undefined") {
  var DupValidator = __webpack_require__("?9d51");
  DupValidator.ensureSingleVersion(module);
  var path = __webpack_require__("?1988");
  var fs = __webpack_require__("?17bb");
  var os = __webpack_require__("?c2ca");
}

/**
 * Main class for working with configuration (reading, updating, source registration)
 */
var Config = /*#__PURE__*/function () {
  function Config() {
    _classCallCheck(this, Config);
  }
  _createClass(Config, null, [{
    key: "registerImplicitSource",
    value:
    /**
     * Allows to provide default configuration of library or application.
     * @param {string|RegExp|Object} source
     */
    function registerImplicitSource(source) {
      Config.implicitSources.push(new ConfigSource(source));
      var profiles = Config.activeProfiles;
      if (profiles && profiles.length > 0) {
        Config.activateProfiles.apply(Config, _toConsumableArray(profiles));
      }
    }

    /**
     * Allows registration of additional configuration source
     * @param {String} profile
     * @param {string|RegExp|Object} source
     * @param {Number} ttl
     */
  }, {
    key: "registerSource",
    value: function registerSource(profile, source, ttl) {
      var profileSources = Config.sources[profile];
      if (profileSources) {
        profileSources.push(new ConfigSource(source, ttl));
      } else {
        Config.sources[profile] = [new ConfigSource(source, ttl)];
      }
      var profiles = Config.activeProfiles;
      if (profiles.includes(profile)) {
        Config.activateProfiles.apply(Config, _toConsumableArray(profiles));
      }
    }
  }, {
    key: "atProfileActivation",
    value: function atProfileActivation(funktion) {
      for (var _len = arguments.length, profiles = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        profiles[_key - 1] = arguments[_key];
      }
      Config.callbacks.push([funktion, profiles]);
    }

    /**
     * Activates given set of configuration profiles
     * @param {...profiles} profiles
     */
  }, {
    key: "activateProfiles",
    value: function activateProfiles() {
      for (var _len2 = arguments.length, profiles = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        profiles[_key2] = arguments[_key2];
      }
      var sources = [];
      if (typeof window == "undefined") {
        // 1) registered sources
        profiles.forEach(function (profile) {
          var profileSources = Config.sources[profile] || [];
          profileSources.reverse();
          sources.push.apply(sources, _toConsumableArray(profileSources));
          profileSources.reverse();
        });
        // 2) "legacy" source for backward compatibility with C3
        sources.push(new ConfigSource("env://SERVER_CFG"));
        // 3) configuration from environment
        sources.push(new ConfigSource(/.*/));
        // 4) configuration files
        var cfgDir = ({"NAME":"uu_appg01_core","VERSION":"5.19.0","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})["CONFIG_DIR"] || Config._getDefaultConfigDir();
        var sysCfgDir = ({"NAME":"uu_appg01_core","VERSION":"5.19.0","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})["SYS_CONFIG_DIR"] || Config._getDefaultSysConfigDir();
        var testCfgDir = Config._getTestConfigDir();
        profiles.forEach(function (profile) {
          var profileCfgPropertiesFile = path.join(cfgDir, profile.toLowerCase() + ".properties");
          var profileCfgJsonFile = path.join(cfgDir, profile.toLowerCase() + ".json");
          var sysProfileCfgPropertiesFile = path.join(sysCfgDir, profile.toLowerCase() + ".properties");
          var sysProfileCfgJsonFile = path.join(sysCfgDir, profile.toLowerCase() + ".json");
          var testProfileCfgPropertiesFile = path.join(testCfgDir, profile.toLowerCase() + ".properties");
          var testProfileCfgJsonFile = path.join(testCfgDir, profile.toLowerCase() + ".json");
          if (fs.existsSync(testProfileCfgJsonFile)) {
            sources.push(new ConfigSource("file://" + testProfileCfgJsonFile));
          }
          if (fs.existsSync(sysProfileCfgJsonFile)) {
            sources.push(new ConfigSource("file://" + sysProfileCfgJsonFile));
          }
          if (fs.existsSync(profileCfgJsonFile)) {
            sources.push(new ConfigSource("file://" + profileCfgJsonFile));
          }
          if (fs.existsSync(testProfileCfgPropertiesFile)) {
            sources.push(new ConfigSource("file://" + testProfileCfgPropertiesFile));
          }
          if (fs.existsSync(sysProfileCfgPropertiesFile)) {
            sources.push(new ConfigSource("file://" + sysProfileCfgPropertiesFile));
          }
          if (fs.existsSync(profileCfgPropertiesFile)) {
            sources.push(new ConfigSource("file://" + profileCfgPropertiesFile));
          }
        });
        // 5) default configuration
        sources.push.apply(sources, _toConsumableArray(Config.implicitSources));
      } else {
        var uu5 = window["uu5Environment"] || window["UU5"];
        var env = Config._getUu5Env(uu5) || {};
        sources.push(new ConfigSource(env));
      }
      // create the chain
      var chain = new ConfigChain(sources, profiles);

      // Copy custom configuration added to config from previously
      // activated profiles (so runtime configuration is not lost)
      if (Config.chain) chain._custom = Json.parse(Json.stringify(Config.chain._custom));
      Config.chain = chain;

      // Force load of all configs, fail on errors (Configuration must be
      // complete at least on profile activation which is expected during
      // environment initialization)
      chain.load(true);

      // Invoke profile activation callbacks
      Config.callbacks.forEach(function (entry) {
        var cb = entry[0];
        var cbProfiles = entry[1];
        if (!Config._doArraysIntersect(profiles, cbProfiles)) cb.call();
      });
      Config.activeProfiles = Array.from(new Set([].concat(_toConsumableArray(Config.activeProfiles), profiles)));

      // TODO log it (when logging gets standardised)
      // console.log('\nProfile(s) ' + chain.activeProfiles() +  ' activated. Effective configuration:\n', chain.toJSON(),'\n')
    }

    /**
     * Checks if given profile(s) is(are) active.
     * @param {...profiles} profiles
     * @returns {boolean}
     */
  }, {
    key: "isProfileActive",
    value: function isProfileActive() {
      var activeProfiles = Config.activeProfiles;
      if (!activeProfiles) return false;
      for (var _len3 = arguments.length, profiles = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        profiles[_key3] = arguments[_key3];
      }
      return Config._doArraysIntersect(activeProfiles, profiles);
    }

    /**
     * Returns value of the given configuration parameter
     * @param {string} name
     * @param {Boolean} recursive
     * @returns {*}
     */
  }, {
    key: "get",
    value: function get(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return Config._getChain().get(name, recursive);
    }

    /**
     * Returns parameter value transformed to string using .toString().
     * @param {String} name
     * @param {boolean} recursive
     * @returns {String}
     */
  }, {
    key: "getString",
    value: function getString(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return Config._getChain().getString(name, recursive);
    }

    /**
     * Returns parameter value transformed to number (if possible, else raises error).
     * @param {String} name
     * @param {boolean} recursive
     * @returns {Number}
     */
  }, {
    key: "getNumber",
    value: function getNumber(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return Config._getChain().getNumber(name, recursive);
    }

    /**
     * Returns parameter value transformed to boolean (if possible, else raises error).
     * @param {String} name
     * @param {boolean} recursive
     * @returns {Boolean}
     */
  }, {
    key: "getBoolean",
    value: function getBoolean(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return Config._getChain().getBoolean(name, recursive);
    }

    /**
     * Returns parameter value transformed to a Date object using its constructor or raises error.
     * @param {String} name
     * @param {boolean} recursive
     * @returns {Date}
     */
  }, {
    key: "getTime",
    value: function getTime(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return Config._getChain().getTime(name, recursive);
    }

    /**
     * Returns parameter value transformed to a class if possible, else raises error.
     * Source path needs to be provided, which is the path to the module that exports the requested class.
     * @param {String} name
     * @param {String} sourcePath
     * @param {boolean} recursive
     * @returns {Function}
     */
  }, {
    key: "getClass",
    value: function getClass(name, sourcePath) {
      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      return Config._getChain().getClass(name, sourcePath, recursive);
    }

    /**
     * Returns parameter value transformed to array of given types
     * @param {String} name
     * @param {String} type
     * @param {Boolean} recursive
     * @returns {Array}
     */
  }, {
    key: "getArray",
    value: function getArray(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var sourcePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      return Config._getChain().getArray(name, type, recursive, sourcePath);
    }

    /**
     * Sets configuration parameter with highest priority (overrides value of any existing source).
     * @param {String} name
     * @param {*} value
     */
  }, {
    key: "set",
    value: function set(name, value) {
      Config._getChain().set(name, value);
    }

    /**
     * Deletes explicitly set configuration parameter.
     * @param {String} name
     */
  }, {
    key: "delete",
    value: function _delete(name) {
      Config._getChain().delete(name);
    }

    /**
     * Checks if configuration provides parameter of given name.
     * Returns false for undefined values and true for null values.
     * @param {String} name
     * @param {Boolean} recursive
     * @returns {*|Boolean|boolean}
     */
  }, {
    key: "hasKey",
    value: function hasKey(name) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return Config._getChain().hasKey(name, recursive);
    }

    /**
     * Returns Object containing effective configuration.
     * @param {boolean} failOnError
     * @returns {*}
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var failOnError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return Config._getChain().toJSON(failOnError);
    }

    /**
     * Forces reload of all configuration sources related to activated profiles.
     * @param {boolean} failOnError
     */
  }, {
    key: "reload",
    value: function reload() {
      var failOnError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Config._getChain().load(failOnError);
    }

    /**
     * Clears all configuration.
     */
  }, {
    key: "clear",
    value: function clear() {
      Config.activeProfiles = [];
      Config.callbacks = [];
      Config.implicitSources = [];
      Config.sources = {};
      Config.chain = null;
    }
  }, {
    key: "_getChain",
    value: function _getChain() {
      var chain = Config.chain;
      if (!chain) {
        var actProf = Config.activeProfiles;
        if (actProf.length === 0) {
          var envProfiles = ({"NAME":"uu_appg01_core","VERSION":"5.19.0","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})["CONFIG_PROFILE"] || (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development");
          if (envProfiles) {
            var arr = envProfiles.split(",");
            actProf = [];
            arr.forEach(function (profile) {
              actProf.push(profile.trim());
            });
            Config.activateProfiles.apply(Config, _toConsumableArray(actProf));
          } else {
            actProf = "production";
            Config.activateProfiles(actProf);
          }
        }
        chain = Config.chain;
      }
      return chain;
    }

    // TODO move this function to some more appropriate place?
  }, {
    key: "_doArraysIntersect",
    value: function _doArraysIntersect(arr1, arr2) {
      var doTheyIntersect = false;
      arr1.forEach(function (el1) {
        if (arr2.includes(el1)) doTheyIntersect = true;
      });
      return doTheyIntersect;
    }
  }, {
    key: "_getDefaultConfigDir",
    value: function _getDefaultConfigDir() {
      var configPath = path.join(process.cwd(), "env");
      if (!fs.existsSync(configPath)) {
        configPath = path.join(process.cwd(), "config");
      }
      return configPath;
    }
  }, {
    key: "_getDefaultSysConfigDir",
    value: function _getDefaultSysConfigDir() {
      var configPath = path.join(os.homedir(), ".uu", "env");
      if (!fs.existsSync(configPath)) {
        configPath = path.join(os.homedir(), ".uu", "config");
      }
      return configPath;
    }
  }, {
    key: "_getTestConfigDir",
    value: function _getTestConfigDir() {
      return path.join(process.cwd(), "test", "env");
    }
  }, {
    key: "_getUu5Env",
    value: function _getUu5Env(uu5) {
      if (!uu5) {
        return {};
      }
      if (uu5.Environment) {
        return uu5.Environment;
      } else {
        return uu5;
      }
    }
  }]);
  return Config;
}();
Config.activeProfiles = [];
Config.callbacks = [];
Config.implicitSources = [];
Config.sources = {};
Config.chain = null;
module.exports = Config;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/context-store.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var GlobalStore = __webpack_require__("../node_modules/uu_appg01_core-utils/src/global-store.js");
var BaseError = __webpack_require__("../node_modules/uu_appg01_core-utils/src/base-error.js");

/**
 * ThreadLocal alike context store.
 */
var ContextStore = /*#__PURE__*/function () {
  /**
   * Creates new instance of context store.
   * @private
   */
  function ContextStore() {
    _classCallCheck(this, ContextStore);
    this._attributes = {};
  }

  /**
   * Stores context attribute.
   * @param key Context attribute name.
   * @param value Context attribute value.
   */
  _createClass(ContextStore, [{
    key: "set",
    value: function set(key, value) {
      this._attributes[key] = value;
    }

    /**
     * Returns context attribute.
     * @param key Context attribute name.
     * @returns {*} Context attribute value.
     */
  }, {
    key: "get",
    value: function get(key) {
      return this._attributes[key];
    }

    /**
     * Deletes context attribute.
     * @param key Context attribute name.
     */
  }, {
    key: "delete",
    value: function _delete(key) {
      delete this._attributes[key];
    }

    /**
     * Binds context store to emitter object. This is necessary to ensure context
     * is visible inside methods invoked by emitter events (like "on data" etc.).
     * @param emitter Emitter object (e.g. stream, socket, etc.)
     */
  }, {
    key: "bind",
    value: function bind(emitter) {
      // Nothing to do in browser environment.
    }

    /**
     * @deprecated Use {@link bind}.
     */
  }, {
    key: "bindEmitter",
    value: function bindEmitter(emitter) {
      this.bind(emitter);
    }

    /**
     * Forks context and runs given function.
     * @param fn Function to which should forked context store be bound.
     * @returns {*} Return value of invoked function.
     */
  }, {
    key: "fork",
    value: function fork(fn) {
      return fn();
    }
  }], [{
    key: "create",
    value:
    /**
     * Creates new context store
     * @param ctxName Context store name.
     * @param fn Function to which should context store be bound.
     * @returns {*} Return value of invoked function.
     */
    function create(ctxName, fn) {
      var contextStores = GlobalStore.get("uuAppContextStores");
      var contextStore = contextStores.get(ctxName);
      if (contextStore) {
        throw new BaseError(`Context "${ctxName}" is already created.`);
      }
      contextStore = new ContextStore();
      contextStores.set(ctxName, contextStore);
      return fn();
    }

    /**
     * Returns context store bound to current context.
     * @param ctxName Context store name.
     * @returns {ContextStore|null} Instance of context store or null.
     */
  }, {
    key: "get",
    value: function get(ctxName) {
      var contextStores = GlobalStore.get("uuAppContextStores");
      return contextStores.get(ctxName) || null;
    }
  }]);
  return ContextStore;
}();
module.exports = ContextStore;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/digest.browser.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var _sha = __webpack_require__("../node_modules/js-sha1/src/sha1.js");
var Digest = /*#__PURE__*/function () {
  function Digest() {
    _classCallCheck(this, Digest);
  }
  _createClass(Digest, null, [{
    key: "sha1",
    value: function sha1(value) {
      return _sha(value);
    }
  }]);
  return Digest;
}();
module.exports = Digest;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/global-store.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var storage = typeof window === "undefined" ? __webpack_require__.g : window;
if (!storage._uuAppGlobalStores) {
  storage._uuAppGlobalStores = {};
}

/**
 * Global storage allowing to share objects accross multiple modules in various versions.
 */
var GlobalStore = /*#__PURE__*/function () {
  /**
   * Creates new instance of global store.
   * @private
   */
  function GlobalStore() {
    _classCallCheck(this, GlobalStore);
    this._attributes = {};
  }

  /**
   * Stores global attribute.
   * @param key Global attribute name.
   * @param value Global attribute value.
   */
  _createClass(GlobalStore, [{
    key: "set",
    value: function set(key, value) {
      this._attributes[key] = value;
    }

    /**
     * Returns global attribute.
     * @param key Global attribute name.
     * @returns {*} Global attribute value.
     */
  }, {
    key: "get",
    value: function get(key) {
      return this._attributes[key];
    }

    /**
     * Deletes global attribute.
     * @param key Global attribute name.
     */
  }, {
    key: "delete",
    value: function _delete(key) {
      delete this._attributes[key];
    }
  }], [{
    key: "get",
    value:
    /**
     * Returns global store with given name.
     * @param storeName Global store name.
     * @returns {GlobalStore} Instance of global store.
     */
    function get(storeName) {
      var store = storage._uuAppGlobalStores[storeName];
      if (!store) {
        store = storage._uuAppGlobalStores[storeName] = new GlobalStore();
      }
      return store;
    }
  }]);
  return GlobalStore;
}();
module.exports = GlobalStore;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  get BaseError() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/base-error.js");
  },
  get Config() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/config/config.js");
  },
  get NameConverter() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/name-converter.js");
  },
  get Loader() {
    return __webpack_require__("?7bb3");
  },
  get ValueConverter() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/value-converter.js");
  },
  get OptsReader() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/opts-reader.js");
  },
  get ContextStore() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/context-store.browser.js");
  },
  get GlobalStore() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/global-store.js");
  },
  get Histogram() {
    return __webpack_require__("?2f8b");
  },
  get DuplicateLibraryValidator() {
    return __webpack_require__("?54d4");
  },
  get Finder() {
    return __webpack_require__("?de5b");
  },
  get Digest() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/digest.browser.js");
  },
  get Mutex() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/mutex.js");
  },
  get LruCache() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/lru-cache.js");
  },
  get Base64() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/base64.js");
  },
  get Json() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/json.js");
  }
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/json.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var POLLUTION_CHECK = /"(((_|\\u005f)(_|\\u005f)(p|\\u0070)(r|\\u0072)(o|\\u006f)(t|\\u0074)(o|\\u006f)(_|\\u005f)(_|\\u005f))|((c|\\u0063)(o|\\u006[Ff])(n|\\u006[Ee])(s|\\u0073)(t|\\u0074)(r|\\u0072)(u|\\u0075)(c|\\u0063)(t|\\u0074)(o|\\u006[Ff])(r|\\u0072)))"/;
var PROTO_KEY = "__proto__";
var CONSTRUCTOR_KEY = "constructor";
var BOOLEAN_TYPE = "boolean";
var OBJECT_TYPE = "object";
var PRUNED_VALUE = "-pruned-";
var Json = /*#__PURE__*/function () {
  function Json() {
    _classCallCheck(this, Json);
  }
  _createClass(Json, null, [{
    key: "parse",
    value: function parse(text) {
      var secure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (secure && POLLUTION_CHECK.test(text)) {
        return JSON.parse(text, function (key, value) {
          return key !== PROTO_KEY && key !== CONSTRUCTOR_KEY ? value : undefined;
        });
      } else {
        return JSON.parse(text);
      }
    }
  }, {
    key: "stringify",
    value: function stringify(value) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof opts === BOOLEAN_TYPE) {
        opts = {
          prettyPrint: opts
        };
      }
      var pruner;
      if (opts && opts.prune) {
        var seen = [];
        pruner = function pruner(key, value) {
          if (!value || typeof value !== OBJECT_TYPE) {
            return value;
          } else if (seen.indexOf(value) !== -1) {
            return PRUNED_VALUE;
          } else {
            seen.push(value);
            return value;
          }
        };
      }
      if (opts && opts.prettyPrint) {
        return JSON.stringify(value, pruner, 2);
      } else {
        return JSON.stringify(value, pruner);
      }
    }
  }]);
  return Json;
}();
module.exports = Json;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/lru-cache.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _slicedToArray = (__webpack_require__("../node_modules/@babel/runtime/helpers/slicedToArray.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Json = __webpack_require__("../node_modules/uu_appg01_core-utils/src/json.js");
var localStorageAvailable;
try {
  var check = localStorage;
  localStorageAvailable = !!check;
} catch (e) {
  localStorageAvailable = false;
}

/**
 * Cache item.
 * @private
 */
var Item = /*#__PURE__*/function () {
  /**
   * Creates new instance of cache item.
   * @param key Item name
   * @param value Item value
   * @param exp Item expiration
   */
  function Item(key, value, exp) {
    _classCallCheck(this, Item);
    this.key = key;
    this.value = value;
    this.exp = exp;
    this.next = null;
    this.prev = null;
  }

  /**
   * Checks if item is expired.
   * @returns {boolean} True if item is expired
   */
  _createClass(Item, [{
    key: "isExpired",
    value: function isExpired() {
      return this.exp > -1 && this.exp <= Date.now();
    }

    /**
     * Returns object representation of cache item.
     * @returns {*[]} Array containing key, value end expiration (in this order)
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      return [this.key, this.value, this.exp];
    }
  }]);
  return Item;
}();
/**
 * Browser friendly implementation of LRU cache with support of persisting
 * cache to browser local storage.
 */
var LruCache = /*#__PURE__*/function () {
  /**
   * Creates new instance of cache.
   * @param {Object|null} opts Cache options
   * @param {number} opts.maxSize Maximal number of items to be stored
   * @param {number} opts.maxAge How long (in milliseconds) should items be stored
   * @param {String} opts.localStorageKey If set, cache will be persisted to browser
   *   local storage. Local storage key should contain product identification to
   *   avoid conflicting names between various components.
   */
  function LruCache() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, LruCache);
    if (typeof opts.maxSize === 'number') {
      this._maxSize = opts.maxSize;
    } else {
      this._maxSize = -1;
    }
    if (typeof opts.maxAge === 'number') {
      this._maxAge = opts.maxAge;
    } else {
      this._maxAge = -1;
    }
    this._name = opts.localStorageKey;
    this._size = 0;
    this._items = {};
    this._first = null;
    this._last = null;
    this._loadFromStorage();
    this._storeToStorage();
  }

  /**
   * Stores value into cache.
   * @param key Key to access cached value
   * @param value Value to be cached
   * @param maxAge How long (in milliseconds) should this value be stored (overrides global maxAge)
   * @returns {*} Value previously stored under this key (or null if none)
   */
  _createClass(LruCache, [{
    key: "set",
    value: function set(key, value) {
      var maxAge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this._loadFromStorage();
      var origValue = null;
      maxAge = typeof maxAge === "number" ? maxAge : this._maxAge;
      var exp = maxAge > -1 ? maxAge + Date.now() : -1;
      var newItem = new Item(key, value, exp);
      // If there is same existing item, delete it
      // (and remember original value to return it)
      if (this._items[key]) {
        origValue = this.delete(key);
      }
      // Set new item to front of list
      this._push(newItem);
      // If cache is full we have to prune it
      if (this._maxSize > -1 && this._size > this._maxSize) {
        this._prune(this._size - this._maxSize);
      }
      this._storeToStorage();
      // Return original value (if any)
      return origValue;
    }

    /**
     * Check if a key is in the cache, without updating the recent-ness or deleting it for being stale.
     * @param {Check} key Key of cached value
     * @returns {boolean} True if key is in cache, else false
     */
  }, {
    key: "has",
    value: function has(key) {
      this._loadFromStorage();
      var item = this._items[key];
      return item && !item.isExpired();
    }

    /**
     * Returns value from cache.
     * @param key Key of cached value
     * @returns {*} Cached value (or null)
     */
  }, {
    key: "get",
    value: function get(key) {
      this._loadFromStorage();
      var item = this._items[key];
      var value = null;
      if (item) {
        if (item.isExpired()) {
          // It item is expired, just delete it
          this._remove(item);
        } else {
          value = item.value;
          this._touch(item);
        }
      }
      this._storeToStorage();
      return value;
    }

    /**
     * Deletes value from cache.
     * @param key Key of cached value
     * @returns {*} Cached value (or null)
     */
  }, {
    key: "delete",
    value: function _delete(key) {
      this._loadFromStorage();
      var value = null;
      if (this._items[key]) {
        var item = this._items[key];
        if (!item.isExpired()) {
          // In case item is not expired, return value of deleted item
          value = item.value;
        }
        this._remove(item);
      }
      this._storeToStorage();
      return value;
    }

    /**
     * Clears cache.
     */
  }, {
    key: "clear",
    value: function clear() {
      this._size = 0;
      this._items = {};
      this._first = null;
      this._last = null;
      this._storeToStorage();
    }

    /**
     * Returns actual cache size.
     * @returns {number}
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return this._size;
    }

    /**
     * Returns object representation of cache item.
     * @returns {Array} List of cached items
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var items = [];
      // Serialize from last to ensure correct order on restore
      var item = this._last;
      while (item) {
        items.push(item.toJSON());
        item = item.prev;
      }
      return [this._maxSize, this._maxAge, items];
    }

    /**
     * Initializes cache from serialized value (clears any existing data).
     * @param json Serialized cache
     */
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      this.clear();
      if (typeof json === "string") {
        json = Json.parse(json);
      }
      var _json = json,
        _json2 = _slicedToArray(_json, 3),
        maxSize = _json2[0],
        maxAge = _json2[1],
        items = _json2[2];
      this._maxSize = maxSize;
      this._maxAge = maxAge;
      var _iterator = _createForOfIteratorHelper(items),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 3),
            key = _step$value[0],
            value = _step$value[1],
            exp = _step$value[2];
          this._push(new Item(key, value, exp));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    /**
     * Return an array of the keys in the cache.
     * @return {Array} List of the keys in the cache.
     */
  }, {
    key: "keys",
    value: function keys() {
      this._loadFromStorage();
      var result = [];
      var item = this._first;
      while (item) {
        if (!item.isExpired()) {
          result.push(item.key);
        }
        item = item.next;
      }
      return result;
    }

    /**
     * Return an array of the values in the cache.
     * @return {Array} List of the values in the cache.
     */
  }, {
    key: "values",
    value: function values() {
      this._loadFromStorage();
      var result = [];
      var item = this._first;
      while (item) {
        if (!item.isExpired()) {
          result.push(item.value);
        }
        item = item.next;
      }
      return result;
    }

    /**
     * Iterates through cached items (from newest to oldest)
     * @param callback Function receiving two parameters - item key and value.
     *    Function may return false to stop the loop.
     */
  }, {
    key: "forEach",
    value: function forEach(callback) {
      if (typeof callback !== 'function') {
        throw new BaseError(`Parameter must be function`);
      }
      this._loadFromStorage();
      var item = this._first;
      while (item) {
        var doNext = null;
        if (!item.isExpired()) {
          doNext = callback(item.key, item.value);
        }
        if (typeof doNext === 'boolean' && !doNext) {
          break;
        } else {
          item = item.next;
        }
      }
    }

    /**
     * Pushes new item to cache.
     * @param item Cached item
     * @private
     */
  }, {
    key: "_push",
    value: function _push(item) {
      // Set previous first item after new item
      item.next = this._first;
      item.prev = null;
      if (this._first) {
        this._first.prev = item;
      }
      // Set new item to first place
      this._first = item;
      if (!this._last) {
        // If case was emtpy, first item is also last
        this._last = item;
      }
      // Store the item
      this._items[item.key] = item;
      this._size++;
    }

    /**
     * Moves item to fist position.
     * @param item Touched item
     * @private
     */
  }, {
    key: "_touch",
    value: function _touch(item) {
      // If item is already first do nothing
      if (item.prev) {
        // Link previous item with next of moved item
        item.prev.next = item.next;
        if (item.next) {
          // Link next item with prev of moded item
          item.next.prev = item.prev;
        } else {
          // In case we are moving last item, update tail
          this._last = item.prev;
        }
        // Set previous first item after moved item
        item.next = this._first;
        item.prev = null;
        if (this._first) {
          this._first.prev = item;
        }
        // Set moved item to first place
        this._first = item;
      }
    }

    /**
     * Removes item from cache.
     * @param item Item to be removed
     * @private
     */
  }, {
    key: "_remove",
    value: function _remove(item) {
      if (item.prev) {
        // Link previous item with next of deleted item
        item.prev.next = item.next;
      } else {
        // In case we are deleting first item, update head
        this._first = item.next;
      }
      if (item.next) {
        // Link next item with prev of deleted item
        item.next.prev = item.prev;
      } else {
        // In case we are deleting last item, update tail
        this._last = item.prev;
      }
      // Delete the item
      delete this._items[item.key];
      this._size--;
    }

    /**
     * Prune at least specified number of items, first delete
     * expired ones, then delete from last item until given
     * number of items to be deleted is reached.
     * @param atLeast Number of items to be removed
     * @private
     */
  }, {
    key: "_prune",
    value: function _prune() {
      var atLeast = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var deleted = 0;
      // Delete all expired items first
      var item = this._last;
      while (item) {
        if (item.isExpired()) {
          this._remove(item);
          deleted++;
        }
        item = item.prev;
      }
      // Delete remaining number of items
      if (deleted < atLeast) {
        var _item = this._last;
        for (var i = 0; i < atLeast - deleted; i++) {
          this._remove(_item);
          _item = _item.prev;
          // Break in case all items are gone
          if (!_item) {
            break;
          }
        }
      }
    }

    /**
     * If available, deserializes cache content from browser local storage.
     * @private
     */
  }, {
    key: "_loadFromStorage",
    value: function _loadFromStorage() {
      if (localStorageAvailable && this._name) {
        var persistedCache = localStorage.getItem(this._name);
        if (persistedCache) {
          this.fromJSON(persistedCache);
        }
      }
    }

    /**
     * If available, serilalizes cache content to browser local storage.
     * @private
     */
  }, {
    key: "_storeToStorage",
    value: function _storeToStorage() {
      if (localStorageAvailable && this._name) {
        localStorage.setItem(this._name, Json.stringify(this));
      }
    }
  }]);
  return LruCache;
}();
module.exports = LruCache;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/mutex.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = (__webpack_require__("../node_modules/@babel/runtime/helpers/regeneratorRuntime.js")["default"]);
var _asyncToGenerator = (__webpack_require__("../node_modules/@babel/runtime/helpers/asyncToGenerator.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Digest = __webpack_require__("../node_modules/uu_appg01_core-utils/src/digest.browser.js");
var Json = __webpack_require__("../node_modules/uu_appg01_core-utils/src/json.js");

/**
 * Component providing synchronization methods
 * for running asynchronous functions.
 */
var Mutex = /*#__PURE__*/function () {
  /**
   * Creates new instance of Mutex.
   */
  function Mutex() {
    _classCallCheck(this, Mutex);
    this._promises = {};
  }

  /**
   * Ensures given functionality is invoked only once at a time. Method internally
   * computes functionality invocation signature (or used given one) and in case
   * functionality with same signature as already running one is requested, it does
   * not perform new invocation but returns result of previous one.
   * @param sig Invocation signature which should be unique for given function
   *   and/or function argument values. If not given, default signature is
   *   computed as "${fn.name}:${sha1(JSON.stringify(args))}"
   * @param fn Function to be invoked
   * @param args Function arguments
   * @returns {Promise<*>} Result of invoked function
   */
  _createClass(Mutex, [{
    key: "runOneAtTime",
    value: function runOneAtTime() {
      var _this = this;
      var sig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var fn = arguments.length > 1 ? arguments[1] : undefined;
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      if (typeof sig === "function") {
        args.unshift(fn);
        fn = sig;
        sig = null;
      }
      var signature = sig || this._getSignature.apply(this, [fn].concat(args));
      var promise = this._promises[signature];
      if (!promise || promise._finished) {
        promise = this._invokeFn.apply(this, [fn].concat(args));
        promise._finished = false;
        this._promises[signature] = promise;
        var finalize = function finalize() {
          promise._finished = true;
          delete _this._promises[signature];
        };
        promise.then(finalize, finalize);
      }
      return promise;
    }

    /**
     * Ensures given functionality is invoked after previously given one is finished.
     * @param fn Function to be invoked
     * @param args Function arguments
     * @returns {PromiseLike<*>} Result of invoked function
     */
  }, {
    key: "runInBand",
    value: function runInBand(fn) {
      var _this2 = this;
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      var prevPromise = this._promises["runInBand"];
      var nextPromise;
      if (!prevPromise || prevPromise._finished) {
        nextPromise = this._invokeFn.apply(this, [fn].concat(args));
      } else {
        var runNext = function runNext() {
          return _this2._invokeFn.apply(_this2, [fn].concat(args));
        };
        nextPromise = prevPromise.then(runNext, runNext);
      }
      nextPromise._finished = false;
      this._promises["runInBand"] = nextPromise;
      var finalize = function finalize() {
        nextPromise._finished = true;
      };
      nextPromise.then(finalize, finalize);
      return nextPromise;
    }
  }, {
    key: "_getSignature",
    value: function _getSignature(fn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      var argsString = Json.stringify(args, {
        pruned: true
      });
      var argsHash = Digest.sha1(argsString);
      return `${fn.name}:${argsHash}`;
    }
  }, {
    key: "_invokeFn",
    value: function _invokeFn(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      if (fn.constructor.name === 'AsyncFunction') {
        return fn.apply(void 0, args);
      } else {
        var asyncWrapper = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", fn.apply(void 0, args));
                case 1:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function asyncWrapper() {
            return _ref.apply(this, arguments);
          };
        }();
        return asyncWrapper();
      }
    }
  }], [{
    key: "sleep",
    value:
    /**
     * Allows to suspend processing of method for given time. Returns the actual
     * number of milliseconds the processing was suspended, which is typically
     * slightly higher than given time (due to delay of callback invocation).
     * @param ms Number of milliseconds to sleep
     * @returns {Promise<number>} Number of milliseconds actually slept
     */
    function () {
      var _sleep = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ms) {
        var initiated;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              initiated = Date.now();
              return _context2.abrupt("return", new Promise(function (resolve) {
                setTimeout(function () {
                  return resolve(Date.now() - initiated);
                }, ms);
              }));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function sleep(_x) {
        return _sleep.apply(this, arguments);
      }
      return sleep;
    }()
  }, {
    key: "yield",
    value:
    /**
     * Allows to split long running functions to multiple segments in order to prevent
     * blocking of thread by long running operations (e.g. it can be called in each loop).
     * @returns {Promise<number>} Number of milliseconds how long function was interrupted
     */
    function () {
      var _yield2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var initiated, interrupt;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              initiated = Date.now();
              interrupt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }))();
              return _context4.abrupt("return", interrupt.then(function () {
                return Date.now() - initiated;
              }));
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function _yield() {
        return _yield2.apply(this, arguments);
      }
      return _yield;
    }()
  }]);
  return Mutex;
}();
module.exports = Mutex;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/name-converter.js":
/***/ (function(module) {

/**
 * Convert nameSpace to file path
 * @param str
 * @returns {string|string}
 * @constructor
 */
function NameConverter(str) {
  var REGEX = /^([_]*[$@#]?)?(?:[a-zA-Z0-9]+(?:[_]+[a-zA-Z0-9]+)?)*([_]+)?$/;
  function _scan(s, re) {
    if (!re.global) throw "Name Converter Error";
    var m = re.exec(s),
      r = [];
    while (m) {
      m.shift();
      r.push(m);
      m = re.exec(s);
    }
    return r;
  }
  var strings = [];
  var result = "";
  str.match(REGEX);
  var prefix = str.match(/^[_]*/)[0];
  str = str.substring(prefix.length, str.length);
  var postfix = str.match(/[_]*$/)[0];
  str = str.substring(0, str.length - postfix.length);
  var befIndex = 0;
  _scan(str, /[a-z]+|[A-Z]+|[0-9]+/g).forEach(function (val) {
    var index = val["index"];
    strings.push(str.substring(befIndex, index));
    befIndex = index;
  });
  strings.push(str.substring(befIndex));
  if (strings[0] === "/" || strings[0] === "\\") strings.shift();
  for (var i = 0; i < strings.length; i += 1) {
    var act = strings[i];
    var nxt = strings[i + 1];
    if (act.match(/^[a-z]+|[0-9]+$/)) {
      result += act;
      result += nxt !== undefined ? "-" : "";
    } else if (act.match(/^[A-Z]$/)) {
      result += act.toLowerCase();
    } else if (act.match(/^[A-Z]+$/)) {
      if (nxt === undefined || nxt.match(/^[0-9]+$/)) {
        result += act.toLowerCase();
        result += nxt !== undefined ? "-" : "";
      } else {
        result += act.substring(0, act.length - 1).toLowerCase();
        result += "-";
        result += act[act.length - 1].toLowerCase();
      }
    }
  }
  result = prefix + result + postfix;
  return result;
}
module.exports = NameConverter;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/opts-reader.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _createForOfIteratorHelper = (__webpack_require__("../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js")["default"]);
var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var Config = __webpack_require__("../node_modules/uu_appg01_core-utils/src/config/config.js");
var ValueConverter = __webpack_require__("../node_modules/uu_appg01_core-utils/src/value-converter.js");

/**
 * Component for reading option from multiple option
 * sources with support for providing default values
 * and basic type conversions.
 * Example:
 *   reader = new OptsReader(opts1, opts2, Config);
 *   anyType = reader.get("opt_key")
 *   number = reader.getNumber("opt_key", 42)
 */
var OptsReader = /*#__PURE__*/function () {
  /**
   * Creates new instance of options reader.
   * @param opts List of option sources to be read
   *   (ordered by priority from highest to lowest).
   */
  function OptsReader() {
    _classCallCheck(this, OptsReader);
    for (var _len = arguments.length, opts = new Array(_len), _key = 0; _key < _len; _key++) {
      opts[_key] = arguments[_key];
    }
    this._optList = opts;
  }

  /**
   * Returns option with given name or default value
   * if none of option sources provide required option.
   * @param key Option name.
   * @param defaultValue Default options value.
   * @returns {*}
   */
  _createClass(OptsReader, [{
    key: "get",
    value: function get(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var value = null;
      var _iterator = _createForOfIteratorHelper(this._optList),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var opts = _step.value;
          if (opts === Config) {
            if (opts.hasKey(key, false)) {
              value = opts.get(key, false);
            }
          } else if (opts) {
            if (opts.hasOwnProperty(key) && opts[key] !== undefined) {
              value = opts[key];
            }
          }
          if (value != null) {
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (value == null) {
        value = defaultValue;
      }
      return value;
    }

    /**
     * Checks if any of option sources provide
     * option with given name.
     * @param key Option name.
     * @returns {Boolean} True if option exists.
     */
  }, {
    key: "hasKey",
    value: function hasKey(key) {
      var _iterator2 = _createForOfIteratorHelper(this._optList),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var opts = _step2.value;
          if (opts === Config) {
            if (opts.hasKey(key)) {
              return true;
            }
          } else if (opts) {
            if (opts.hasOwnProperty(key) && opts[key] !== undefined) {
              return true;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return false;
    }

    /**
     * Returns string value created from option with given
     * name or default value if none of options sources provide
     * required option.
     * @param key Option name.
     * @param defaultValue Default options value.
     * @returns {String}
     */
  }, {
    key: "getString",
    value: function getString(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var value = this.get(key, defaultValue);
      return ValueConverter.toString(value);
    }

    /**
     * Returns number value created from option with given
     * name or default value if none of options sources provide
     * required option.
     * @param key Option name.
     * @param defaultValue Default options value.
     * @returns {Number}
     */
  }, {
    key: "getNumber",
    value: function getNumber(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var value = this.get(key, defaultValue);
      return ValueConverter.toNumber(value);
    }

    /**
     * Returns boolean value created from option with given
     * name or default value if none of options sources provide
     * required option.
     * @param key Option name.
     * @param defaultValue Default options value.
     * @returns {Boolean}
     */
  }, {
    key: "getBoolean",
    value: function getBoolean(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var value = this.get(key, defaultValue);
      return ValueConverter.toBoolean(value);
    }

    /**
     * Returns time value created from option with given
     * name or default value if none of options sources provide
     * required option.
     * @param key Option name.
     * @param defaultValue Default options value.
     * @returns {Date}
     */
  }, {
    key: "getTime",
    value: function getTime(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var value = this.get(key, defaultValue);
      return ValueConverter.toTime(value);
    }

    /**
     * Returns class value created from option with given
     * name or default value if none of options sources provide
     * required option.
     * @param key Option name.
     * @param sourcePath Path to app/library source folder (app|src) from where to load class.
     * @param defaultValue Default options value.
     * @returns {Function}
     */
  }, {
    key: "getClass",
    value: function getClass(key, sourcePath) {
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var value = this.get(key, defaultValue);
      return ValueConverter.toClass(value, sourcePath);
    }

    /**
     * Returns array value created from option with given
     * name or default value if none of options sources provide
     * required option.
     * @param key Option name.
     * @param type If set, all array items will be converted to
     *   given type (one of "string", "number", "boolean", "time", "class")
     * @param defaultValue Default options value.
     * @param sourcePath Path to app/library source folder (app|src) from where to load class
     *   Required for "class" conversion.
     * @returns {Array}
     */
  }, {
    key: "getArray",
    value: function getArray(key) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var sourcePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var value = this.get(key, defaultValue);
      return ValueConverter.toArray(value, type, sourcePath);
    }
  }]);
  return OptsReader;
}();
module.exports = OptsReader;

/***/ }),

/***/ "../node_modules/uu_appg01_core-utils/src/value-converter.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _classCallCheck = (__webpack_require__("../node_modules/@babel/runtime/helpers/classCallCheck.js")["default"]);
var _createClass = (__webpack_require__("../node_modules/@babel/runtime/helpers/createClass.js")["default"]);
var BaseError = __webpack_require__("../node_modules/uu_appg01_core-utils/src/base-error.js");
var Loader = __webpack_require__("?7bb3");
var INVALID_DATE = new Date("foo");

/**
 * Helper for converting values to different basic types.
 */
var ValueConverter = /*#__PURE__*/function () {
  function ValueConverter() {
    _classCallCheck(this, ValueConverter);
  }
  _createClass(ValueConverter, null, [{
    key: "toString",
    value:
    /**
     * Converts value to string.
     * @param value Value to be converted.
     * @returns {String} Converted value.
     */
    function toString(value) {
      if (value === null || value === undefined) {
        return null;
      } else {
        return value.toString();
      }
    }

    /**
     * Converts value to number.
     * @param value Value to be converted.
     * @returns {Number} Converted value.
     */
  }, {
    key: "toNumber",
    value: function toNumber(value) {
      if (value === null || value === undefined) {
        return null;
      } else if (typeof value === "number") {
        return value;
      } else if (typeof value === "string") {
        if (/^[+-]?[\d]+(\.[\d]+)?([eE][+-]?[\d]+)?$/.test(value)) {
          return Number(value);
        } else {
          throw new BaseError(`No implicit conversion of "${value}" to number`);
        }
      } else {
        throw new BaseError(`No implicit conversion of "${typeof value}" to number`);
      }
    }

    /**
     * Converts value to boolean.
     * @param value Value to be converted.
     * @returns {Boolean} Converted value.
     */
  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      if (value === null || value === undefined) {
        return null;
      } else if (typeof value === "boolean") {
        return value;
      } else if (typeof value === "number") {
        return value !== 0;
      } else if (typeof value === "string") {
        if (/^(false|0)$/i.test(value)) {
          return false;
        } else if (/^(true|1)$/i.test(value)) {
          return true;
        } else {
          throw new BaseError(`No implicit conversion of "${value}" to boolean`);
        }
      } else {
        throw new BaseError(`No implicit conversion of "${typeof value}" to boolean`);
      }
    }

    /**
     * Converts value to time.
     * @param value Value to be converted.
     * @returns {Date} Converted value.
     */
  }, {
    key: "toTime",
    value: function toTime(value) {
      if (value === null || value === undefined) {
        return null;
      } else if (value instanceof Date) {
        return value;
      } else if (typeof value === "number") {
        return new Date(value);
      } else if (typeof value === "string") {
        var date = new Date(value);
        if (date.toString() === INVALID_DATE.toString()) {
          throw new BaseError(`No implicit conversion of "${value}" to time`);
        } else {
          return date;
        }
      } else {
        throw new BaseError(`No implicit conversion of "${typeof value}" to time`);
      }
    }

    /**
     * Converts value to class.
     * @param value Value to be converted.
     * @param sourcePath Path to app/library source folder (app|src) from where to load class.
     * @returns {Function} Converted value.
     */
  }, {
    key: "toClass",
    value: function toClass(value, sourcePath) {
      if (value === null || value === undefined) {
        return null;
      } else if (typeof value === "function") {
        // TODO Check that function is constructor
        return value;
      } else if (typeof value === "string") {
        if (sourcePath === null || sourcePath === undefined) {
          throw new BaseError("Parameter sourcePath is required to resolve class from string");
        }
        return Loader.loadRealization(sourcePath, value, false);
      } else {
        return value.constructor;
      }
    }

    /**
     * Converts value to array of given types.
     * @param value Value to be converted.
     * @param type If set, all array items will be converted to
     *   given type (one of "string", "number", "boolean", "time", "class")
     * @param sourcePath Path to app/library source folder (app|src) from where to load class
     *   Required for "class" conversion.
     * @returns {Array} Converted value.
     */
  }, {
    key: "toArray",
    value: function toArray(value) {
      var _this = this;
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sourcePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var arr = null;
      if (value === null || value === undefined) {
        return null;
      } else if (value instanceof Array) {
        arr = value;
      } else if (typeof value === "string") {
        arr = value.split(/[ ]*,[ ]*/);
      } else {
        arr = [value];
      }
      switch (type) {
        case null:
        case undefined:
          // No conversion
          break;
        case "string":
          arr = arr.map(function (item) {
            return _this.toString(item);
          });
          break;
        case "number":
          arr = arr.map(function (item) {
            return _this.toNumber(item);
          });
          break;
        case "boolean":
          arr = arr.map(function (item) {
            return _this.toBoolean(item);
          });
          break;
        case "time":
          arr = arr.map(function (item) {
            return _this.toTime(item);
          });
          break;
        case "class":
          arr = arr.map(function (item) {
            return _this.toClass(item, sourcePath);
          });
          break;
        default:
          throw new BaseError(`Unknown conversion type "${type}"`);
      }
      return arr;
    }
  }]);
  return ValueConverter;
}();
module.exports = ValueConverter;

/***/ }),

/***/ "./index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  get AppClient() {
    var AppClient = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/index.js");
    // support legacy API
    AppClient.Client = AppClient.AppClient;
    return AppClient;
  },
  get Uri() {
    return __webpack_require__("../node_modules/uu_appg01_core-uri/src/index.js");
  },
  get Logging() {
    return __webpack_require__("../node_modules/uu_appg01_core-logging/src/index.browser.js");
  },
  get Util() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js");
  },
  get Utils() {
    return __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js");
  },
  get Perflog() {
    return __webpack_require__("../node_modules/uu_appg01_core-perflog/src/index.browser.js");
  },
  get Authentication() {
    return __webpack_require__("../node_modules/uu_appg01_core-authentication/src/index.js");
  },
  get Error() {
    var Utils = __webpack_require__("../node_modules/uu_appg01_core-utils/src/index.js");
    return {
      Error: Utils.BaseError
    };
  }
};

/***/ }),

/***/ "../target/webpack-tmp/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var mod = __webpack_require__("module");
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/5.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/5.19.0/";
__webpack_require__.p = (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\]*$/, "") : uri;
module.exports = __webpack_require__("./index.js");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", {
    configurable: true,
    value: "5.19.0"
  });
  if (!("name" in ex)) Object.defineProperty(ex, "name", {
    configurable: true,
    value: "uu_appg01_core".split(/[\/\\]/).pop()
  });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", {
    configurable: true,
    value: "UuApp"
  });
}

/***/ }),

/***/ "module":
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_module__;

/***/ }),

/***/ "?9d51":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?17bb":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?c2ca":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?1988":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?54d4":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?de5b":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?2f8b":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?7bb3":
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/AsyncGenerator.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var OverloadYield = __webpack_require__("../node_modules/@babel/runtime/helpers/OverloadYield.js");
function AsyncGenerator(gen) {
  var front, back;
  function resume(key, arg) {
    try {
      var result = gen[key](arg),
        value = result.value,
        overloaded = value instanceof OverloadYield;
      Promise.resolve(overloaded ? value.v : value).then(function (arg) {
        if (overloaded) {
          var nextKey = "return" === key ? "return" : "next";
          if (!value.k || arg.done) return resume(nextKey, arg);
          arg = gen[nextKey](arg).value;
        }
        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }
  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: !0
        });
        break;
      case "throw":
        front.reject(value);
        break;
      default:
        front.resolve({
          value: value,
          done: !1
        });
    }
    (front = front.next) ? resume(front.key, front.arg) : back = null;
  }
  this._invoke = function (key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };
      back ? back = back.next = request : (front = back = request, resume(key, arg));
    });
  }, "function" != typeof gen["return"] && (this["return"] = void 0);
}
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
}, AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
}, AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
}, AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};
module.exports = AsyncGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/OverloadYield.js":
/***/ (function(module) {

function _OverloadYield(value, kind) {
  this.v = value, this.k = kind;
}
module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/***/ (function(module) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/***/ (function(module) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__("../node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/***/ (function(module) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/asyncIterator.js":
/***/ (function(module) {

function _asyncIterator(iterable) {
  var method,
    async,
    sync,
    retry = 2;
  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }
  return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function next() {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    "return": function _return(value) {
      var ret = this.s["return"];
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    "throw": function _throw(value) {
      var thr = this.s["return"];
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}
module.exports = _asyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/***/ (function(module) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var OverloadYield = __webpack_require__("../node_modules/@babel/runtime/helpers/OverloadYield.js");
function _awaitAsyncGenerator(value) {
  return new OverloadYield(value, 0);
}
module.exports = _awaitAsyncGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/classCallCheck.js":
/***/ (function(module) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/construct.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("../node_modules/@babel/runtime/helpers/setPrototypeOf.js");
var isNativeReflectConstruct = __webpack_require__("../node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _construct.apply(null, arguments);
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/createClass.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPropertyKey = __webpack_require__("../node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var unsupportedIterableToArray = __webpack_require__("../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/createSuper.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__("../node_modules/@babel/runtime/helpers/getPrototypeOf.js");
var isNativeReflectConstruct = __webpack_require__("../node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");
var possibleConstructorReturn = __webpack_require__("../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
function _createSuper(Derived) {
  var hasNativeReflectConstruct = isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
module.exports = _createSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/defineProperty.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPropertyKey = __webpack_require__("../node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/get.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var superPropBase = __webpack_require__("../node_modules/@babel/runtime/helpers/superPropBase.js");
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/***/ (function(module) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/inherits.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("../node_modules/@babel/runtime/helpers/setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/isNativeFunction.js":
/***/ (function(module) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/***/ (function(module) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/iterableToArray.js":
/***/ (function(module) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/***/ (function(module) {

function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/nonIterableRest.js":
/***/ (function(module) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/***/ (function(module) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/objectSpread2.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = __webpack_require__("../node_modules/@babel/runtime/helpers/defineProperty.js");
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__("../node_modules/@babel/runtime/helpers/typeof.js")["default"]);
var assertThisInitialized = __webpack_require__("../node_modules/@babel/runtime/helpers/assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__("../node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/***/ (function(module) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/slicedToArray.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__("../node_modules/@babel/runtime/helpers/arrayWithHoles.js");
var iterableToArrayLimit = __webpack_require__("../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
var unsupportedIterableToArray = __webpack_require__("../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableRest = __webpack_require__("../node_modules/@babel/runtime/helpers/nonIterableRest.js");
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/superPropBase.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__("../node_modules/@babel/runtime/helpers/getPrototypeOf.js");
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/toConsumableArray.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__("../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
var iterableToArray = __webpack_require__("../node_modules/@babel/runtime/helpers/iterableToArray.js");
var unsupportedIterableToArray = __webpack_require__("../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableSpread = __webpack_require__("../node_modules/@babel/runtime/helpers/nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/toPrimitive.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__("../node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/toPropertyKey.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__("../node_modules/@babel/runtime/helpers/typeof.js")["default"]);
var toPrimitive = __webpack_require__("../node_modules/@babel/runtime/helpers/toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/typeof.js":
/***/ (function(module) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__("../node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var AsyncGenerator = __webpack_require__("../node_modules/@babel/runtime/helpers/AsyncGenerator.js");
function _wrapAsyncGenerator(fn) {
  return function () {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}
module.exports = _wrapAsyncGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__("../node_modules/@babel/runtime/helpers/getPrototypeOf.js");
var setPrototypeOf = __webpack_require__("../node_modules/@babel/runtime/helpers/setPrototypeOf.js");
var isNativeFunction = __webpack_require__("../node_modules/@babel/runtime/helpers/isNativeFunction.js");
var construct = __webpack_require__("../node_modules/@babel/runtime/helpers/construct.js");
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _wrapNativeSuper(Class);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	!function() {
/******/ 		__webpack_require__.amdO = {};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("../target/webpack-tmp/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});